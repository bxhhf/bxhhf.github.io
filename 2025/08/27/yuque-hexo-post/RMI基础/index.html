

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#ADD8E6">
  <meta name="author" content="bxhhf">
  <meta name="keywords" content="">
  
    <meta name="description" content="RMI 调用的流程及可能出现的反序列化攻击点">
<meta property="og:type" content="article">
<meta property="og:title" content="RMI基础">
<meta property="og:url" content="https://bxhhf.github.io/2025/08/27/yuque-hexo-post/RMI%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="bxhhf">
<meta property="og:description" content="RMI 调用的流程及可能出现的反序列化攻击点">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755326934324-f7c7013a-5ef3-489f-b2f0-d12df309a52a.jpeg">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755443990338-694be342-01d9-4eed-b38d-d6efad5791f2.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755501829173-994fdb53-52b6-496d-921a-cca95c42ccb0.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755501861880-a1bfd1d0-23ef-4db6-8108-d5ff6d01560e.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755502879164-02181194-f392-450b-9260-8251990d4bab.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755606449508-4974bff1-ef07-49ea-b18f-14b1ae87de84.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755617034980-6888c721-73a7-4816-a094-793c859c0b43.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755617680801-eed19bb8-7634-4d35-8ddd-275bb1cd85ca.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755617823425-dbe143e5-921a-45c3-a37a-cc036473a4e0.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755619335370-9076f8be-ff9b-46d2-b8c7-a2fd10feb92f.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755651940133-5ece89a2-2e2f-487e-a0cb-aaf4b55334fe.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755652020758-c91521a5-fa59-41a2-96ae-95b3f26c12d4.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755652093500-f67e6f73-db5c-4353-9325-dbbec9569d6c.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755828539466-30d9031b-6520-45ab-863a-9d9aaaacdae9.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755869443528-e117172c-5c35-4afc-8654-d87126f86794.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755871694915-14b95b1f-2ab5-4e4e-ac6e-a4d378a30f0a.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755925050327-4cbfc2be-d426-4750-a622-bcbb9cf47964.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755924564318-a25f1686-4fb5-4143-8215-759cc0237e96.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755938737556-48318753-d4cc-4f8d-b71c-8567ab752941.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755959806478-ba8872cb-bce8-4542-b3c7-5f0b52759867.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755960323419-d3ba3bcd-730d-47ab-9984-d1870cf2b054.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756003901829-27d52239-26f4-46c8-9044-59eb033ea003.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756003967785-8ce4aa8b-3913-4ce3-9dba-313a7ed593b4.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756004387676-6c6484c6-c99d-4ff4-a695-eb3ef8cbf2da.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2025/png/56492498/1756006466253-b3686d85-c955-4d67-a772-086f1669ea00.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756029465440-30f2f79b-5ab2-4656-bbf4-e55d4a6b8dfd.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756019675465-4dfe0c1d-7615-499b-a12e-25aa351e1977.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756018836999-73271755-bbde-4680-a530-fda208d5901e.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756030310383-2ad079cb-c2d3-4703-82b2-a8626aab6c0b.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756030732534-3c4f67ad-04c8-41cc-9c17-3a6a1e200d9e.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756031147167-da024ce7-9d84-4875-8c45-6eda7b01e934.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756048718442-3d9ac659-9eec-4fc6-b63b-b0a9fc49b07a.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756048793768-8fbae2d0-13e6-42b8-b9c6-b82179651b8b.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756088667246-7bea2bf4-9cc9-497e-87bc-0ff2ccd3714d.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756092318874-f1c72a0f-79cc-428f-bbcd-2341220fbdf8.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756092394922-565456c4-4b4f-4544-a923-3fb9deb34ddf.png">
<meta property="og:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756115098629-70b81ed1-70bf-446d-a770-3ec74d67eb36.png">
<meta property="article:published_time" content="2025-08-27T11:23:20.000Z">
<meta property="article:modified_time" content="2025-08-27T12:25:49.976Z">
<meta property="article:author" content="bxhhf">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755326934324-f7c7013a-5ef3-489f-b2f0-d12df309a52a.jpeg">
  
  
  
  <title>RMI基础 - bxhhf</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/lxgw-wenkai-screen-webfont/1.7.0/style.min.css">
<link rel="stylesheet" href="//at.alicdn.com/t/c/font_3846514_kabxni94auf.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/shubiao.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/gundongtiao.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/gradient.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"bxhhf.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"enable":true,"app_id":"AN6AZUYA9oJo0TesuVqbgX1I-gzGzoHsz","app_key":"gbgqDB024hr2I7jmwbO6Mz2a","server_url":"https://an6azuya.lc-cn-n1-shared.com","enable_sync":false,"path":"window.location.pathname","ignore_local":true},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://registry.npmmirror.com/lxgw-wenkai-screen-web/latest/files/style.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong class="navbar-title">bxhhf</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/8.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.1)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="RMI基础"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-08-27 19:23" pubdate>
          2025年8月27日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          91 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">RMI基础</h1>
            
              <p id="updated-time" class="note note-info" style="">
                
                  
                    本文最后更新于 2025年8月27日 晚上
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p><font style="color:rgb(26, 26, 26);">RMI 调用的流程及可能出现的反序列化攻击点</font></p>
<span id="more"></span>

<h1 id="一-RMI-简述"><a href="#一-RMI-简述" class="headerlink" title="一. RMI 简述"></a>一. RMI 简述</h1><h2 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h2><p><font style="color:rgb(77, 77, 77);">RMI 是 Java 中的一种技术，全称为远程方法调用。它的作用是允许你在不同的 </font><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020"><font style="color:rgb(77, 77, 77);">Java 虚拟机</font></a><font style="color:rgb(77, 77, 77);">（JVM）之间进行通信，就像在同一个 JVM 中调用方法一样，调用远程方法。这些</font><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020"><font style="color:rgb(77, 77, 77);">虚拟机</font></a><font style="color:rgb(77, 77, 77);">可以在不同的主机上、也可以在同一个主机上。</font></p>
<p><font style="color:rgb(77, 77, 77);"></font></p>
<p><font style="color:rgb(77, 77, 77);">先了解一下 RMI 中涉及到的三个角色，它们分别为服务端，注册中心和客户端</font></p>
<p>还有这两个：</p>
<pre><code class="hljs">- **存根/桩(Stub):**远程对象在客户端上的代理，囊括了远程对象的具体信息，客户端可以通过这个代理和服务端进行交互。&lt;font style=&quot;color:rgb(85, 85, 85);background-color:rgb(42, 42, 42) !important;&quot;&gt;Stub 类实际上是一个动态代理类，类名为&lt;/font&gt; `ClassName`+`_Stub`&lt;font style=&quot;color:rgb(85, 85, 85);background-color:rgb(42, 42, 42) !important;&quot;&gt;，由于是代理类，其会继承所有的接口 。&lt;/font&gt;
- **骨架(Skeleton):**可以看作为服务端的一个代理，用来处理Stub发送过来的请求，然后去调用客户端需要的请求方法，最终将方法执行结果返回给Stub。&lt;font style=&quot;color:rgb(85, 85, 85);background-color:rgb(42, 42, 42) !important;&quot;&gt;Skeleton 也是一个动态代理类，类名为 &lt;/font&gt;`&lt;font style=&quot;color:rgb(85, 85, 85);background-color:rgb(42, 42, 42) !important;&quot;&gt;ClassName&lt;/font&gt;`&lt;font style=&quot;color:rgb(85, 85, 85);background-color:rgb(42, 42, 42) !important;&quot;&gt;+&lt;/font&gt;`&lt;font style=&quot;color:rgb(85, 85, 85);background-color:rgb(42, 42, 42) !important;&quot;&gt;_Skel&lt;/font&gt;`&lt;font style=&quot;color:rgb(85, 85, 85);background-color:rgb(42, 42, 42) !important;&quot;&gt; 。&lt;/font&gt;
</code></pre>
<p><img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755326934324-f7c7013a-5ef3-489f-b2f0-d12df309a52a.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>两句话说明：</p>
<p>服务端创建远程对象，将其绑定到注册中心上，从注册中心获取了远程对象后进行服务端方法的调用</p>
<p>客户端通过 Stub 代理来调用远程对象，Stub 把请求交给 Skeleton，再由 Skeleton 调用真正的 <code>RemoteObjImpl</code>。</p>
<h2 id="1-2-RMI-实现"><a href="#1-2-RMI-实现" class="headerlink" title="1.2 RMI 实现"></a><font style="color:rgb(77, 77, 77);">1.2 RMI 实现</font></h2><blockquote>
<p>客户端和服务端需要写相同接口，服务器端进行实现接口，客户端远程调用在接口实现类中的方法</p>
</blockquote>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p><font style="color:#213BC0;">远程调用接口</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">package org.example;<br><br>import java.rmi.Remote;<br>import java.rmi.RemoteException;<br><br>public interface IRemoteObj extends Remote &#123;<br><br>    public String sayhello(String keywords) throws RemoteException;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：</p>
<p>具备远程调用的接口要<strong>继承 Remote</strong>，该接口是一个空接口，只作为 RMI 标识接口，并且具备远程调用的接口中的方法要抛出异常 RemoteException</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">public interface Remote &#123;&#125;<br></code></pre></td></tr></table></figure>

<p><font style="color:#213BC0;">接口的实现类：</font></p>
<ul>
<li>实现方法写在服务端：远程对象调用的是服务端的方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plain">package org.example;<br><br>import java.rmi.RemoteException;<br>import java.rmi.server.UnicastRemoteObject;<br><br>public class RemoteObjImpl extends UnicastRemoteObject implements IRemoteObj &#123;<br><br>    public RemoteObjImpl() throws RemoteException &#123;<br>    &#125;<br><br><br>    @Override<br>    public String sayhello(String keywords) throws RemoteException &#123;<br>        String upKeywords = keywords.toUpperCase();<br>        System.out.println(upKeywords);<br>        return upKeywords;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：</p>
<p>接口的实现类要继承 UnicastRemoteObject (该类提供了很多支持 RMI 的方法，用于生成 Stub 对象以及生成 Skeleton)</p>
<hr>
<p><font style="color:#213BC0;">RMIServer:</font><font style="color:#000000;">创建远程对象。创建注册中心管理端口它的默认端口 1099。然后将远程对象绑定到注册中心上</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">package org.example;<br><br>import java.rmi.AlreadyBoundException;<br>import java.rmi.RemoteException;<br>import java.rmi.registry.LocateRegistry;<br>import java.rmi.registry.Registry;<br><br>public class RMIServer &#123;<br>    public static void main(String[] args) throws RemoteException, AlreadyBoundException &#123;<br>        IRemoteObj remoteObj = new RemoteObjImpl();//创建远程调用对象<br>        Registry r= LocateRegistry.createRegistry(1099);//创建注册中心<br>        r.bind(&quot;remoteObj&quot;, remoteObj);//绑定<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第三行代码将远程对象绑定到注册中心详细写法：</p>
<p><font style="color:rgb(51,51,51);">第一个参数是一个</font><font style="color:rgb(51,51,51);">URL</font><font style="color:rgb(51,51,51);">，形如： </font><font style="color:rgb(51,51,51);">rmi:&#x2F;&#x2F;host:port&#x2F;name </font><font style="color:rgb(51,51,51);">。其中，</font><font style="color:rgb(51,51,51);">host</font><font style="color:rgb(51,51,51);">和</font><font style="color:rgb(51,51,51);">port</font><font style="color:rgb(51,51,51);">就是 </font></p>
<p><font style="color:rgb(51,51,51);">RMI Registry</font><font style="color:rgb(51,51,51);">的地址和端口，</font><font style="color:rgb(51,51,51);">name</font><font style="color:rgb(51,51,51);">是远程对象的名字。 </font></p>
<p><font style="color:rgb(51,51,51);">如果 RMI Registry 在本地运行，那么 host 和 port 是可以省略的，此时 host 默认是 localhost ，port 默认 是 1099 ：</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">r.bind(&quot;rmi://127.0.0.1:1099/remoteObject&quot;,remoteObject);<br></code></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p><font style="color:#213BC0;">同样的具备远程调用的接口</font></p>
<p><font style="color:#213BC0;">RMIClient:</font><font style="color:#000000;">连接注册中心获取一个东西调用远程对象并调用方法</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain">package org.example;<br><br>import java.rmi.NotBoundException;<br>import java.rmi.Remote;<br>import java.rmi.RemoteException;<br>import java.rmi.registry.LocateRegistry;<br>import java.rmi.registry.Registry;<br><br>public class RMICilent &#123;<br>    public static void main(String[] args) throws RemoteException, NotBoundException &#123;<br>        Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;,1099);<br>        IRemoteObj remoteObj = (IRemoteObj)registry.lookup(&quot;remoteObj&quot;);//lookup(&quot;rmi://127.0.0.1:1099/remoteObject&quot;)<br>        System.out.println(remoteObj.sayhello(&quot;hello&quot;));<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755443990338-694be342-01d9-4eed-b38d-d6efad5791f2.png" srcset="/img/loading.gif" lazyload style="zoom:67%;">对象的创建和调用都是在内存中以序列化和反序列化的形式进行的，所以总的 RMI 的整个流程就是序列化和反序列化实现的</p>
<h1 id="二-RMI-原理分析"><a href="#二-RMI-原理分析" class="headerlink" title="二. RMI 原理分析"></a>二. RMI 原理分析</h1><blockquote>
<p>类加载（初始化阶段：静态代码块 &#x2F; 静态变量）→ 每次实例化时先执行构造代码块 → 再执行构造函数</p>
<p>实例化对象时会首先触发<font style="color:#DF2A3F;">类加载</font>，在类加载的初始化阶段进行合并静态代码块和静态变量进行赋值操作，接着才会执行<font style="color:#DF2A3F;">构造代码块，构造函数</font>。还要注意静态变量和静态代码块初始化只执行一次。</p>
</blockquote>
<h2 id="2-1-服务端创建远程对象"><a href="#2-1-服务端创建远程对象" class="headerlink" title="2.1 服务端创建远程对象"></a>2.1 服务端创建远程对象</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">IRemoteObj remoteObj = new RemoteObjImpl();//创建远程调用对象<br></code></pre></td></tr></table></figure>

<p>new 实例化 RemoteObjImpl 远程对象,就按照上面回顾的顺序加载，首先类加载的初始化阶段静态变量和静态代码块</p>
<p><img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755501829173-994fdb53-52b6-496d-921a-cca95c42ccb0.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755501861880-a1bfd1d0-23ef-4db6-8108-d5ff6d01560e.png" srcset="/img/loading.gif" lazyload></p>
<p>接着就是来到远程对象类的构造器了，（_**<font style="color:rgb(51, 51, 51);">在子类构造器中有隐藏的调用父类构造器的代码 super()）</font>**_</p>
<p>所以先调 UnicastRemoteObject 的无参构造器它里面又掉它的有参构造</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">public class RemoteObjImpl extends UnicastRemoteObject implements IRemoteObj &#123;<br><br>    public RemoteObjImpl() throws RemoteException &#123;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>父类无参：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">protected UnicastRemoteObject() throws RemoteException<br>&#123;<br>    this(0);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>有参：接下来要将远程对象发布到网络上，Port 这里默认传的 0，就是远程对象发布到任意端口上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">protected UnicastRemoteObject(int port) throws RemoteException<br>&#123;<br>    this.port = port;<br>    exportObject((Remote) this, port);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="UnicastServerRef-exportObject"><a href="#UnicastServerRef-exportObject" class="headerlink" title="UnicastServerRef.exportObject"></a>UnicastServerRef.exportObject</h3><p>接着调到该类静态方法这儿</p>
<p>这里导出对象方法有两个参数，一个就是实现远程调用对象逻辑的对象，另一个就是处理网络请求的</p>
<p><img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755502879164-02181194-f392-450b-9260-8251990d4bab.png" srcset="/img/loading.gif" lazyload></p>
<p>第二个参数是实例化的是 UnicastServerRef</p>
<p>进入到构造器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">public UnicastServerRef(int port) &#123;<br>    super(new LiveRef(port));<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p><strong>new LiveRef</strong></p>
<p>在这里创建了一个 LiveRef</p>
<p>LiveRef 构造里就是以一个 ip 一个端口作为参数的构造器–&gt;还是构造中调第二个参数是 TCPEndpoint 静态方法的返回结果的有参构造</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">public LiveRef(int port) &#123;<br>    this((new ObjID()), port);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">public LiveRef(ObjID objID, int port) &#123;<br>    this(objID, TCPEndpoint.getLocalEndpoint(port), true);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>getLocalEndpoint 该方法返回一个 TCPEndPoint 对象作为 LiveRef 有参构造的第二个参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static TCPEndpoint getLocalEndpoint(int port) &#123;<br>    return getLocalEndpoint(port, null, null);<br>&#125;<br><br>//在下面这个方法里有给私有属性transport赋值<br>public static TCPEndpoint getLocalEndpoint(int port,<br>                                           RMIClientSocketFactory csf,<br>                                           RMIServerSocketFactory ssf)<br>&#123;<br>    /*<br>     * Find mapping for an endpoint key to the list of local unique<br>     * endpoints for this client/server socket factory pair (perhaps<br>     * null) for the specific port.<br>     */<br>    TCPEndpoint ep = null;<br><br>    synchronized (localEndpoints) &#123;<br>        TCPEndpoint endpointKey = new TCPEndpoint(null, port, csf, ssf);<br>        LinkedList&lt;TCPEndpoint&gt; epList = localEndpoints.get(endpointKey);<br>        String localHost = resampleLocalHost();<br><br>        if (epList == null) &#123;<br>            /*<br>             * Create new endpoint list.<br>             */<br>            ep = new TCPEndpoint(localHost, port, csf, ssf);<br>            epList = new LinkedList&lt;TCPEndpoint&gt;();<br>            epList.add(ep);<br>            ep.listenPort = port;<br>            ep.transport = new TCPTransport(epList);<br>            localEndpoints.put(endpointKey, epList);<br><br>            if (TCPTransport.tcpLog.isLoggable(Log.BRIEF)) &#123;<br>                TCPTransport.tcpLog.log(Log.BRIEF,<br>                    &quot;created local endpoint for socket factory &quot; + ssf +<br>                    &quot; on port &quot; + port);<br>            &#125;<br>        &#125; else &#123;<br>            synchronized (epList) &#123;<br>                ep = epList.getLast();<br>                String lastHost = ep.host;<br>              ....<br><br>    return ep;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>参数分析完，好了终于来到了最终的这个有参构造，到这里远程对象就创建好了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">public LiveRef(ObjID objID, Endpoint endpoint, boolean isLocal) &#123;<br>    ep = endpoint;<br>    id = objID;<br>    this.isLocal = isLocal;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p><strong>super</strong></p>
<p>最里面参数部分走完，现在就回到这里，调 UnicastServerRef 的 super()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">public UnicastServerRef(int port) &#123;<br>    super(new LiveRef(port));<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p>在父类 UnicastRef 中赋值，即刚刚创建的 liveRef</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">public UnicastRef(LiveRef liveRef) &#123;<br>    ref = liveRef;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p>里面走完回到这里，接着走 exportObject</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plain">//UnicastRemoteObject<br>public static Remote exportObject(Remote obj, int port)<br>    throws RemoteException<br>&#123;<br>    return exportObject(obj, new UnicastServerRef(port));<br>&#125;<br><br>//UnicastRemoteObject<br>    private static Remote exportObject(Remote obj, UnicastServerRef sref)<br>        throws RemoteException<br>    &#123;<br>        // if obj extends UnicastRemoteObject, set its ref.<br>        if (obj instanceof UnicastRemoteObject) &#123;<br>            ((UnicastRemoteObject) obj).ref = sref;<br>        &#125;<br>        return sref.exportObject(obj, null, false);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="exportObject-方法"><a href="#exportObject-方法" class="headerlink" title="exportObject()方法"></a>exportObject()方法</h4><p><strong>接着跟上面，从 UnicastRemoteObject 构造器–&gt;该类的静态方法–&gt;还是一个静态方法–&gt; UnicastServerRef 的 exportObject</strong></p>
<p><font style="color:#DF2A3F;">重要的一个静态函数 exportObject()导出对象</font>，注意由于他是静态方法，所以远程调用类在不继承 UnicastRemoteObject 的情况下，就需要手动在远程调用对象的构造器中类调用导出对象这个静态方法（在加载子类的时候首先就会加载父类进行初始化）</p>
<p><strong>最终执行 UnicastServerRef 的 exportObject：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plain">public Remote exportObject(Remote impl, Object data,<br>                           boolean permanent)<br>    throws RemoteException<br>&#123;<br>    Class&lt;?&gt; implClass = impl.getClass();<br>    Remote stub;<br><br>    try &#123;<br>        stub = Util.createProxy(implClass, getClientRef(), forceStubUse);<br>    &#125; catch (IllegalArgumentException e) &#123;<br>        throw new ExportException(<br>            &quot;remote object implements illegal remote interface&quot;, e);<br>    &#125;<br>    if (stub instanceof RemoteStub) &#123;<br>        setSkeleton(impl);<br>    &#125;<br><br>    Target target =<br>        new Target(impl, this, stub, ref.getObjID(), permanent);<br>    ref.exportObject(target);<br>    hashToMethod_Map = hashToMethod_Maps.get(implClass);<br>    return stub;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p>最里层真正 exportObject 走完，就一层一层往外返回，返回到静态方法这里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static Remote exportObject(Remote obj, int port)<br>    throws RemoteException<br>&#123;<br>    return exportObject(obj, new UnicastServerRef(port));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>跟进看看具体执行，这里将方法的第二个参数也就是创建的 UnicastServerRef 且里面还包含了 LiveRef,将 sref 他赋值给远程对象的属性 ref</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">private static Remote exportObject(Remote obj, UnicastServerRef sref)<br>        throws RemoteException<br>    &#123;<br>        // if obj extends UnicastRemoteObject, set its ref.<br>        if (obj instanceof UnicastRemoteObject) &#123;<br>            ((UnicastRemoteObject) obj).ref = sref;<br>        &#125;<br>        return sref.exportObject(obj, null, false);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755606449508-4974bff1-ef07-49ea-b18f-14b1ae87de84.png" srcset="/img/loading.gif" lazyload></p>
<p>然后调到前面说的方法执行的这里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plain">public Remote exportObject(Remote impl, Object data,<br>                           boolean permanent)<br>    throws RemoteException<br>&#123;<br>    Class&lt;?&gt; implClass = impl.getClass();<br>    Remote stub;<br><br>    try &#123;<br>        stub = Util.createProxy(implClass, getClientRef(), forceStubUse);<br>    &#125; catch (IllegalArgumentException e) &#123;<br>        throw new ExportException(<br>            &quot;remote object implements illegal remote interface&quot;, e);<br>    &#125;<br>    if (stub instanceof RemoteStub) &#123;<br>        setSkeleton(impl);<br>    &#125;<br><br>    Target target =<br>        new Target(impl, this, stub, ref.getObjID(), permanent);<br>    ref.exportObject(target);<br>    hashToMethod_Map = hashToMethod_Maps.get(implClass);<br>    return stub;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>** createProxy**</p>
<blockquote>
<p>创建客户端的代理，客户端的动态代理是在服务端创建的，再放到注册中心，客户端从注册中获取再向服务端的代理请求</p>
</blockquote>
<p>跟进去它</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">stub = Util.createProxy(implClass, getClientRef(), forceStubUse);<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static Remote createProxy(Class&lt;?&gt; implClass,<br>                                 RemoteRef clientRef,<br>                                 boolean forceStubUse)<br>    throws StubNotFoundException<br>&#123;<br>    Class&lt;?&gt; remoteClass;<br><br>    try &#123;<br>        remoteClass = getRemoteClass(implClass);<br>    &#125; catch (ClassNotFoundException ex ) &#123;<br>        throw new StubNotFoundException(<br>            &quot;object does not implement a remote interface: &quot; +<br>            implClass.getName());<br>    &#125;<br><br>    if (forceStubUse ||<br>        !(ignoreStubClasses || !stubClassExists(remoteClass)))<br>    &#123;<br>        return createStub(remoteClass, clientRef);<br>    &#125;<br><br>    final ClassLoader loader = implClass.getClassLoader();<br>    final Class&lt;?&gt;[] interfaces = getRemoteInterfaces(implClass);<br>    final InvocationHandler handler =<br>        new RemoteObjectInvocationHandler(clientRef);<br><br>    /* REMIND: private remote interfaces? */<br><br>    try &#123;<br>        return AccessController.doPrivileged(new PrivilegedAction&lt;Remote&gt;() &#123;<br>            public Remote run() &#123;<br>                return (Remote) Proxy.newProxyInstance(loader,<br>                                                       interfaces,<br>                                                       handler);<br>            &#125;&#125;);<br>    &#125; catch (IllegalArgumentException e) &#123;<br>        throw new StubNotFoundException(&quot;unable to create proxy&quot;, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看这部分逻辑，stubClassExists 要返回 true，这里就返回 creatStub 方法结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">if (forceStubUse ||<br>       !(ignoreStubClasses || !stubClassExists(remoteClass)))<br>   &#123;<br>       return createStub(remoteClass, clientRef);<br>   &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>stubClassExists：该方法的主要作用是判断指定的远程类是否存在对应的 Stub 类，这里没有返回 false</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">private static boolean stubClassExists(Class&lt;?&gt; remoteClass) &#123;<br>    if (!withoutStubs.containsKey(remoteClass)) &#123;<br>        try &#123;<br>            Class.forName(remoteClass.getName() + &quot;_Stub&quot;,<br>                          false,<br>                          remoteClass.getClassLoader());<br>            return true;<br><br>        &#125; catch (ClassNotFoundException cnfe) &#123;<br>            withoutStubs.put(remoteClass, null);<br>        &#125;<br>    &#125;<br>    return false;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后接着看 createProxy 的逻辑，下面这部分就是标准的创建动态代理了，参数有<font style="background-color:#FBDE28;">真正类的类加载器即 AppclassLoader，真正类实现的接口即 IRemoteObj ,调用处理器</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">return (Remote) Proxy.newProxyInstance(loader,<br>                                                      interfaces,<br>                                                      handler);<br></code></pre></td></tr></table></figure>

<p><img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755617034980-6888c721-73a7-4816-a094-793c859c0b43.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>看一下调用处理器是什么，从下面的图中可以看到 ref 还是前面创建的 LiveRef@845，从始至终就这一个</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">public RemoteObjectInvocationHandler(RemoteRef ref) &#123;<br>    super(ref);<br>    if (ref == null) &#123;<br>        throw new NullPointerException();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">protected RemoteObject(RemoteRef newref) &#123;<br>    ref = newref;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755617680801-eed19bb8-7634-4d35-8ddd-275bb1cd85ca.png" srcset="/img/loading.gif" lazyload></p>
<p>creatProxy 之后就创建好了动态代理 stub，可以看到 h 就是动态代理类的的调用处理器，里面还有我们的核心 ref</p>
<p><img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755617823425-dbe143e5-921a-45c3-a37a-cc036473a4e0.png" srcset="/img/loading.gif" lazyload></p>
<p>接着 exportObject 的逻辑，这里是判断 stub 是内置的类就执行 if 里的代码，现在是不满足的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">if (stub instanceof RemoteStub) &#123;<br>    setSkeleton(impl);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后把我们已经获得的所有信息封装进 target 中，里面的 disp 是服务端代理，stub 就是客户端代理，（为了保证服务端和客户端之间的通信）他们都有一个相同的核心东西 ref 即同一个 LiveRef 对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">Target target =<br>    new Target(impl, this, stub, ref.getObjID(), permanent);<br></code></pre></td></tr></table></figure>

<img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755619335370-9076f8be-ff9b-46d2-b8c7-a2fd10feb92f.png" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<p>接着将封装好的 traget exportObject 发布到网络上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">ref.exportObject(target);<br></code></pre></td></tr></table></figure>

<h3 id="TCPTransport-exportObject"><a href="#TCPTransport-exportObject" class="headerlink" title="TCPTransport.exportObject"></a>TCPTransport.exportObject</h3><p>ref 调也就来到了<strong>LiveRef.exportObject</strong></p>
<p>LiveRef.exportObject：</p>
<p>ep 里面有个 transport(TCPTransport@1170),后面一直是他</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">public void exportObject(Target target) throws RemoteException &#123;<br>    ep.exportObject(target);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755651940133-5ece89a2-2e2f-487e-a0cb-aaf4b55334fe.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>TCPEndpoint.exportObject：</strong></p>
<p>这里 transport 就还是上面的(TCPTransport@1170)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">public void exportObject(Target target) throws RemoteException &#123;<br>    transport.exportObject(target);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755652020758-c91521a5-fa59-41a2-96ae-95b3f26c12d4.png" srcset="/img/loading.gif" lazyload></p>
<p>再然后就是真正执行的<strong>TCPTransport.exportObject</strong></p>
<p><img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755652093500-f67e6f73-db5c-4353-9325-dbbec9569d6c.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plain">public void exportObject(Target target) throws RemoteException &#123;<br>    /*<br>     * Ensure that a server socket is listening, and count this<br>     * export while synchronized to prevent the server socket from<br>     * being closed due to concurrent unexports.<br>     */<br>    synchronized (this) &#123;<br>        listen();<br>        exportCount++;<br>    &#125;<br><br>    /*<br>     * Try to add the Target to the exported object table; keep<br>     * counting this export (to keep server socket open) only if<br>     * that succeeds.<br>     */<br>    boolean ok = false;<br>    try &#123;<br>        super.exportObject(target);<br>        ok = true;<br>    &#125; finally &#123;<br>        if (!ok) &#123;<br>            synchronized (this) &#123;<br>                decrementExportCount();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p>来看 listen 的逻辑，Listen 监听就会开启端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs plain">private void listen() throws RemoteException &#123;<br>    assert Thread.holdsLock(this);<br>    TCPEndpoint ep = getEndpoint();<br>    int port = ep.getPort();//这里获得刚刚上面说的TCPEndpoint里面包含TCPtransport@1170的这个<br><br>    if (server == null) &#123;<br>        if (tcpLog.isLoggable(Log.BRIEF)) &#123;<br>            tcpLog.log(Log.BRIEF,<br>                &quot;(port &quot; + port + &quot;) create server socket&quot;);<br>        &#125;<br><br>        try &#123;<br>            server = ep.newServerSocket();//这里创建新的socket的话回将port重新赋个值<br>            /*<br>             * Don&#x27;t retry ServerSocket if creation fails since<br>             * &quot;port in use&quot; will cause export to hang if an<br>             * RMIFailureHandler is not installed.<br>             */<br>            Thread t = AccessController.doPrivileged(<br>                new NewThreadAction(new AcceptLoop(server),<br>                                    &quot;TCP Accept-&quot; + port, true));<br>            t.start();<br>        &#125; catch (java.net.BindException e) &#123;<br>            throw new ExportException(&quot;Port already in use: &quot; + port, e);<br>        &#125; catch (IOException e) &#123;<br>            throw new ExportException(&quot;Listen failed on port: &quot; + port, e);<br>        &#125;<br><br>    &#125; else &#123;<br>        // otherwise verify security access to existing server socket<br>        SecurityManager sm = System.getSecurityManager();<br>        if (sm != null) &#123;<br>            sm.checkListen(port);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>获取已经创建处理的 TCPEndpoint</li>
<li>设置端口值，若果是默认 0，设置一个端口值，服务端将远程对象发布到这个端口上</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">if (listenPort == 0)<br>    setDefaultPort(server.getLocalPort(), csf, ssf);<br></code></pre></td></tr></table></figure>

<img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755828539466-30d9031b-6520-45ab-863a-9d9aaaacdae9.png" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<ul>
<li>创建服务端 socket,新建一个线程打开线程等待客户端连接（表明网络请求和代码逻辑是分离开的）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">Thread t = AccessController.doPrivileged(<br>    new NewThreadAction(new AcceptLoop(server),<br>                        &quot;TCP Accept-&quot; + port, true));<br>t.start();<br></code></pre></td></tr></table></figure>

<p>listen 分析完</p>
<hr>
<p>已经发布远程对象到随机设置的那个端口了，接下来要记录一下</p>
<p>调用 TCPTransport 父类 Transport.exportObject—-&gt; ObjectTable.putTarget(target)</p>
<p>将 target(封装的全部远程对象的信息)put 进两个服务端这边静态的表进行存储</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">objTable.put(oe, target);<br>implTable.put(weakImpl, target);<br></code></pre></td></tr></table></figure>

<p>到这里远程对象就在服务端创建好，且被发布出去了</p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>服务端在创建远程对象 exportObject“导出远程对象时”会<strong>动态代理</strong>生成客户端代理 stub，（<font style="color:rgba(0, 0, 0, 0.85);">会被 </font><strong>传递到客户端</strong><font style="color:rgba(0, 0, 0, 0.85);">（通过注册中心 ），让客户端持有这个 “代理”，间接调用服务端的真实对象。</font></p>
<h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="2-2-服务端创建注册中心"><a href="#2-2-服务端创建注册中心" class="headerlink" title="2.2 服务端创建注册中心"></a>2.2 服务端创建注册中心</h2><h3 id="创建注册中心"><a href="#创建注册中心" class="headerlink" title="创建注册中心"></a>创建注册中心</h3><blockquote>
<p>注册中心和服务端本质上都是一个远程服务开到一个端口上，所以下面的调试和上面差的不多</p>
</blockquote>
<p>跟进创建注册中心，传入 1099 端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">Registry r= LocateRegistry.createRegistry(1099);<br></code></pre></td></tr></table></figure>

<p>静态方法 createRegistry，创建了 RegistryImpl</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static Registry createRegistry(int port) throws RemoteException &#123;<br>    return new RegistryImpl(port);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>RegistryImpl 构造器中先进行安全检查，这里直接就走到 else 里两行代码</p>
<p>发现和上面服务端创建远程对象一致，都用了 UnicastSeverRef 一个服务端引用来封装创建的 LiveRef 对象，只是这里端口我们传的 1099</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plain">public RegistryImpl(int port)<br>    throws RemoteException<br>&#123;<br>    if (port == Registry.REGISTRY_PORT &amp;&amp; System.getSecurityManager() != null) &#123;<br>        // grant permission for default port only.<br>        try &#123;<br>            AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Void&gt;() &#123;<br>                public Void run() throws RemoteException &#123;<br>                    LiveRef lref = new LiveRef(id, port);<br>                    setup(new UnicastServerRef(lref));<br>                    return null;<br>                &#125;<br>            &#125;, null, new SocketPermission(&quot;localhost:&quot;+port, &quot;listen,accept&quot;));<br>        &#125; catch (PrivilegedActionException pae) &#123;<br>            throw (RemoteException)pae.getException();<br>        &#125;<br>    &#125; else &#123;<br>        LiveRef lref = new LiveRef(id, port);<br>        setup(new UnicastServerRef(lref));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>快速过一下 new UnicastServerRef 这里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">public UnicastServerRef(LiveRef ref) &#123;<br>    super(ref);<br>&#125;<br><br><br>//它的父类构造器中进行赋值<br>    public UnicastRef(LiveRef liveRef) &#123;<br>        ref = liveRef;<br>    &#125;<br><br><br></code></pre></td></tr></table></figure>

<p>接着跟 setup，封装了 LiveRef 的 uref 被赋给了属性 ref,在这儿调了 UnicastServerRef.exportObject,和前面一样的，只是第三个参数由 false 变为了 true ,<font style="color:rgb(35, 38, 59);background-color:rgba(255, 255, 255, 0.8);">true 创建的是永久对象，而 false 创建的是临时对象</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">private void setup(UnicastServerRef uref)<br>    throws RemoteException<br>&#123;<br>    /* Server ref must be created and assigned before remote<br>     * object &#x27;this&#x27; can be exported.<br>     */<br>    ref = uref;<br>    uref.exportObject(this, null, true);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font style="color:rgb(35, 38, 59);background-color:rgba(255, 255, 255, 0.8);">然后进到 UnicastServerRef.exportObject 里面，同样创建 stub,traget,</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plain">public Remote exportObject(Remote impl, Object data,<br>                           boolean permanent)<br>    throws RemoteException<br>&#123;<br>    Class&lt;?&gt; implClass = impl.getClass();<br>    Remote stub;<br><br>    try &#123;<br>        stub = Util.createProxy(implClass, getClientRef(), forceStubUse);<br>    &#125; catch (IllegalArgumentException e) &#123;<br>        throw new ExportException(<br>            &quot;remote object implements illegal remote interface&quot;, e);<br>    &#125;<br>    if (stub instanceof RemoteStub) &#123;<br>        setSkeleton(impl);<br>    &#125;<br><br>    Target target =<br>        new Target(impl, this, stub, ref.getObjID(), permanent);<br>    ref.exportObject(target);<br>    hashToMethod_Map = hashToMethod_Maps.get(implClass);<br>    return stub;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不同的是 createProxy 创建 stub 时，这里代码走进了 if,stubClassExists 找到了<code>&lt;font style=&quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);&quot;&gt;RegistryImpl_Stub&lt;/font&gt;</code><font style="color:rgb(33, 53, 71);">类，所以走 creatStub,不会到下面的动态代理那了（这里 if 的出现在下面思考中给出解释）</font></p>
<img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755869443528-e117172c-5c35-4afc-8654-d87126f86794.png" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<p>createStub：全类名 forName 获得类，再实例化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs plain">private static RemoteStub createStub(Class&lt;?&gt; remoteClass, RemoteRef ref)<br>    throws StubNotFoundException<br>&#123;<br>    String stubname = remoteClass.getName() + &quot;_Stub&quot;;<br><br>    /* Make sure to use the local stub loader for the stub classes.<br>     * When loaded by the local loader the load path can be<br>     * propagated to remote clients, by the MarshalOutputStream/InStream<br>     * pickle methods<br>     */<br>    try &#123;<br>        Class&lt;?&gt; stubcl =<br>            Class.forName(stubname, false, remoteClass.getClassLoader());<br>        Constructor&lt;?&gt; cons = stubcl.getConstructor(stubConsParamTypes);<br>        return (RemoteStub) cons.newInstance(new Object[] &#123; ref &#125;);<br><br>    &#125; catch (ClassNotFoundException e) &#123;<br>        throw new StubNotFoundException(<br>            &quot;Stub class not found: &quot; + stubname, e);<br>    &#125; catch (NoSuchMethodException e) &#123;<br>        throw new StubNotFoundException(<br>            &quot;Stub class missing constructor: &quot; + stubname, e);<br>    &#125; catch (InstantiationException e) &#123;<br>        throw new StubNotFoundException(<br>            &quot;Can&#x27;t create instance of stub class: &quot; + stubname, e);<br>    &#125; catch (IllegalAccessException e) &#123;<br>        throw new StubNotFoundException(<br>            &quot;Stub class constructor not public: &quot; + stubname, e);<br>    &#125; catch (InvocationTargetException e) &#123;<br>        throw new StubNotFoundException(<br>            &quot;Exception creating instance of stub class: &quot; + stubname, e);<br>    &#125; catch (ClassCastException e) &#123;<br>        throw new StubNotFoundException(<br>            &quot;Stub class not instance of RemoteStub: &quot; + stubname, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里由 creatStub 创建的 stub 是<font style="color:rgb(33, 53, 71);">一个</font><code>&lt;font style=&quot;background-color:rgb(241, 241, 241);&quot;&gt;RegistryImpl_Stub&lt;/font&gt;</code>封装着 UnicastRef，里面再一层还封装着 LiveRef<img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755871694915-14b95b1f-2ab5-4e4e-ac6e-a4d378a30f0a.png" srcset="/img/loading.gif" lazyload></p>
<p><font style="background-color:rgb(241, 241, 241);">RegistryImpl_Stub </font>是 jdk 自带的类，继承<font style="color:rgb(33, 53, 71);">RemoteStub 的所以会进入到 if 当中，执行 setSkeleton 方法</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">stub = Util.createProxy(implClass, getClientRef(), forceStubUse);<br>    &#125; catch (IllegalArgumentException e) &#123;<br>        throw new ExportException(<br>            &quot;remote object implements illegal remote interface&quot;, e);<br>    &#125;<br>    if (stub instanceof RemoteStub) &#123;<br>        setSkeleton(impl);<br>    &#125;<br><br>    Target target =<br>        new Target(impl, this, stub, ref.getObjID(), permanent);<br>    ref.exportObject(target);<br>    hashToMethod_Map = hashToMethod_Maps.get(implClass);<br>    return stub;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>setSkeleton 中会创建一个 skeleton 作为服务端代理（forName 方式创建的）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs plain">public void setSkeleton(Remote impl) throws RemoteException &#123;<br>    if (!withoutSkeletons.containsKey(impl.getClass())) &#123;<br>        try &#123;<br>            skel = Util.createSkeleton(impl);//----------&gt;跟进&lt;-----------<br>        &#125; catch (SkeletonNotFoundException e) &#123;<br>            /*<br>             * Ignore exception for skeleton class not found, because a<br>             * skeleton class is not necessary with the 1.2 stub protocol.<br>             * Remember that this impl&#x27;s class does not have a skeleton<br>             * class so we don&#x27;t waste time searching for it again.<br>             */<br>            withoutSkeletons.put(impl.getClass(), null);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><br>//还是类加载，实例化<br><br>   static Skeleton createSkeleton(Remote object)<br>        throws SkeletonNotFoundException<br>    &#123;<br>        Class&lt;?&gt; cl;<br>        try &#123;<br>            cl = getRemoteClass(object.getClass());<br>        &#125; catch (ClassNotFoundException ex ) &#123;<br>            throw new SkeletonNotFoundException(<br>                &quot;object does not implement a remote interface: &quot; +<br>                object.getClass().getName());<br>        &#125;<br><br>        // now try to load the skeleton based ont he name of the class<br>        String skelname = cl.getName() + &quot;_Skel&quot;;<br>        try &#123;<br>            Class&lt;?&gt; skelcl = Class.forName(skelname, false, cl.getClassLoader());<br><br>            return (Skeleton)skelcl.newInstance();<br>        &#125; catch (ClassNotFoundException ex) &#123;<br>            throw new SkeletonNotFoundException(&quot;Skeleton class not found: &quot; +<br>                                                skelname, ex);<br>        &#125; catch (InstantiationException ex) &#123;<br>            throw new SkeletonNotFoundException(&quot;Can&#x27;t create skeleton: &quot; +<br>                                                skelname, ex);<br>        &#125; catch (IllegalAccessException ex) &#123;<br>            throw new SkeletonNotFoundException(&quot;No public constructor: &quot; +<br>                                                skelname, ex);<br>        &#125; catch (ClassCastException ex) &#123;<br>            throw new SkeletonNotFoundException(<br>                &quot;Skeleton not of correct class: &quot; + skelname, ex);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755925050327-4cbfc2be-d426-4750-a622-bcbb9cf47964.png" srcset="/img/loading.gif" lazyload></p>
<p>exportObject 方法最后还是将这些都放到 target 中，再用 exportObject 发布到网络</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>Target target =<br>    new Target(impl, this, stub, ref.getObjID(), permanent);<br>ref.exportObject(target);<br>hashToMethod_Map = hashToMethod_Maps.get(implClass);<br>return stub;<br></code></pre></td></tr></table></figure>

<p>然后还是与上面一样，记录在静态表中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">public void exportObject(Target target) throws RemoteException &#123;<br>    target.setExportedTransport(this);<br>    ObjectTable.putTarget(target);<br>&#125;<br><br><br><br>//putTarget<br>  objTable.put(oe, target);<br>                implTable.put(weakImpl, target);<br></code></pre></td></tr></table></figure>

<hr>
<p>put 进表的有三个 Traget，可以都点开看看他们本质都是一样的有一个是 Impl_Stub 它不是我们之前创建的，叫<font style="color:rgb(33, 53, 71);">分布式垃圾回收，是默认创建的一个重要对象，稍后 2.6 里面再看</font></p>
<p><img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755924564318-a25f1686-4fb5-4143-8215-759cc0237e96.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>实际上就是 put 进去 HashTable</p>
<p>断点调试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">r.bind(&quot;remoteObj&quot;, remoteObj);//绑定<br></code></pre></td></tr></table></figure>

<p>checkAccess 进行检查是否在本地，然后检测是否进行绑定，已经绑定过就抛出异常，没有就将元编程对象 name 和对象 put 进去</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">public void bind(String name, Remote obj)<br>    throws RemoteException, AlreadyBoundException, AccessException<br>&#123;<br>    checkAccess(&quot;Registry.bind&quot;);<br>    synchronized (bindings) &#123;<br>        Remote curr = bindings.get(name);<br>        if (curr != null)<br>            throw new AlreadyBoundException(name);<br>        bindings.put(name, obj);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><font style="color:#213BC0;"> RMI 实现是要求注册中心和服务端在同一台主机上。而在低版本的是允许它们远程绑定，所以会出现一些漏洞</font></p>
</blockquote>
<h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h2 id="🤔"><a href="#🤔" class="headerlink" title="🤔"></a>🤔</h2><p>创建远程对象时没有看到显式的 skel,在创建注册中心时却看到了 skel：</p>
<p>因为从 JDK 1.2 开始：</p>
<ul>
<li><strong>普通定义的远程对象</strong>：Stub 通过动态代理自动生成，不再需要显式 Stub 类；<font style="background-color:#FBDE28;">Skeleton 机制已被完全废弃</font>，由 <code>UnicastServerRef.dispatch() + 反射 </code>实现。</li>
<li><strong>RMI Registry</strong>：作为系统级远程对象，虽然 Skeleton 机制已被完全废弃但仍保留静态 Stub 类（<code>RegistryImpl_Stub</code>）和静态 Skelton<code>RegistryImpl_Skel</code>以保证兼容性和稳定性。<font style="color:#2F8EF4;">这也就是对应的上面创建注册中心创建 stub 时，当代码走进了 if,也就是 stubClassExists 找到了</font><code>&lt;font style=&quot;color:#2F8EF4;background-color:rgb(241, 241, 241);&quot;&gt;RegistryImpl_Stub&lt;/font&gt;</code><font style="color:#2F8EF4;">类，就实例化</font></li>
</ul>
<p>还有就是 无论远程对象还是注册中心都是<code>UnicastServerRef</code> 接管了 Skeleton 的工作 只是注册中心：在 <code>UnicastServerRef</code> 里保留了“如果存在 Skel 就用 Skel，否则走反射”的逻辑。</p>
<p>所以在后面客户端请求注册中心时注册中心是有 skel 的，而客户端请求服务端时服务端并没有远程对象的 skel</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>静态 Stub（<code>RegistryImpl_Stub</code>） → 方法里调用 <code>UnicastRef.invoke()</code></li>
<li>动态 Stub（<code>Proxy</code>） → 方法转到 <code>RemoteObjectInvocationHandler.invoke()</code>，再调 <code>UnicastRef.invoke()</code>。</li>
<li>远程对象的 skel 已被完全废弃（jdk1.2 之后），由<code>UnicastServerRef+ 反射机制  </code>内部实现，不显示定义。</li>
<li>注册中心或 DGC 的 服务端处理是 UnicastServerRef 走的 skel(内置类)逻辑不走反射</li>
</ul>
<h2 id="2-3-客户端请求注册中心—客户端"><a href="#2-3-客户端请求注册中心—客户端" class="headerlink" title="2.3 客户端请求注册中心—客户端"></a>2.3 客户端请求注册中心—客户端</h2><blockquote>
<p>现在服务端创建好远程对象和注册中心并进行了绑定。该看客户端做得事情：1.客户端从注册中心获取远程对象的代理（其实是在本地创建）。2. ·客户端向服务端发起请求（反序列化获得）</p>
</blockquote>
<h3 id="获取注册中心"><a href="#获取注册中心" class="headerlink" title="获取注册中心"></a>获取注册中心</h3><p>获取注册中心的 stub 对象(先说一下这里是不存在漏洞的具体看分析~)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;,1099);<br></code></pre></td></tr></table></figure>

<p>认知中获取一个远程对象 是需要序列化和反序列化的，但这看代码它实际上是在本地创建 LiveRef，将主机和端口传进去，然后进行封装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs plain">//LocateRegistry.getRegistry<br>public static Registry getRegistry(String host, int port)<br>    throws RemoteException<br>&#123;<br>    return getRegistry(host, port, null);<br>&#125;<br>//LocateRegistry.getRegistry<br>  public static Registry getRegistry(String host, int port,<br>                                       RMIClientSocketFactory csf)<br>        throws RemoteException<br>    &#123;<br>        Registry registry = null;<br><br>        if (port &lt;= 0)<br>            port = Registry.REGISTRY_PORT;<br><br>        if (host == null || host.length() == 0) &#123;<br>            // If host is blank (as returned by &quot;file:&quot; URL in 1.0.2 used in<br>            // java.rmi.Naming), try to convert to real local host name so<br>            // that the RegistryImpl&#x27;s checkAccess will not fail.<br>            try &#123;<br>                host = java.net.InetAddress.getLocalHost().getHostAddress();<br>            &#125; catch (Exception e) &#123;<br>                // If that failed, at least try &quot;&quot; (localhost) anyway...<br>                host = &quot;&quot;;<br>            &#125;<br>        &#125;<br><br><br>        LiveRef liveRef =<br>            new LiveRef(new ObjID(ObjID.REGISTRY_ID),<br>                        new TCPEndpoint(host, port, csf, null),<br>                        false);<br>        RemoteRef ref =<br>            (csf == null) ? new UnicastRef(liveRef) : new UnicastRef2(liveRef);<br><br>        return (Registry) Util.createProxy(RegistryImpl.class, ref, false);<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>之后又调了 Util.createProxy 方法（与上面服务端创建 stub 的流程是一样的，还是以 forname 形式实例化出来的）就获取到注册中心的 stub 对象，下一步就通过它去查找远程对象</p>
<p>所以这里从注册中心获得远程对象并没有以序列化的形式，而是传了参数在本地创建了一模一样的，所以这里没有漏洞</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs plain">// Util.createProxy<br>public static Remote createProxy(Class&lt;?&gt; implClass,<br>                                 RemoteRef clientRef,<br>                                 boolean forceStubUse)<br>    throws StubNotFoundException<br>&#123;<br>    Class&lt;?&gt; remoteClass;<br><br>    try &#123;<br>        remoteClass = getRemoteClass(implClass);<br>    &#125; catch (ClassNotFoundException ex ) &#123;<br>        throw new StubNotFoundException(<br>            &quot;object does not implement a remote interface: &quot; +<br>            implClass.getName());<br>    &#125;<br><br>    if (forceStubUse ||<br>        !(ignoreStubClasses || !stubClassExists(remoteClass)))<br>    &#123;<br>        return createStub(remoteClass, clientRef);<br>    &#125;<br><br>    final ClassLoader loader = implClass.getClassLoader();<br>    final Class&lt;?&gt;[] interfaces = getRemoteInterfaces(implClass);<br>    final InvocationHandler handler =<br>        new RemoteObjectInvocationHandler(clientRef);<br><br>    /* REMIND: private remote interfaces? */<br><br>    try &#123;<br>        return AccessController.doPrivileged(new PrivilegedAction&lt;Remote&gt;() &#123;<br>            public Remote run() &#123;<br>                return (Remote) Proxy.newProxyInstance(loader,<br>                                                       interfaces,<br>                                                       handler);<br>            &#125;&#125;);<br>    &#125; catch (IllegalArgumentException e) &#123;<br>        throw new StubNotFoundException(&quot;unable to create proxy&quot;, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="查找远程对象"><a href="#查找远程对象" class="headerlink" title="查找远程对象"></a>查找远程对象</h3><blockquote>
<p>将名字序列化给注册中心反序列化获取 stub</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">IRemoteObj remoteObj = (IRemoteObj)registry.lookup(&quot;remoteObj&quot;);<br></code></pre></td></tr></table></figure>

<ul>
<li>因为此处调试对应 class 文件是 1.1 版本，无法断点调试，静态分析就好</li>
</ul>
<p>看一下 lookup，它的参数 String var1 是绑定的远程对象的名字</p>
<p>writeObject 进行序列化(那么对应的<strong>注册中心就有反序列化的操作</strong>了)，然后 super.ref.invoke(var2)处理客户端网络请求的，建立连接，返回结果 readObject<strong>反序列化赋给 var23</strong>(var23 就是获取的远程对象的 stub)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">ObjectInput var6 = var2.getInputStream();<br>            var23 = (Remote)var6.readObject();<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs plain">//RegistryImpl_Stub.lookup<br>public Remote lookup(String var1) throws AccessException, NotBoundException, RemoteException &#123;<br>    try &#123;<br>        RemoteCall var2 = super.ref.newCall(this, operations, 2, 4905912898345647071L);<br><br>        try &#123;<br>            ObjectOutput var3 = var2.getOutputStream();<br>            var3.writeObject(var1);<br>        &#125; catch (IOException var18) &#123;<br>            throw new MarshalException(&quot;error marshalling arguments&quot;, var18);<br>        &#125;<br><br>        super.ref.invoke(var2);<br><br>        Remote var23;<br>        try &#123;<br>            ObjectInput var6 = var2.getInputStream();<br>            var23 = (Remote)var6.readObject();<br>        &#125; catch (IOException var15) &#123;<br>            throw new UnmarshalException(&quot;error unmarshalling return&quot;, var15);<br>        &#125; catch (ClassNotFoundException var16) &#123;<br>            throw new UnmarshalException(&quot;error unmarshalling return&quot;, var16);<br>        &#125; finally &#123;<br>            super.ref.done(var2);<br>        &#125;<br><br>        return var23;<br>    &#125; catch (RuntimeException var19) &#123;<br>        throw var19;<br>    &#125; catch (RemoteException var20) &#123;<br>        throw var20;<br>    &#125; catch (NotBoundException var21) &#123;<br>        throw var21;<br>    &#125; catch (Exception var22) &#123;<br>        throw new UnexpectedException(&quot;undeclared checked exception&quot;, var22);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font style="color:#2F8EF4;">上面 lookup 从注册中心读取字节流进行反序列化，就可能存在攻击点这是一个，还有一个更隐蔽攻击面更广的点：</font></p>
<p>跟进去客户端处理网络请求这里 super.ref.invoke(var2); 真正处理网络请求的是<font style="background-color:#FBDE28;">executeCall</font></p>
<p>在它的第二个 case 里 产生 TransportConstants.ExceptionalReturn 这个异常时会通过反序列化（ex &#x3D; in.readObject()）;当获取网络传输流里面的对象，如果注册中心返回一个恶意对象，即可能产生漏洞。</p>
<p>所以如果有要调用 StreamRemoteCall.executeCall()或 super.ref.invoke(var2);的都有被攻击的可能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">public void invoke(RemoteCall call) throws Exception &#123;<br>       try &#123;<br>           clientRefLog.log(Log.VERBOSE, &quot;execute call&quot;);<br><br>           call.executeCall();<br><br>       &#125; catch (RemoteException e) &#123;<br>          ......<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs plain">//StreamRemoteCall.executeCall()<br>public void executeCall() throws Exception &#123;<br>   ......<br><br>    // read return value<br>    switch (returnType) &#123;<br>    case TransportConstants.NormalReturn:<br>        break;<br><br>    case TransportConstants.ExceptionalReturn:<br>        Object ex;<br>        try &#123;<br>            ex = in.readObject();<br>        &#125; catch (Exception e) &#123;<br>            throw new UnmarshalException(&quot;Error unmarshaling return&quot;, e);<br>        &#125;<br><br>        // An exception should have been received,<br>        // if so throw it, else flag error<br>        if (ex instanceof Exception) &#123;<br>            exceptionReceivedFromServer((Exception) ex);<br>        &#125; else &#123;<br>            throw new UnmarshalException(&quot;Return type not Exception&quot;);<br>        &#125;<br>        // Exception is thrown before fallthrough can occur<br>    default:<br>        if (Transport.transportLog.isLoggable(Log.BRIEF)) &#123;<br>            Transport.transportLog.log(Log.BRIEF,<br>                &quot;return code invalid: &quot; + returnType);<br>        &#125;<br>        throw new UnmarshalException(&quot;Return code invalid&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面就是客户端与注册中心进行交互获取远程对象代理时可能产生的攻击点。</p>
<p>继续看获取到 remoteObj 远程对象代理就是一个动态代理</p>
<p><img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755938737556-48318753-d4cc-4f8d-b71c-8567ab752941.png" srcset="/img/loading.gif" lazyload></p>
<p>下一步就该客户端与服务端进行交互</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>在客户端本地创建的注册中心 （其实是注册中心的 stub“代理对象”），发起网络请求，将名字序列化给注册中心反序列化获取远程对象的 stub</p>
<h2 id="2-4-客户端请求服务端—客户端"><a href="#2-4-客户端请求服务端—客户端" class="headerlink" title="2.4 客户端请求服务端—客户端"></a>2.4 客户端请求服务端—客户端</h2><blockquote>
<p>将方法的参数序列化，反序列化返回结果</p>
</blockquote>
<p>进行调试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">System.out.println(remoteObj.sayhello(&quot;hello&quot;));<br></code></pre></td></tr></table></figure>

<p>remoteObject 是远程对象的代理，调用方法就肯定先进处理器的 invoke 方法里面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plain">//RempteObjectOnvocationHandler.invoke<br>public Object invoke(Object proxy, Method method, Object[] args)<br>    throws Throwable<br>&#123;<br>    if (! Proxy.isProxyClass(proxy.getClass())) &#123;<br>        throw new IllegalArgumentException(&quot;not a proxy&quot;);<br>    &#125;<br><br>    if (Proxy.getInvocationHandler(proxy) != this) &#123;<br>        throw new IllegalArgumentException(&quot;handler mismatch&quot;);<br>    &#125;<br><br>    if (method.getDeclaringClass() == Object.class) &#123;<br>        return invokeObjectMethod(proxy, method, args);<br>    &#125; else if (&quot;finalize&quot;.equals(method.getName()) &amp;&amp; method.getParameterCount() == 0 &amp;&amp;<br>        !allowFinalizeInvocation) &#123;<br>        return null; // ignore<br>    &#125; else &#123;<br>        return invokeRemoteMethod(proxy, method, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>invokeRemoteMethod 这里又调了 ref.invoke， 只是方法的参数不一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs plain">private Object invokeRemoteMethod(Object proxy,<br>                                  Method method,<br>                                  Object[] args)<br>    throws Exception<br>&#123;<br>    try &#123;<br>        if (!(proxy instanceof Remote)) &#123;<br>            throw new IllegalArgumentException(<br>                &quot;proxy not Remote instance&quot;);<br>        &#125;<br>        return ref.invoke((Remote) proxy, method, args,<br>                          getMethodHash(method));<br>    &#125; catch (Exception e) &#123;<br>        if (!(e instanceof RuntimeException)) &#123;<br>            Class&lt;?&gt; cl = proxy.getClass();<br>            try &#123;<br>                method = cl.getMethod(method.getName(),<br>                                      method.getParameterTypes());<br>            &#125; catch (NoSuchMethodException nsme) &#123;<br>                throw (IllegalArgumentException)<br>                    new IllegalArgumentException().initCause(nsme);<br>            &#125;<br>            Class&lt;?&gt; thrownType = e.getClass();<br>            for (Class&lt;?&gt; declaredType : method.getExceptionTypes()) &#123;<br>                if (declaredType.isAssignableFrom(thrownType)) &#123;<br>                    throw e;<br>                &#125;<br>            &#125;<br>            e = new UnexpectedException(&quot;unexpected exception&quot;, e);<br>        &#125;<br>        throw e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最终是进入 UnicastRef 的 invoke 里面有一个新的攻击点就是循环中调用的 marshalValue(types[i], params[i], out);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs plain">public Object invoke(Remote obj,<br>                     Method method,<br>                     Object[] params,<br>                     long opnum)<br>    throws Exception<br>&#123;<br>    if (clientRefLog.isLoggable(Log.VERBOSE)) &#123;<br>        clientRefLog.log(Log.VERBOSE, &quot;method: &quot; + method);<br>    &#125;<br><br>    if (clientCallLog.isLoggable(Log.VERBOSE)) &#123;<br>        logClientCall(obj, method);<br>    &#125;<br><br>    Connection conn = ref.getChannel().newConnection();<br>    RemoteCall call = null;<br>    boolean reuse = true;<br><br><br>    boolean alreadyFreed = false;<br><br>    try &#123;<br>        if (clientRefLog.isLoggable(Log.VERBOSE)) &#123;<br>            clientRefLog.log(Log.VERBOSE, &quot;opnum = &quot; + opnum);<br>        &#125;<br><br>        // create call context<br>        call = new StreamRemoteCall(conn, ref.getObjID(), -1, opnum);<br><br>        // marshal parameters<br>        try &#123;<br>            ObjectOutput out = call.getOutputStream();<br>            marshalCustomCallData(out);<br>            Class&lt;?&gt;[] types = method.getParameterTypes();<br>            for (int i = 0; i &lt; types.length; i++) &#123;<br>                marshalValue(types[i], params[i], out);<br>            &#125;<br>        &#125; catch (IOException e) &#123;<br>            clientRefLog.log(Log.BRIEF,<br>                &quot;IOException marshalling arguments: &quot;, e);<br>            throw new MarshalException(&quot;error marshalling arguments&quot;, e);<br>        &#125;<br><br>        // unmarshal return<br>        call.executeCall();<br><br>        try &#123;<br>            Class&lt;?&gt; rtype = method.getReturnType();<br>            if (rtype == void.class)<br>                return null;<br>            ObjectInput in = call.getInputStream();<br>            return returnValue;<br><br>        &#125; catch (IOException e) &#123;<br>            clientRefLog.log(Log.BRIEF,<br>                             &quot;IOException unmarshalling return: &quot;, e);<br>            throw new UnmarshalException(&quot;error unmarshalling return&quot;, e);<br>        &#125; catch (ClassNotFoundException e) &#123;<br>            clientRefLog.log(Log.BRIEF,<br>                &quot;ClassNotFoundException unmarshalling return: &quot;, e);<br><br>            throw new UnmarshalException(&quot;error unmarshalling return&quot;, e);<br>        &#125; finally &#123;<br>            try &#123;<br>                call.done();<br>            &#125; catch (IOException e) &#123;<br>                reuse = false;<br>            &#125;<br>        &#125;<br><br>    &#125; catch (RuntimeException e) &#123;<br>        if ((call == null) ||<br>            (((StreamRemoteCall) call).getServerException() != e))<br>        &#123;<br>            reuse = false;<br>        &#125;<br>        throw e;<br><br>    &#125; catch (RemoteException e) &#123;<br>        reuse = false;<br>        throw e;<br><br>    &#125; catch (Error e) &#123;<br>        reuse = false;<br>        throw e;<br><br>    &#125; finally &#123;<br>        if (!alreadyFreed) &#123;<br>            if (clientRefLog.isLoggable(Log.BRIEF)) &#123;<br>                clientRefLog.log(Log.BRIEF, &quot;free connection (reuse = &quot; +<br>                                       reuse + &quot;)&quot;);<br>            &#125;<br>            ref.getChannel().free(conn, reuse);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>分析一下循环中调用的 marshalValue，第二个参数 value 就是调用方法的参数，看经过一堆判断后 writeObject(value)将传的参数 hello 序列化（后面肯定会反序列化获得返回结果）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plain">protected static void marshalValue(Class&lt;?&gt; type, Object value,<br>                                   ObjectOutput out)<br>    throws IOException<br>&#123;<br>    if (type.isPrimitive()) &#123;<br>        if (type == int.class) &#123;<br>            out.writeInt(((Integer) value).intValue());<br>        &#125; else if (type == boolean.class) &#123;<br>            out.writeBoolean(((Boolean) value).booleanValue());<br>        &#125; else if (type == byte.class) &#123;<br>            out.writeByte(((Byte) value).byteValue());<br>        &#125; else if (type == char.class) &#123;<br>            out.writeChar(((Character) value).charValue());<br>        &#125; else if (type == short.class) &#123;<br>            out.writeShort(((Short) value).shortValue());<br>        &#125; else if (type == long.class) &#123;<br>            out.writeLong(((Long) value).longValue());<br>        &#125; else if (type == float.class) &#123;<br>            out.writeFloat(((Float) value).floatValue());<br>        &#125; else if (type == double.class) &#123;<br>            out.writeDouble(((Double) value).doubleValue());<br>        &#125; else &#123;<br>            throw new Error(&quot;Unrecognized primitive type: &quot; + type);<br>        &#125;<br>    &#125; else &#123;<br>        out.writeObject(value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755959806478-ba8872cb-bce8-4542-b3c7-5f0b52759867.png" srcset="/img/loading.gif" lazyload></p>
<p>接着重载的 invoke 中会调 call.executeCall();也就是像前面的一样客户端处理网络请求的，同样会有头一个攻击点</p>
<p>然后 unmarshalValue 方法中反序列化结果<br>所以 UnicastRef 里面序列化–&gt;发送网络请求–&gt;再反序列化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">Object returnValue = unmarshalValue(rtype, in);<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plain">protected static Object unmarshalValue(Class&lt;?&gt; type, ObjectInput in)<br>    throws IOException, ClassNotFoundException<br>&#123;<br>    if (type.isPrimitive()) &#123;<br>        if (type == int.class) &#123;<br>            return Integer.valueOf(in.readInt());<br>        &#125; else if (type == boolean.class) &#123;<br>            return Boolean.valueOf(in.readBoolean());<br>        &#125; else if (type == byte.class) &#123;<br>            return Byte.valueOf(in.readByte());<br>        &#125; else if (type == char.class) &#123;<br>            return Character.valueOf(in.readChar());<br>        &#125; else if (type == short.class) &#123;<br>            return Short.valueOf(in.readShort());<br>        &#125; else if (type == long.class) &#123;<br>            return Long.valueOf(in.readLong());<br>        &#125; else if (type == float.class) &#123;<br>            return Float.valueOf(in.readFloat());<br>        &#125; else if (type == double.class) &#123;<br>            return Double.valueOf(in.readDouble());<br>        &#125; else &#123;<br>            throw new Error(&quot;Unrecognized primitive type: &quot; + type);<br>        &#125;<br>    &#125; else &#123;<br>        return in.readObject();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1755960323419-d3ba3bcd-730d-47ab-9984-d1870cf2b054.png" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<h3 id="攻击点小结："><a href="#攻击点小结：" class="headerlink" title="攻击点小结："></a>攻击点小结：</h3><p>可能的攻击点：</p>
<ul>
<li>（注册中心—&gt;客户端）客户端访问注册中心获取远程对象的代理时： call.executeCall()（网络请求建立连接里抛出固定异常时反序列化）和反序列化获取远程对象的代理</li>
<li>（服务端—&gt;客户端）客户端请求服务端方法时： call.executeCall(); 和 unmarshalValue 反序列化获取方法返回结果</li>
</ul>
<h2 id="2-5-客户端请求注册中心—注册中心"><a href="#2-5-客户端请求注册中心—注册中心" class="headerlink" title="2.5 客户端请求注册中心—注册中心"></a>2.5 客户端请求注册中心—注册中心</h2><blockquote>
<p>客户端请求注册中心客户端干的事已经分析了，现在看看在此操作获取远程对象时注册中心发生的事儿~！</p>
</blockquote>
<p>注册中心可以说是特殊的服务端，打断点时考虑之前客户端代理是 stub，所以这里操作的是注册中心的代理 skel，分析<font style="color:rgb(33, 53, 71);">RegistryImpl_Skel 类（注册中心处理客户端交互的逻辑就在这里）。下面看是怎么走到 RegistryImpl_Skel 类的</font></p>
<p>从服务端创建注册中心 LocateRegistry.createRegistry(1099);这开始，里面还是像上面一样走到 listen 那创建了一个新的线程，所以就要去看这个线程里面的<font style="color:rgb(33, 53, 71);">（AcceptLoop 里面的）run 方法</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs plain">private void listen() throws RemoteException &#123;<br>    assert Thread.holdsLock(this);<br>    TCPEndpoint ep = getEndpoint();<br>    int port = ep.getPort();<br><br>    if (server == null) &#123;<br>        if (tcpLog.isLoggable(Log.BRIEF)) &#123;<br>            tcpLog.log(Log.BRIEF,<br>                &quot;(port &quot; + port + &quot;) create server socket&quot;);<br>        &#125;<br><br>        try &#123;<br>            server = ep.newServerSocket();<br>            /*<br>             * Don&#x27;t retry ServerSocket if creation fails since<br>             * &quot;port in use&quot; will cause export to hang if an<br>             * RMIFailureHandler is not installed.<br>             */<br>            Thread t = AccessController.doPrivileged(<br>                new NewThreadAction(new AcceptLoop(server),<br>                                    &quot;TCP Accept-&quot; + port, true));<br>            t.start();<br>        &#125; catch (java.net.BindException e) &#123;<br>            throw new ExportException(&quot;Port already in use: &quot; + port, e);<br>        &#125; catch (IOException e) &#123;<br>            throw new ExportException(&quot;Listen failed on port: &quot; + port, e);<br>        &#125;<br><br>    &#125; else &#123;<br>        // otherwise verify security access to existing server socket<br>        SecurityManager sm = System.getSecurityManager();<br>        if (sm != null) &#123;<br>            sm.checkListen(port);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>AcceptLoop.run 里面就只调了 executeAcceptLoop()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain">//AcceptLoop.run<br>public void run() &#123;<br>    try &#123;<br>        executeAcceptLoop();<br>    &#125; finally &#123;<br>        try &#123;<br>            /*<br>             * Only one accept loop is started per server<br>             * socket, so after no more connections will be<br>             * accepted, ensure that the server socket is no<br>             * longer listening.<br>             */<br>            serverSocket.close();<br>        &#125; catch (IOException e) &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个方法里又创建了新的线程<font style="color:rgb(33, 53, 71);">ConnectionHandler,所以就看他的 run 方法,run 里面实际上那就是调 run0</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs plain">//executeAcceptLoop()<br>private void executeAcceptLoop() &#123;<br>    if (tcpLog.isLoggable(Log.BRIEF)) &#123;<br>        tcpLog.log(Log.BRIEF, &quot;listening on port &quot; +<br>                   getEndpoint().getPort());<br>    &#125;<br><br>    while (true) &#123;<br>        Socket socket = null;<br>        try &#123;<br>            socket = serverSocket.accept();<br><br>            /*<br>             * Find client host name (or &quot;0.0.0.0&quot; if unknown)<br>             */<br>            InetAddress clientAddr = socket.getInetAddress();<br>            String clientHost = (clientAddr != null<br>                                 ? clientAddr.getHostAddress()<br>                                 : &quot;0.0.0.0&quot;);<br><br>            /*<br>             * Execute connection handler in the thread pool,<br>             * which uses non-system threads.<br>             */<br>            try &#123;<br>                connectionThreadPool.execute(<br>                    new ConnectionHandler(socket, clientHost));<br>            &#125; catch (RejectedExecutionException e) &#123;<br>                closeSocket(socket);<br>                tcpLog.log(Log.BRIEF,<br>                           &quot;rejected connection from &quot; + clientHost);<br>            &#125;<br><br>      ......<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">public void run() &#123;<br>          Thread t = Thread.currentThread();<br>          String name = t.getName();<br>          try &#123;<br>              t.setName(&quot;RMI TCP Connection(&quot; +<br>                        connectionCount.incrementAndGet() +<br>                        &quot;)-&quot; + remoteHost);<br>              AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;)() -&gt; &#123;<br>                  run0();<br>                  return null;<br>              &#125;, NOPERMS_ACC);<br>          &#125; finally &#123;<br>              t.setName(name);<br>          &#125;<br>      &#125;<br></code></pre></td></tr></table></figure>

<p>run0 里面会解析协议传来的字段等等，重点是调用了 handleMessages</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs plain">private void run0() &#123;<br>      ......<br>            try &#123;<br>                InputStream sockIn = socket.getInputStream();<br>                InputStream bufIn = sockIn.markSupported()<br>                        ? sockIn<br>                        : new BufferedInputStream(sockIn);<br><br>                // Read magic (or HTTP wrapper)<br>                bufIn.mark(4);<br>                DataInputStream in = new DataInputStream(bufIn);<br>                int magic = in.readInt();<br><br>                if (magic == POST) &#123;<br>                    tcpLog.log(Log.BRIEF, &quot;decoding HTTP-wrapped call&quot;);<br><br>                    // It&#x27;s really a HTTP-wrapped request.  Repackage<br>                    // the socket in a HttpReceiveSocket, reinitialize<br>                    // sockIn and in, and reread magic.<br>                    bufIn.reset();      // unread &quot;POST&quot;<br><br>                    try &#123;<br>                        socket = new HttpReceiveSocket(socket, bufIn, null);<br>                        remoteHost = &quot;0.0.0.0&quot;;<br>                        sockIn = socket.getInputStream();<br>                        bufIn = new BufferedInputStream(sockIn);<br>                        in = new DataInputStream(bufIn);<br>                        magic = in.readInt();<br><br>                    &#125; catch (IOException e) &#123;<br>                        throw new RemoteException(&quot;Error HTTP-unwrapping call&quot;,<br>                                                  e);<br>                    &#125;<br>                &#125;<br>               ......<br><br>                    // read input messages<br>                    handleMessages(conn, false);<br>                    break;<br><br>               ......<br></code></pre></td></tr></table></figure>

<p>handleMessages 就是根据字段进入到不同 case，这里面默认进到第一个调用 serviceCall(call）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs plain">void handleMessages(Connection conn, boolean persistent) &#123;<br>    int port = getEndpoint().getPort();<br><br>    try &#123;<br>        DataInputStream in = new DataInputStream(conn.getInputStream());<br>        do &#123;<br>            int op = in.read();     // transport op<br>            if (op == -1) &#123;<br>                if (tcpLog.isLoggable(Log.BRIEF)) &#123;<br>                    tcpLog.log(Log.BRIEF, &quot;(port &quot; +<br>                        port + &quot;) connection closed&quot;);<br>                &#125;<br>                break;<br>            &#125;<br><br>            if (tcpLog.isLoggable(Log.BRIEF)) &#123;<br>                tcpLog.log(Log.BRIEF, &quot;(port &quot; + port +<br>                    &quot;) op = &quot; + op);<br>            &#125;<br><br>            switch (op) &#123;<br>            case TransportConstants.Call:<br>                // service incoming RMI call<br>                RemoteCall call = new StreamRemoteCall(conn);<br>                if (serviceCall(call) == false)<br>                    return;<br>                break;<br><br>            case TransportConstants.Ping:<br>                // send ack for ping<br>                DataOutputStream out =<br>                    new DataOutputStream(conn.getOutputStream());<br>                out.writeByte(TransportConstants.PingAck);<br>                conn.releaseOutputStream();<br>                break;<br><br>            case TransportConstants.DGCAck:<br>                DGCAckHandler.received(UID.read(in));<br>                break;<br><br>            default:<br>      ......<br></code></pre></td></tr></table></figure>

<p>serviceCall 里面 getTarget,从静态表中获取记录的 target(存放着所有的信息)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plain">public boolean serviceCall(final RemoteCall call) &#123;<br>        try &#123;<br>            /* read object id */<br>            final Remote impl;<br>            ObjID id;<br><br>            try &#123;<br>                id = ObjID.read(call.getInputStream());<br>            &#125; catch (java.io.IOException e) &#123;<br>                throw new MarshalException(&quot;unable to read objID&quot;, e);<br>            &#125;<br><br>            /* get the remote object */<br>            Transport transport = id.equals(dgcID) ? null : this;<br>            Target target =<br>                ObjectTable.getTarget(new ObjectEndpoint(id, transport));<br><br>            if (target == null || (impl = target.getImpl()) == null) &#123;<br>                throw new NoSuchObjectException(&quot;no such object in table&quot;);<br>            &#125;<br><br>          ......<br></code></pre></td></tr></table></figure>

<p>所以现在下断点调试看看上面分析的 getTarget 对不对，先在服务端 getTarget 下断点启动调试，然后客户端请求，成功断到这里</p>
<img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756003901829-27d52239-26f4-46c8-9044-59eb033ea003.png" srcset="/img/loading.gif" lazyload style="zoom: 33%;">

<p>往下看到 target 里有 stub，端口为 1099</p>
<img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756003967785-8ce4aa8b-3913-4ce3-9dba-313a7ed593b4.png" srcset="/img/loading.gif" lazyload style="zoom:33%;">

<p>接下来从 target 中获取 skel 放到分发器 disp 里面</p>
<img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756004387676-6c6484c6-c99d-4ff4-a695-eb3ef8cbf2da.png" srcset="/img/loading.gif" lazyload style="zoom: 33%;">

<p>然后 serviceCall 方法中调用 disp.dispatch(impl, call)在里面 skel 不为 null 进入 if 调 oldDispatch，传的第三个参数 num 为 2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plain">public void dispatch(Remote obj, RemoteCall call) throws IOException &#123;<br>    // positive operation number in 1.1 stubs;<br>    // negative version number in 1.2 stubs and beyond...<br>    int num;<br>    long op;<br>    try &#123;<br>        // read remote call header<br>        ObjectInput in;<br>        try &#123;<br>            in = call.getInputStream();<br>            num = in.readInt();<br>            if (num &gt;= 0) &#123;<br>                if (skel != null) &#123;<br>                    oldDispatch(obj, call, num);<br>                    return;<br>                &#125; else &#123;<br>                    throw new UnmarshalException(<br>                        &quot;skeleton class not found but required &quot; +<br>                        &quot;for client version&quot;);<br>                &#125;<br>            ......<br></code></pre></td></tr></table></figure>

<p>oldDispatc 里面调 skel.dispatch，<font style="background-color:#FBDE28;">就终于走到最初说的</font><font style="color:rgb(33, 53, 71);background-color:#FBDE28;">RegistryImpl_Skel 类</font><font style="color:rgb(33, 53, 71);">里面了因为还是 class 文件，还是静态分析</font></p>
<p>所以在客户端我们操作处理 stub 去干一些事情，服务端就操作处理 skel 干一些事情（注册中心看作是特殊的服务端）</p>
<img src="https://cdn.nlark.com/yuque/0/2025/png/56492498/1756006466253-b3686d85-c955-4d67-a772-086f1669ea00.png" srcset="/img/loading.gif" lazyload style="zoom:33%;">

<ul>
<li>具体分析一下方法，var3 的不同 case,就是客户端和注册中心进行交互的不同方式（这里调试客户端从注册中心获取远程对象默认 var3 是 2） case 2 中有反序列化然后调用 lookup,可以是一个客户端攻击注册中心的点。（因为回顾之前在客户端将远程对象的名字序列化发送出去，对应的在注册中心这边一定会有反序列化的地方的）<ul>
<li>0-&gt;bind</li>
<li>1-&gt;list</li>
<li>2-&gt;lookup</li>
<li>3-&gt;rebind</li>
<li>4-&gt;unbind</li>
</ul>
</li>
<li>然后观察到这些 case 中处理 list 都有反序列化，所以客户端打注册中心的点就多了</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs plain">public void dispatch(Remote var1, RemoteCall var2, int var3, long var4) throws Exception &#123;<br>    if (var4 != 4905912898345647071L) &#123;<br>        throw new SkeletonMismatchException(&quot;interface hash mismatch&quot;);<br>    &#125; else &#123;<br>        RegistryImpl var6 = (RegistryImpl)var1;<br>        switch (var3) &#123;<br>            case 0:<br>                String var100;<br>                Remote var103;<br>                try &#123;<br>                    ObjectInput var105 = var2.getInputStream();<br>                    var100 = (String)var105.readObject();<br>                    var103 = (Remote)var105.readObject();<br>                &#125; catch (IOException var94) &#123;<br>                    throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var94);<br>                &#125; catch (ClassNotFoundException var95) &#123;<br>                    throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var95);<br>                &#125; finally &#123;<br>                    var2.releaseInputStream();<br>                &#125;<br><br>                var6.bind(var100, var103);<br><br>                try &#123;<br>                    var2.getResultStream(true);<br>                    break;<br>                &#125; catch (IOException var93) &#123;<br>                    throw new MarshalException(&quot;error marshalling return&quot;, var93);<br>                &#125;<br>            case 1:<br>                var2.releaseInputStream();<br>                String[] var99 = var6.list();<br><br>                try &#123;<br>                    ObjectOutput var102 = var2.getResultStream(true);<br>                    var102.writeObject(var99);<br>                    break;<br>                &#125; catch (IOException var92) &#123;<br>                    throw new MarshalException(&quot;error marshalling return&quot;, var92);<br>                &#125;<br>            case 2:<br>                String var98;<br>                try &#123;<br>                    ObjectInput var104 = var2.getInputStream();<br>                    var98 = (String)var104.readObject();<br>                &#125; catch (IOException var89) &#123;<br>                    throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var89);<br>                &#125; catch (ClassNotFoundException var90) &#123;<br>                    throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var90);<br>                &#125; finally &#123;<br>                    var2.releaseInputStream();<br>                &#125;<br><br>                Remote var101 = var6.lookup(var98);<br><br>                try &#123;<br>                    ObjectOutput var9 = var2.getResultStream(true);<br>                    var9.writeObject(var101);<br>                    break;<br>                &#125; catch (IOException var88) &#123;<br>                    throw new MarshalException(&quot;error marshalling return&quot;, var88);<br>                &#125;<br>            case 3:<br>                Remote var8;<br>                String var97;<br>                try &#123;<br>                    ObjectInput var11 = var2.getInputStream();<br>                    var97 = (String)var11.readObject();<br>                    var8 = (Remote)var11.readObject();<br>                &#125; catch (IOException var85) &#123;<br>                    throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var85);<br>                &#125; catch (ClassNotFoundException var86) &#123;<br>                    throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var86);<br>                &#125; finally &#123;<br>                    var2.releaseInputStream();<br>                &#125;<br><br>                var6.rebind(var97, var8);<br><br>                try &#123;<br>                    var2.getResultStream(true);<br>                    break;<br>                &#125; catch (IOException var84) &#123;<br>                    throw new MarshalException(&quot;error marshalling return&quot;, var84);<br>                &#125;<br>            case 4:<br>                String var7;<br>                try &#123;<br>                    ObjectInput var10 = var2.getInputStream();<br>                    var7 = (String)var10.readObject();<br>                &#125; catch (IOException var81) &#123;<br>                    throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var81);<br>                &#125; catch (ClassNotFoundException var82) &#123;<br>                    throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var82);<br>                &#125; finally &#123;<br>                    var2.releaseInputStream();<br>                &#125;<br><br>                var6.unbind(var7);<br><br>                try &#123;<br>                    var2.getResultStream(true);<br>                    break;<br>                &#125; catch (IOException var80) &#123;<br>                    throw new MarshalException(&quot;error marshalling return&quot;, var80);<br>                &#125;<br>            default:<br>                throw new UnmarshalException(&quot;invalid method number&quot;);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h3><p>客户端从注册中心获取远程调用对象时，注册中心 run 新线程从静态表中获取 target,skel,等一些操作调到<font style="color:rgb(33, 53, 71);">RegistryImpl_Skel.dispath 处理不同交互，将客户端发送的数据反序列化（readObject），就构成了攻击</font></p>
<p><font style="color:rgb(33, 53, 71);"></font></p>
<h2 id="2-6-客户端请求服务端—服务端"><a href="#2-6-客户端请求服务端—服务端" class="headerlink" title="2.6 客户端请求服务端—服务端"></a><font style="color:rgb(33, 53, 71);">2.6 客户端请求服务端—服务端</font></h2><p>客户端调用方法请求服务端，服务端也会像上面一样先走进 ServiceCall 方法（注册中心和服务端走的是同一套代码跟 2.5 差不多）</p>
<p>在这两个地方下断点</p>
<img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756029465440-30f2f79b-5ab2-4656-bbf4-e55d4a6b8dfd.png" srcset="/img/loading.gif" lazyload style="zoom:33%;">

<p>下断点后 target 里面的 stub 是 RegistryImpl_Stub 这个是上面客户端请求注册中心时的 （调用 <code>LocateRegistry.getRegistry()</code> 时，拿到的就是这个注册中心的 stub。)<font style="color:rgb(33, 53, 71);">连按两下 f9stub 变成了 DGCImpl_stub 它是处理内存垃圾的，再连按两下 f9 直到使得 stub 变为 Proxy</font></p>
<img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756019675465-4dfe0c1d-7615-499b-a12e-25aa351e1977.png" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756018836999-73271755-bbde-4680-a530-fda208d5901e.png" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<p>发现 skel 是 null（也就是上面说的服务端创建远程对象是没有显式的 skel）</p>
<img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756030310383-2ad079cb-c2d3-4703-82b2-a8626aab6c0b.png" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<p>所以这一步就与上面不一样了，disp 的 skel 是 null</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">final Dispatcher disp = target.getDispatcher();<br></code></pre></td></tr></table></figure>

<img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756030732534-3c4f67ad-04c8-41cc-9c17-3a6a1e200d9e.png" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<p>接着在 UnicastServerRef.dispath 中 skel 为 null 就不会调用 oldDispatch，也就不会调用 Registry_Skel 了</p>
<p>继续往下走获取输入流与 Method(就是调用的 sayhello)</p>
<img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756031147167-da024ce7-9d84-4875-8c45-6eda7b01e934.png" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<p>接着是重点循环当中的 unmarshalValue，就是在 2.4 客户端反序列化服务端返回的数据时也见过,存在漏洞</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">try &#123;<br>    unmarshalCustomCallData(in);<br>    for (int i = 0; i &lt; types.length; i++) &#123;<br>        params[i] = unmarshalValue(types[i], in);<br>    &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plain">protected static Object unmarshalValue(Class&lt;?&gt; type, ObjectInput in)<br>    throws IOException, ClassNotFoundException<br>&#123;<br>    if (type.isPrimitive()) &#123;<br>        if (type == int.class) &#123;<br>            return Integer.valueOf(in.readInt());<br>        &#125; else if (type == boolean.class) &#123;<br>            return Boolean.valueOf(in.readBoolean());<br>        &#125; else if (type == byte.class) &#123;<br>            return Byte.valueOf(in.readByte());<br>        &#125; else if (type == char.class) &#123;<br>            return Character.valueOf(in.readChar());<br>        &#125; else if (type == short.class) &#123;<br>            return Short.valueOf(in.readShort());<br>        &#125; else if (type == long.class) &#123;<br>            return Long.valueOf(in.readLong());<br>        &#125; else if (type == float.class) &#123;<br>            return Float.valueOf(in.readFloat());<br>        &#125; else if (type == double.class) &#123;<br>            return Double.valueOf(in.readDouble());<br>        &#125; else &#123;<br>            throw new Error(&quot;Unrecognized primitive type: &quot; + type);<br>        &#125;<br>    &#125; else &#123;<br>        return in.readObject();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font style="color:rgb(33, 53, 71);">再调用 method.invoke 方法去调用我们所调用的 sayHello 方法，然后用 marshalValue 将 result 序列化传回客户端</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plain">try &#123;<br>    result = method.invoke(obj, params);<br>&#125; catch (InvocationTargetException e) &#123;<br>    throw e.getTargetException();<br>&#125;<br><br>// marshal return value<br>try &#123;<br>    ObjectOutput out = call.getResultStream(true);<br>    Class&lt;?&gt; rtype = method.getReturnType();<br>    if (rtype != void.class) &#123;<br>        marshalValue(rtype, result, out);<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="小结：-2"><a href="#小结：-2" class="headerlink" title="小结："></a>小结：</h3><p>UnicastServerRef.dispath 中 unmarshalValue 反序列化客户端传的参数造成攻击、</p>
<h2 id="🤔-1"><a href="#🤔-1" class="headerlink" title="🤔"></a>🤔</h2><p>emm 在 RMI 客户端请求服务端时，宏观把握有点点像学的动态代理， RemoteObjImpl 为真正类，服务端创建的 stub 客户端代理，类比的是 Proxy 类（他们都实现相同的接口 IRemoteObj），skeleton(&#x2F;UnicastServerRef)就类比<u>服务端调用处理器</u>了（因为都是由代理类调用转发后的，且反射调用真正类的方法，这么说仅从逻辑方面类比是服务端的调用处理器)，RemoteObjectInvocationHandler 就是<u>客户端的调用处理器</u>（从代码方面它是 InvocationHandler 的实现类,<font style="color:#DF2A3F;">再提一下这个只是动态 stub 才有的，像 regietry,DGC 的 Stub 就没有这个，直接就是 stub–&gt;代理类，UnicastRef.invoke–&gt;处理网络请求, UnicastServerRef(里面又走 skel)—&gt;调用处理器</font>）</p>
<p>真实流程: 客户端代理类调方法—&gt;RemoteObjectInvocationHandler<u>客户端的调用处理器</u>—&gt;里面逻辑还是调用 UnicastRef.invoke(处理网络请求的) → 网络层 → UnicastServerRef.dispatch() <u>服务端调用处理器</u></p>
<p>RMI （粗略看作有两个调用处理器）是动态代理里的调用处理器又调远程进程里的调用处理器，中间靠序列化 + 网络传输连接起来。</p>
<p><font style="color:#DF2A3F;">上面只是总体把握方便理解，接着看一下具体区别</font></p>
<p><strong>区别：</strong></p>
<p><strong>1.</strong></p>
<p>动态代理中每个方法都统一通过 invoke 方法调用真正类的方法的，<code>InvocationHandler</code>是<strong>本地代理的处理器</strong>，负责在同一个进程内转发调用，也就时<font style="background-color:#FBDE28;">本地增强方法</font></p>
<hr>
<p>RMI 中区别于动态代理调用处理器主要是跨进程（就有两个）</p>
<p><code>RemoteObjectInvocationHandler</code>（上面调试跟进 creatProxy 时方法里创建的动态代理中调用处理器就是它）是<strong>客户端的处理器</strong>，负责<font style="background-color:#FBDE28;">跨进程发送请求</font>；</p>
<p>原 Skeleton 的功能被（UnicastServerRef.dispatch）替代，成为<strong>服务端的处理器</strong>，负责<font style="background-color:#FBDE28;">跨进程接收请求并反射调用</font>。</p>
<ul>
<li>服务端接收请求，通过 RMI Skeleton &#x2F; Dispatcher）解析请求；反序列化为 java 对象后，服务端 Skeleton&#x2F;服务端分发 通过 反射 调用 <code>RemoteObjImpl</code> 的对应方法 ,再将结果序列化返回给 stub</li>
</ul>
<p><strong>2.</strong></p>
<p>动态代理的代理类直接在同一进程中调用转发（proxy 创建后在底层有转发给调用处理器）</p>
<hr>
<p>RMI 中 Stub 并不是直接调用服务端的“调用处理器”，而是通过网络传输把请求送过去。</p>
<p>stub（打包+发送）</p>
<ul>
<li>封装方法调用信息（方法名、参数、返回类型等），序列化后通过网络协议（JRMP）发送给服务端， 等待服务端响应，再反序列化结果</li>
</ul>
<p>借用 ai<strong>结论</strong></p>
<ul>
<li>Stub 就像“能上网的动态代理”：不在本地 <code>invoke</code>，而是把调用序列化后发到远端执行。</li>
<li>Skeleton&#x2F;服务端分发 就像 “跨 JVM 的 InvocationHandler”：解包 → 反射调真实对象 → 打包回传。</li>
<li>真正的业务实现永远在 <code>**RemoteObjImpl**</code> 上。</li>
</ul>
<h2 id="2-7-DGC"><a href="#2-7-DGC" class="headerlink" title="2.7 DGC"></a>2.7 DGC</h2><p>看看在调试中出现的 DGC 是怎么一回事儿</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>首先在创建注册中心那里说了 put 存储进静态表的 target 有三个，其中一个就是 DGCImpl_Stub,这是我们 put 之前在静态表中就有了 DGCImpl_Stub</p>
<img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756048718442-3d9ac659-9eec-4fc6-b63b-b0a9fc49b07a.png" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<p>而此时 put 的 target 里面 stub 是 Proxy(远程对象的 stub)，所以在此之前<font style="color:rgb(33, 53, 71);">DGC 已经被创建好并放入静态表中了</font></p>
<p><img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756048793768-8fbae2d0-13e6-42b8-b9c6-b82179651b8b.png" srcset="/img/loading.gif" lazyload></p>
<p>就从 put 往回倒， <code>DGCImpl.dgcLog.isLoggable(Log.VERBOSE)</code>这句代码就创建了 DGC</p>
<ul>
<li>dgcLog 是这个类的静态属性，之前学过调静态属性时会先类加载，完成初始化（即合并静态代码块和静态变量完成赋值）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs plain">static void putTarget(Target target) throws ExportException &#123;<br>    ObjectEndpoint oe = target.getObjectEndpoint();<br>    WeakRef weakImpl = target.getWeakImpl();<br><br>    if (DGCImpl.dgcLog.isLoggable(Log.VERBOSE)) &#123;<br>        DGCImpl.dgcLog.log(Log.VERBOSE, &quot;add object &quot; + oe);<br>    &#125;<br><br>    synchronized (tableLock) &#123;<br>        /**<br>         * Do nothing if impl has already been collected (see 6597112). Check while<br>         * holding tableLock to ensure that Reaper cannot process weakImpl in between<br>         * null check and put/increment effects.<br>         */<br>        if (target.getImpl() != null) &#123;<br>            if (objTable.containsKey(oe)) &#123;<br>                throw new ExportException(<br>                    &quot;internal error: ObjID already in use&quot;);<br>            &#125; else if (implTable.containsKey(weakImpl)) &#123;<br>                throw new ExportException(&quot;object already exported&quot;);<br>            &#125;<br><br>            objTable.put(oe, target);<br>            implTable.put(weakImpl, target);<br><br>            if (!target.isPermanent()) &#123;<br>                incrementKeepAliveCount();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>静态变量和静态代码块，注意到静态代码块中 dgc &#x3D; new DGCImpl();实例化了一个 DGC，后续操作和创建注册中心一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">static final Log dgcLog = Log.getLog(&quot;sun.rmi.dgc&quot;, &quot;dgc&quot;,<br>    LogStream.parseLevel(AccessController.doPrivileged(<br>        new GetPropertyAction(&quot;sun.rmi.dgc.logLevel&quot;))));<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs plain">static &#123;<br>    /*<br>     * &quot;Export&quot; the singleton DGCImpl in a context isolated from<br>     * the arbitrary current thread context.<br>     */<br>    AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;<br>        public Void run() &#123;<br>            ClassLoader savedCcl =<br>                Thread.currentThread().getContextClassLoader();<br>            try &#123;<br>                Thread.currentThread().setContextClassLoader(<br>                    ClassLoader.getSystemClassLoader());<br><br>                /*<br>                 * Put remote collector object in table by hand to prevent<br>                 * listen on port.  (UnicastServerRef.exportObject would<br>                 * cause transport to listen.)<br>                 */<br>                try &#123;<br>                    dgc = new DGCImpl();<br>                    ObjID dgcID = new ObjID(ObjID.DGC_ID);<br>                    LiveRef ref = new LiveRef(dgcID, 0);<br>                    UnicastServerRef disp = new UnicastServerRef(ref);<br>                    Remote stub =<br>                        Util.createProxy(DGCImpl.class,<br>                                         new UnicastRef(ref), true);<br>                    disp.setSkeleton(dgc);<br><br>                    Permissions perms = new Permissions();<br>                    perms.add(new SocketPermission(&quot;*&quot;, &quot;accept,resolve&quot;));<br>                    ProtectionDomain[] pd = &#123; new ProtectionDomain(null, perms) &#125;;<br>                    AccessControlContext acceptAcc = new AccessControlContext(pd);<br><br>                    Target target = AccessController.doPrivileged(<br>                        new PrivilegedAction&lt;Target&gt;() &#123;<br>                            public Target run() &#123;<br>                                return new Target(dgc, disp, stub, dgcID, true);<br>                            &#125;<br>                        &#125;, acceptAcc);<br><br>                    ObjectTable.putTarget(target);<br>                &#125; catch (RemoteException e) &#123;<br>                    throw new Error(<br>                        &quot;exception initializing server-side DGC&quot;, e);<br>                &#125;<br>            &#125; finally &#123;<br>                Thread.currentThread().setContextClassLoader(savedCcl);<br>            &#125;<br>            return null;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>还是再来一遍看一下</p>
<p>creatProxy 中会检测是否存在内置类<font style="color:rgb(33, 53, 71);">DGCImpl_Stub</font>（像 Registry_Stub 一样），检测到有进入 creatStub ，forName 全类名实例化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">if (forceStubUse ||<br>    !(ignoreStubClasses || !stubClassExists(remoteClass)))<br>&#123;<br>    return createStub(remoteClass, clientRef);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>包括创建 skeleton 也是一样的实例化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs plain">static Skeleton createSkeleton(Remote object)<br>    throws SkeletonNotFoundException<br>&#123;<br>    Class&lt;?&gt; cl;<br>    try &#123;<br>        cl = getRemoteClass(object.getClass());<br>    &#125; catch (ClassNotFoundException ex ) &#123;<br>        throw new SkeletonNotFoundException(<br>            &quot;object does not implement a remote interface: &quot; +<br>            object.getClass().getName());<br>    &#125;<br><br>    // now try to load the skeleton based ont he name of the class<br>    String skelname = cl.getName() + &quot;_Skel&quot;;<br>    try &#123;<br>        Class&lt;?&gt; skelcl = Class.forName(skelname, false, cl.getClassLoader());<br><br>        return (Skeleton)skelcl.newInstance();<br>    &#125; catch (ClassNotFoundException ex) &#123;<br>        throw new SkeletonNotFoundException(&quot;Skeleton class not found: &quot; +<br>                                            skelname, ex);<br>    &#125; catch (InstantiationException ex) &#123;<br>        throw new SkeletonNotFoundException(&quot;Can&#x27;t create skeleton: &quot; +<br>                                            skelname, ex);<br>    &#125; catch (IllegalAccessException ex) &#123;<br>        throw new SkeletonNotFoundException(&quot;No public constructor: &quot; +<br>                                            skelname, ex);<br>    &#125; catch (ClassCastException ex) &#123;<br>        throw new SkeletonNotFoundException(<br>            &quot;Skeleton not of correct class: &quot; + skelname, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756088667246-7bea2bf4-9cc9-497e-87bc-0ff2ccd3714d.png" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>这就是 DGC（看作特殊的远程服务）的创建过程，调用自然像上面小结说的是会走到 UnicastSeverRef.dispatch 里面</p>
<p>走一下进行验证</p>
<img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756092318874-f1c72a0f-79cc-428f-bbcd-2341220fbdf8.png" srcset="/img/loading.gif" lazyload style="zoom:33%;">

<p>走到 dispatch 这里，这里 UnicastServerRef 里面有 DGCImpl_Skel，所以后面一定不走 UnicastServerRef 的反射，而是走 DGCImpl_Skel 分发</p>
<img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756092394922-565456c4-4b4f-4544-a923-3fb9deb34ddf.png" srcset="/img/loading.gif" lazyload style="zoom:33%;">

<p>DGCImpl_Skel.dispatch</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs plain">public void dispatch(Remote var1, RemoteCall var2, int var3, long var4) throws Exception &#123;<br>    if (var4 != -669196253586618813L) &#123;<br>        throw new SkeletonMismatchException(&quot;interface hash mismatch&quot;);<br>    &#125; else &#123;<br>        DGCImpl var6 = (DGCImpl)var1;<br>        switch (var3) &#123;<br>            case 0:<br>                ObjID[] var39;<br>                long var40;<br>                VMID var41;<br>                boolean var42;<br>                try &#123;<br>                    ObjectInput var14 = var2.getInputStream();<br>                    var39 = (ObjID[])var14.readObject();<br>                    var40 = var14.readLong();<br>                    var41 = (VMID)var14.readObject();<br>                    var42 = var14.readBoolean();<br>                &#125; catch (IOException var36) &#123;<br>                    throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var36);<br>                &#125; catch (ClassNotFoundException var37) &#123;<br>                    throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var37);<br>                &#125; finally &#123;<br>                    var2.releaseInputStream();<br>                &#125;<br><br>                var6.clean(var39, var40, var41, var42);<br><br>                try &#123;<br>                    var2.getResultStream(true);<br>                    break;<br>                &#125; catch (IOException var35) &#123;<br>                    throw new MarshalException(&quot;error marshalling return&quot;, var35);<br>                &#125;<br>            case 1:<br>                ObjID[] var7;<br>                long var8;<br>                Lease var10;<br>                try &#123;<br>                    ObjectInput var13 = var2.getInputStream();<br>                    var7 = (ObjID[])var13.readObject();<br>                    var8 = var13.readLong();<br>                    var10 = (Lease)var13.readObject();<br>                &#125; catch (IOException var32) &#123;<br>                    throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var32);<br>                &#125; catch (ClassNotFoundException var33) &#123;<br>                    throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var33);<br>                &#125; finally &#123;<br>                    var2.releaseInputStream();<br>                &#125;<br><br>                Lease var11 = var6.dirty(var7, var8, var10);<br><br>                try &#123;<br>                    ObjectOutput var12 = var2.getResultStream(true);<br>                    var12.writeObject(var11);<br>                    break;<br>                &#125; catch (IOException var31) &#123;<br>                    throw new MarshalException(&quot;error marshalling return&quot;, var31);<br>                &#125;<br>            default:<br>                throw new UnmarshalException(&quot;invalid method number&quot;);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="攻击点"><a href="#攻击点" class="headerlink" title="攻击点"></a>攻击点</h3><p>在 DGCImpl_Stub 里面有两个方法 clean 和 dirty</p>
<p>两个方法里面都有 super.ref.invoke(var6);也就是 call.executeCall();客户端处理网络请求</p>
<p>还有就是 dirty 里面的 readObject</p>
<img src="https://typor-imagesbx.oss-cn-beijing.aliyuncs.com/1756115098629-70b81ed1-70bf-446d-a770-3ec74d67eb36.png" srcset="/img/loading.gif" lazyload style="zoom:33%;">

<p>在 DGCImpl_Skel.dispatch 里面有两个 case 对应两个方法的交互，都存在攻击点 readObject</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs plain">public void dispatch(Remote var1, RemoteCall var2, int var3, long var4) throws Exception &#123;<br>    if (var4 != -669196253586618813L) &#123;<br>        throw new SkeletonMismatchException(&quot;interface hash mismatch&quot;);<br>    &#125; else &#123;<br>        DGCImpl var6 = (DGCImpl)var1;<br>        switch (var3) &#123;<br>            case 0:<br>                ObjID[] var39;<br>                long var40;<br>                VMID var41;<br>                boolean var42;<br>                try &#123;<br>                    ObjectInput var14 = var2.getInputStream();<br>                    var39 = (ObjID[])var14.readObject();<br>                    var40 = var14.readLong();<br>                    var41 = (VMID)var14.readObject();<br>                    var42 = var14.readBoolean();<br>                &#125; catch (IOException var36) &#123;<br>                    throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var36);<br>                &#125; catch (ClassNotFoundException var37) &#123;<br>                    throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var37);<br>                &#125; finally &#123;<br>                    var2.releaseInputStream();<br>                &#125;<br><br>                var6.clean(var39, var40, var41, var42);<br><br>                try &#123;<br>                    var2.getResultStream(true);<br>                    break;<br>                &#125; catch (IOException var35) &#123;<br>                    throw new MarshalException(&quot;error marshalling return&quot;, var35);<br>                &#125;<br>            case 1:<br>                ObjID[] var7;<br>                long var8;<br>                Lease var10;<br>                try &#123;<br>                    ObjectInput var13 = var2.getInputStream();<br>                    var7 = (ObjID[])var13.readObject();<br>                    var8 = var13.readLong();<br>                    var10 = (Lease)var13.readObject();<br>                &#125; catch (IOException var32) &#123;<br>                    throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var32);<br>                &#125; catch (ClassNotFoundException var33) &#123;<br>                    throw new UnmarshalException(&quot;error unmarshalling arguments&quot;, var33);<br>                &#125; finally &#123;<br>                    var2.releaseInputStream();<br>                &#125;<br><br>                Lease var11 = var6.dirty(var7, var8, var10);<br><br>                try &#123;<br>                    ObjectOutput var12 = var2.getResultStream(true);<br>                    var12.writeObject(var11);<br>                    break;<br>                &#125; catch (IOException var31) &#123;<br>                    throw new MarshalException(&quot;error marshalling return&quot;, var31);<br>                &#125;<br>            default:<br>                throw new UnmarshalException(&quot;invalid method number&quot;);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.攻击客户端：</p>
<p>客户端查询远程对象时：注册中心攻击客户端 RegistryImpl_Stub.lookup(xxx)</p>
<p>客户端反序列化服务端返回的方法结果：服务端攻击客户端 UnicastRef.invoke()</p>
<p>DGC 服务端攻击客户端 DGCImpl_Stub.dirty()</p>
<p>客户端发起网络请求后反序列化服务端返回的恶意对象：call.executeCall()</p>
<p>2.攻击注册中心：</p>
<p>客户端获取远程对象时：客户端攻击注册中心 RegistryImpl_Skel.dispatch(xxx)</p>
<p>3.攻击服务端：</p>
<p>客户端传递方法参数时：客户端攻击服务端 UnicastServerRef.dispatch(xxx)</p>
<p>DGC 客户端 攻击服务端 DGCImpl_Skel.dispatch()</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/" class="print-no-link">#Java</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>RMI基础</div>
      <div>https://bxhhf.github.io/2025/08/27/yuque-hexo-post/RMI基础/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>bxhhf</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年8月27日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/08/27/yuque-hexo-post/RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB/" title="RMI反序列化攻击">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">RMI反序列化攻击</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/08/27/yuque-hexo-post/wuzhicms/" title="wuzhicms">
                        <span class="hidden-mobile">wuzhicms</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"AN6AZUYA9oJo0TesuVqbgX1I-gzGzoHsz","appKey":"gbgqDB024hr2I7jmwbO6Mz2a","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/cdn.jsdelivr.net/gh/bynotes/texiao/source/js/xiaoxuehua.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
  <!-- 雪花特效 -->
  <script type="text/javascript" src="\js\snow.js"></script>
  
</body>
</html>
