<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>静态代理&amp;&amp;动态代理</title>
    <link href="/2025/04/09/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86&amp;&amp;%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/2025/04/09/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86&amp;&amp;%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>静态代理&amp;&amp;动态代理</p><span id="more"></span><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><ul><li>真实类，代理类，<strong>都实现接口</strong></li><li>在代理类构造器中传入<strong>正常的真实类的对象</strong>(实现真实类，代理类对接),重写代理类中的方法<strong>即用真实类对象调用真实类方法</strong>（有点像将  正常的对象调用方法  封装到代理类的方法中<em>来间接调用</em>，对象也传进去），再添加增强的功能</li></ul><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span>  <span class="hljs-title class_">IUser</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">creat</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>真实类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUser</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;展示&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">creat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;creat&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;update&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUser</span>  &#123;<br>    IUser user;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserProxy</span><span class="hljs-params">(IUser user)</span> &#123;<br>        <span class="hljs-built_in">this</span>.user = user;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>      user.show();<br>      System.out.println(<span class="hljs-string">&quot;调用了show&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">creat</span><span class="hljs-params">()</span> &#123;<br>        user.creat();<br>        System.out.println(<span class="hljs-string">&quot;调用了Creat&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        user.update();<br>        System.out.println(<span class="hljs-string">&quot;调用了Update&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">//直接连接调用</span><br>       <span class="hljs-type">IUser</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserImpl</span>();<span class="hljs-comment">//接口类引用指向实现类对象</span><br>      <span class="hljs-comment">//  user.show();</span><br><br><br>        <span class="hljs-comment">//静态代理</span><br>        <span class="hljs-type">IUser</span> <span class="hljs-variable">userProxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserProxy</span>(user);<span class="hljs-comment">//传进真正的对象</span><br>        userProxy.show();<br>        userProxy.creat();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><img src="/2025/04/09/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86&&%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/联想截图_20250407204639.png" alt="联想截图_20250407204639" style="zoom:50%;"><h4 id="疑问-结论"><a href="#疑问-结论" class="headerlink" title="疑问&amp;&amp;结论"></a>疑问&amp;&amp;结论</h4><p><em>学习ing对代理类对象调用 ‘与真实类的方法重名的 ‘即它重写的方法即 <code>userProxy.show();</code>有了困惑，为啥这么巧合，代理类中重写方法然后代理类对象调用同名的方法，来实现真实对象的方法的调用</em>（同名对他们的调用有关系？？）（它本质上不就是一个对直接调用的封装吗，那我把它装进代理类中单独写的一个方法不可以吗）</p><p>就进行下面的尝试，在代理类中写一个单独的方法（与实现类调用方法不重名，接口中也没有的），欸！这里要注意创建代理类对象就必须引用类型也是代理类的（或者是接口类的引用类型再强转成代理类的）才 能在后续中调用代理类独有的方法进而调用真正对象的方法，操作之后发现是可以的（具体部分代码如下）但是对比就感觉步骤繁琐了，这两种都重写了接口中的全部方法，但它还再写了一个方法太麻烦了</p><p>部分代理类代码 </p><p>  这里<strong>单独写了一个方法</strong> show2 调用正常真实类的对象的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUser</span>  &#123;<br>    IUser user;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserProxy</span><span class="hljs-params">(IUser user)</span> &#123;<br>        <span class="hljs-built_in">this</span>.user = user;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show2</span><span class="hljs-params">()</span> &#123;<br>        user.show();<br>        System.out.println(<span class="hljs-string">&quot;调用了show&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//user.show();</span><br>     <span class="hljs-comment">// System.out.println(&quot;调用了show&quot;);</span><br>    &#125;<br><br></code></pre></td></tr></table></figure><p>实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUser</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;展示&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">creat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;创造&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;update&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jav">//静态代理<br>      UserProxy userProxy = new UserProxy(user);//传进真正的对象<br>       userProxy.show2();<br>       userProxy.creat();<br></code></pre></td></tr></table></figure><p><img src="/2025/04/09/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86&&%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20250407204639-17441621995156-17441622013667.png" alt="联想截图_20250407204639"></p><p><em><strong>所以最后得出结论</strong></em>它们之间的调用与同名无关，同名也是为了看着会清楚，知道这个代理对象调用了这个show方法意味着这个方法show里面会调用真正对象的重名方法show,也体现出接口它规范行为的这么一个作用吧</p><p>就干脆直接在代理类中重写实现类要调的方法，把真正掉的丢进方法里去，代理类调用与真实类的方法同名的方法也就是告诉你最后会调到真实对象的方法</p><hr><p>但静态代理的缺陷：</p><p>接口中每增加一个功能方法，真实类，代理类都也需要重写，导致代码重复</p><hr><p>静态代理用代理类对象调代理类方法来间接调真正类对象的方法，也在代理类中的通过重写方法实现了功能的增强，由此看出在<strong>代理模式</strong>中有两个重要的类，代理类和目标类。<strong>代理类是服务于目标类的</strong>，对其功能进行增强。</p><hr><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul><li><p>动态代理为了实现方法的增强，具体依赖实现InvocationHandler接口中的invoke方法 实现，invoke方法相当于静态代理中代理类重写的增强功能的方法</p></li><li><p>Proxy创建对象强转后调用方法，会触发实现InvocationHandler接口类的invoke()自动执行（具体在底层）</p></li></ul><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">//动态代理</span><br>        <span class="hljs-comment">//classloader,要代理的接口，要做的事情 （真正类的加载器，真正类实现的接口，处理器对象）</span><br>        <span class="hljs-type">UserInvocationHandler</span> <span class="hljs-variable">userInvocationHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserInvocationHandler</span>(user);<br>        <span class="hljs-type">IUser</span> <span class="hljs-variable">userProxy</span>  <span class="hljs-operator">=</span> (IUser) Proxy.newProxyInstance(user.getClass().getClassLoader(), user.getClass().getInterfaces(), userInvocationHandler);<br>        userProxy.show();<br>System.out.println(userProxy.getClass());<span class="hljs-comment">//class jdk.proxy1.$Proxy0      userProxy已经是一个代理对象了</span><br></code></pre></td></tr></table></figure><p>实现接口InvocationHandler的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    IUser user;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserInvocationHandler</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserInvocationHandler</span><span class="hljs-params">(IUser user)</span> &#123;<br>        <span class="hljs-built_in">this</span>.user = user;<br>    &#125;<br><br>    <span class="hljs-comment">//invoke为了获取到外面调用的方法，得到Method</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;现在是invoke方法，调用了&quot;</span>+method.getName());<br>        method.invoke(user,args);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/2025/04/09/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86&&%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20250408211042-174416227367010.png" alt="联想截图_20250408211042"></p><h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><p>？？？？静态代理用代理类对象调代理类方法来间接调真正类对象的方法，动态代理创建代理Proxy类对象后强转成<del>接口类Iuser对象，再用这个Iuser对象调方法</del>。。（那这这这和直接用接口类引用对象调方法有什么区别）（其实这儿不是Iuser对象，是代理对象~~）</p><p>这块的疑问的产生应该是没搞清动态代理的作用和它的底层逻辑咋实现的</p><p>下面参考原文链接：<a href="https://blog.csdn.net/xiao_yao_xian/article/details/146052177">https://blog.csdn.net/xiao_yao_xian/article/details/146052177</a></p><p><a href="https://www.cnblogs.com/gonjan-blog/p/6685611.html">java动态代理实现与原理详细分析 - Gonjian - 博客园</a></p><p>因为代理模式最后都是为了增强方法的功能，在静态代理中有手动创建代理类的比较容易理解，动态代理中我们的<strong>代理类并没有直接的展现在用户面前（它是在底层创建的），但是我们仍可以在调用方法时，获得增强的功能</strong></p><h4 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h4><p>注意：下面接口为ServiceSell，要增强的方法为sell</p><p><strong>一.</strong></p><ul><li><p>Proxy中的重要方法newProxyInstance，可以用来创建代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">newProxyInstance</span> <span class="hljs-params">( ClassLoader loader, Class&lt;?&gt;[] interfaces,                                                  InvocationHandler handler)</span>;<br><br></code></pre></td></tr></table></figure><ul><li>参数讲解</li></ul><p>loader：真正类的<strong>类加载器，</strong>通过目标对象的反射可获取</p><p>interfaces：真正类<strong>实现的接口数组</strong>，通过目标对象的反射可获取</p><p>​                 –这个接口相当于静态代理的接口，可以规范行为</p><p>handler：调用处理器，也叫做方法拦截器，<em><strong>传的是一个实现了  InvocationHandler接口的  <code>实现类的</code>对象</strong></em>      它后面会在代理类中用到</p><p>返回对象:经过一系列的操作后，返回的对象就是我们看不见的代理对象，非常重要!!!!!<strong>二中具体讲</strong></p></li><li><p>实现InvocationHandler接口的类中的invoke方法,它通过反射得到具体的方法，并实现了方法功能的增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span>;<br></code></pre></td></tr></table></figure></li></ul><p><strong>二.</strong></p><p><strong>通过参考上述文章得到了<u><em>具体的代理类代码</em></u></strong></p><ul><li>代理类的定义</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">jdkProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServiceSell</span><br>                   <span class="hljs-comment">//这里类的名字是上面文章中的文件名</span><br></code></pre></td></tr></table></figure><ul><li><ul><li><p>extends Proxy：<u>继承了代理类Proxy</u></p></li><li><p>implements ServiceSell： 实现了接口。 <em><strong>这儿的接口其实就是在Proxy类用newInstance创建对象时传的接口参数</strong></em>，这样才可以在<strong>自动生成这个类的时候实现该接口</strong>。</p></li></ul><p>重点理解：和我们静态代理的代理类应该是一样的，因为实现了相同的接口</p><p><em><strong>这也契合了代理模式</strong></em></p></li><li><p>下面就是代理类中获得{要增强的方法}的具体方法，在底层就是通过反射获得了该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">-静态代码块，我们这里省去异常处理的分析，主要分析<span class="hljs-keyword">try</span>的内容<br><br><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        m1 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;equals&quot;</span>, Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>));<br>        m2 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;toString&quot;</span>);<br>        m0 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;hashCode&quot;</span>);<br>        m3 = Class.forName(<span class="hljs-string">&quot;dynamicproxy.jdk.ServiceSell&quot;</span>).getMethod(<span class="hljs-string">&quot;sell&quot;</span>, Integer.TYPE);<br>    &#125;<br>&#125;<br><br>-理解：我们知道，静态代码块是在类加载时就会执行，分析其执行的业务。<br><br>        从类的结构来看m0,m1,m2...都是Method的对象，表示一个方法<br><br>        这个静态代码块就是获得类的基本方法和根据接口实现的方法<br><br>        我们主要看<span class="hljs-type">m3</span><br><br>        <span class="hljs-variable">m3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;dynamicproxy.jdk.ServiceSell&quot;</span>).getMethod(<span class="hljs-string">&quot;sell&quot;</span>,         Integer.TYPE);根据这个接口我们得到了ServiceSell接口内的方法，也正是我们真正类的方法(需要增强的方法)，因此我们可以理解m3就是真正类（Factory类）的sell<br><br></code></pre></td></tr></table></figure><p>发现在代理类中是有要增强的方法的</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">-sell()<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sell</span><span class="hljs-params">(<span class="hljs-type">int</span> var1)</span> <span class="hljs-keyword">throws</span>  &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m3, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;var1&#125;);<br>        &#125; <br>    &#125;<br><br><span class="hljs-built_in">super</span>.h.invoke(<span class="hljs-built_in">this</span>, m3, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;var1&#125;);<br><br></code></pre></td></tr></table></figure><p>上面这是代理类中sell()方法的逻辑</p><p>super.h，在类的定义中，我们知道这个代理类时extends Proxy，所以想要了解这个h是什么，我们进入Proxy源码</p><p><img src="/2025/04/09/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86&&%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/image-20250408214930692-17441618707024.png" alt="image-20250408214930692"></p><p>发现<strong>它是实现InvocationHandler接口的对象</strong>，而恰好在Proxy用newInstance创建对象时也传进去一个InvocationHandle类的对象！！</p><p><em><strong>所以底层创建的代理类的sell方法（要增强的方法）中调用了InvocationHandle类的对象invoke方法,这个对象就是创建的实现InvocationHandler接口的对象，即示例代码组长讲的实现接口invocationHandler的类中重写的invoke方法，也是上述文章中的内部类方法</strong></em></p><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><em><strong>核心</strong></em>：创建出的底层代理类它包含的方法中调用InvocationHandler 对象的invoke方法，创建时传参—–&gt;帮助我们实现增强方法功能</p><p>我们需要：</p><p>1.创建出底层代理类Proxy.newProxyInstance(类加载器，接口，InvocationHandler 对象)</p><p>2 .有一个实现接口InvocationHandler的类，创建出InvocationHandler 对象，他作为参数传进1中去（起连接的一个作用吧）</p><p>3 .重写invoke方法，在里面调用方法（使用反射的形式），并实现功能增强</p><ul><li>接口：底层代理类会实现这个接口(契合代理模式)，<em><strong>且底层代理类中也会有接口中的方法（由反射获得），方法里面是调InvocationHandler对象的invoke</strong></em></li><li>InvocationHandler 对象：&#x3D;&#x3D;底层代理类包含的方法会调用InvocationHandler 对象的invoke方法，要是不传这个参数就没办法后续利用增强功能&#x3D;&#x3D;（具体它其实是传到Proxy构造器了，然后代理类又是Proxy的子类，所以代理类方法中调invoke方法通过它就能拿出来利用了，去增强功能）</li></ul><p>注意：Proxy.newProxyInstance(…)返回对象强转后是代理类型的（class jdk.proxy1.$Proxy0） </p><p>所以执行流程：</p><p>代理类对象调用方法—–&gt;到底层代理类方法中调用InvocationHandler对象的invoke方法——&gt;到我们自己写的实现接口InvocationHandler的类中的invoke方法——&gt;在invoke()中调用目标类的方法，并实现功能的增强</p><h4 id="在反序列化中的一个作用"><a href="#在反序列化中的一个作用" class="headerlink" title="在反序列化中的一个作用"></a>在反序列化中的一个作用</h4><p>正常的话，这个O任意类型调目标方法：</p><p>A[O]-&gt;O.f 往A中传B即可实现调B的f</p><p>当这个O是动态代理类,O它<strong>调的是别的方法不是目标方法</strong>时：</p><p>A[O]—-&gt;O.abc(虽然不是调的目标方法但这儿会触发O的invoke方法)</p><p>O[B]代理类传进去参数B—-&gt;invoke中调B.f  在invoke中增强功能，调目标f方法</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>概述&amp;&amp;URLDNS</title>
    <link href="/2025/04/02/%E6%A6%82%E8%BF%B0&amp;&amp;URLDNS/"/>
    <url>/2025/04/02/%E6%A6%82%E8%BF%B0&amp;&amp;URLDNS/</url>
    
    <content type="html"><![CDATA[<p>反序列化&amp;&amp;URLDNS</p><span id="more"></span><h3 id="概述序列化与反序列化"><a href="#概述序列化与反序列化" class="headerlink" title="概述序列化与反序列化"></a>概述序列化与反序列化</h3><ul><li><p>Java序列化就是把Java对象转换为字节序列的过程（保存值和数据类型），而Java反序列化就是把字节序列恢复为Java对象的过程（恢复值和数据类型）</p></li><li><p>若要让某个对象支持序列化机制，则必须让其类是可序列化的：即该类必须实现如下两个接口之一：</p><p>Serializable   它里面没有任何方法，是一个标记接口</p><p>Externalizable 该接口有方法要实现，因此推荐第一个</p></li><li><p>为什么产生安全问题：</p><p>只要服务段反序列化数据，客户端传递类的readObject会自动执行，给予攻击者在服务器上运行代码的能力</p></li></ul><h4 id="可能的形式"><a href="#可能的形式" class="headerlink" title="可能的形式"></a>可能的形式</h4><ol><li><p>入口类的readObject,直接调用危险方法（<em><strong>private 定义 readObject方法</strong></em>）</p><p>person 中定义代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(ObjectInputStream ois)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>       ois.defaultReadObject();<br>       Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p>序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SerializableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object o)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(o);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;xiao&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">01</span>);<br>        serialize(person);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserializableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        ObjectInputStream oos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        Object ob=oos.readObject();<br>        <span class="hljs-keyword">return</span> ob;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>      Person person=  (Person)unserialize();<br>        System.out.println(person);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><em><strong>这里为什么Person中（有点类比重写的）这个readObject,方法必须是private属性的？还有为什么能在执行反序列化代码后能调用它，并执行它的代码呢？？</strong></em></p><p>（在序列化（反序列化）的时候，ObjectOutputStream（ObjectInputStream）会寻找目标类中的私有的writeObject（readObject）方法，赋值给变量writeObjectMethod（readObjectMethod）。）</p><ul><li><p>重写<code>readObject()</code>方法，并不是说重写父类中的方法，而是我们自定义了一个private修饰的<code>readObject()</code>方法，在反序列化的过程中检测到我们程序中存在private修饰的<code>readObject()</code>方法，就会去调用我们自定义的<code>readObject()</code>方法</p></li><li><p>总结：如果目标类中没有定义私有的writeObject或readObject方法，那么序列化和反序列化的时候将<strong>调用默认的方法</strong>来根据目标类中的属性来进行序列化和反序列化，而如果目标类中定义了私有的writeObject或readObject方法，那么序列化和反序列化的时候将调用<strong>目标类中指定的</strong>writeObject或readObject方法来实现。</p></li></ul><p>参考：<a href="https://xz.aliyun.com/news/13981?time__1311=eqUxuDcDgGBADODlxGrFDn7DB7D9AnrGB1oD&u_atoken=352634068527f4b4383603b030cddcfd&u_asig=0a472f9017438369825541851e0035">重写的readObject()权限修饰符为什么不能是public-先知社区</a></p></li><li><p>入口类参数中包含可控类，该类有危险方法，readObject时调用套用的第二层类</p></li><li><p>入口类参数中包含可控类，该类又调用其他又危险方法的类，readObject时调用</p></li><li><p>构造函数&#x2F;静态代码块等类加载时隐式执行</p></li></ol><p>共同条件 继承Serializable</p><p>入口类 source(重写readObject 参数类型宽泛  最好jdk自带)</p><p>（直接在类里面向上面的1.那样直接写不太现实，在类里面套一个类并且最好还是Object类的）在readObject中调用一个常见的函数（每一个对象都会调用的比如toString,hashcode）还是jdk自带的。hashMap就是一个符合条件的</p><h3 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h3><h4 id="入口类的条件"><a href="#入口类的条件" class="headerlink" title="入口类的条件"></a>入口类的条件</h4><p>HashMap能够作为入口类的条件：</p><ul><li><p>HashMap 实现类 implements Map, Serializable</p></li><li><p>接受的类型也比较多：因为需要接受键和值</p></li><li><p>重写readObject:  它要保证键的唯一性，当键是对象时需要重新写readOject方法来计算唯一性</p></li></ul><h4 id="readObject-最后实现URL发送dns请求"><a href="#readObject-最后实现URL发送dns请求" class="headerlink" title="readObject 最后实现URL发送dns请求"></a>readObject 最后实现URL发送dns请求</h4><ul><li><p>第一部分:入口类HashMap的readObject调用入口类HashMap的hash方法计算key的hashCode ,再调  key 的hashCode（调了两下，一下调到自己的hash,一下调到  key的hashCode）,而key是我们传入的URL对象，最后就跳转成了调用URL的hashCode</p><p><em><strong>HashMap readObject—&gt;HashMap hash—-&gt; key  hashCode(即URL 的hashCode)</strong></em></p></li><li><p>第二部分:URL的hashCode在计算时会调用getHostAddress来解析域名发送dns</p><p><em><strong>URL.hashCode()—&gt;URLStreamHander.hashCode()—&gt;URL.getHostAddress()—&gt;InetAddress-&gt;getByName()</strong></em></p></li></ul><h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><p>从入口类HashMap的readObject出发</p><p>第一下：看最后面 调HashMap的hash方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(ObjectInputStream s)</span><br>       <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br><br>       ObjectInputStream.<span class="hljs-type">GetField</span> <span class="hljs-variable">fields</span> <span class="hljs-operator">=</span> s.readFields();<br><br>       <span class="hljs-comment">// Read loadFactor (ignore threshold)</span><br>       <span class="hljs-type">float</span> <span class="hljs-variable">lf</span> <span class="hljs-operator">=</span> fields.get(<span class="hljs-string">&quot;loadFactor&quot;</span>, <span class="hljs-number">0.75f</span>);<br>       <span class="hljs-keyword">if</span> (lf &lt;= <span class="hljs-number">0</span> || Float.isNaN(lf))<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidObjectException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> + lf);<br><br>       lf = Math.clamp(lf, <span class="hljs-number">0.25f</span>, <span class="hljs-number">4.0f</span>);<br>       HashMap.UnsafeHolder.putLoadFactor(<span class="hljs-built_in">this</span>, lf);<br><br>       reinitialize();<br><br>       s.readInt();                <span class="hljs-comment">// Read and ignore number of buckets</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">mappings</span> <span class="hljs-operator">=</span> s.readInt(); <span class="hljs-comment">// Read number of mappings (size)</span><br>       <span class="hljs-keyword">if</span> (mappings &lt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidObjectException</span>(<span class="hljs-string">&quot;Illegal mappings count: &quot;</span> + mappings);<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mappings == <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-comment">// use defaults</span><br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mappings &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-type">double</span> <span class="hljs-variable">dc</span> <span class="hljs-operator">=</span> Math.ceil(mappings / (<span class="hljs-type">double</span>)lf);<br>           <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> ((dc &lt; DEFAULT_INITIAL_CAPACITY) ?<br>                      DEFAULT_INITIAL_CAPACITY :<br>                      (dc &gt;= MAXIMUM_CAPACITY) ?<br>                      MAXIMUM_CAPACITY :<br>                      tableSizeFor((<span class="hljs-type">int</span>)dc));<br>           <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)cap * lf;<br>           threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?<br>                        (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br><br>           <span class="hljs-comment">// Check Map.Entry[].class since it&#x27;s the nearest public type to</span><br>           <span class="hljs-comment">// what we&#x27;re actually creating.</span><br>           SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, cap);<br>           <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>           Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[cap];<br>           table = tab;<br><br>           <span class="hljs-comment">// Read the keys and values, and put the mappings in the HashMap</span><br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mappings; i++) &#123;<br>               <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                   <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (K) s.readObject();<br>               <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                   <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (V) s.readObject();<br>               putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>           &#125;<br>       &#125;<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>进入刚刚的调用  来到第二下：调key的hashCode方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>       <span class="hljs-type">int</span> h;<br>       <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>下面这一部分就是URL的了</p><p>进入URL的hashCode后 有一个<strong>判断</strong></p><p>如果hashCode不是-1 就会初始化变为-1并返回,如果是初始化的-1的话，才会执行下面的</p><p>就 继续 跳转到URLStreamHandler 的hashCode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">if</span> (hashCode != -<span class="hljs-number">1</span>)<br>         <span class="hljs-keyword">return</span> hashCode;<br><br>     hashCode = handler.hashCode(<span class="hljs-built_in">this</span>);<br>     <span class="hljs-keyword">return</span> hashCode;<br> &#125;<br></code></pre></td></tr></table></figure><p>之后调getHostAddress 函数，就能发送dns请求了</p><hr><h4 id="———"><a href="#———" class="headerlink" title="———"></a>———</h4><h4 id="URLDNS真正构造"><a href="#URLDNS真正构造" class="headerlink" title="URLDNS真正构造"></a>URLDNS真正构造</h4><p>按上面来讲是 反序列化时会自动调用入口类的 private readOject 然后进入上述流程完成发送请求的，但有个插曲,在写入url时HashMap的put方法 就已经导致在这时发送请求了</p><p>(因为put为了确保键的唯一，它就会先调用了HashMap的hash 和key的hashCode，hashCode就发生了变化)</p><p><img src="/2025/04/02/%E6%A6%82%E8%BF%B0&&URLDNS/image-20250406172100250-17439312619313.png" alt="image-20250406172100250"></p><p><img src="/2025/04/02/%E6%A6%82%E8%BF%B0&&URLDNS/image-20250406172028200-17439312306462.png" alt="image-20250406172028200"></p><p><em>put 的坏处：</em></p><ul><li><p>我们误以为是序列化时就发送DNS请求</p></li><li><p>put改变了hashCode，所以在<strong>反序列化的时候</strong>hashCode不是-1,直接返回初始化-1不会执行下面的代码，不会发送请求了</p><p><img src="/2025/04/02/%E6%A6%82%E8%BF%B0&&URLDNS/image-20250407001830408-17439563124691.png" alt="image-20250407001830408"></p></li></ul><h4 id="总结思路"><a href="#总结思路" class="headerlink" title="总结思路:"></a><em>总结思路:</em></h4><ol><li>入口类hashMap 创建对象</li><li>在put前用反射设置hashCode为非-1,防止put调用key的hashCode发送dns请求</li><li>put方法丢进去url作为key值</li><li>反射设置回来url的hashCode为-1,再序列化对象,这样序列化就不会触发put的那一串发送请求，反序列化的时候就能(调用HashCode的private readObject，调啊调调到URL的hashCode了)发送dns请求了</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SerializableTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object o)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(o);<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, NoSuchFieldException, IllegalAccessException &#123;<br>       <span class="hljs-comment">// Person person = new Person(&quot;xiao&quot;, 18, 01);</span><br>        HashMap&lt;URL, Integer&gt; hashmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;URL, Integer&gt;();<br>       <span class="hljs-comment">//这里不想要发起请求，把url对象的hashcode改成不是-1就可以了</span><br>        <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://be5fsm.ceye.io&quot;</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> url.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">hashcodefield</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;hashCode&quot;</span>);<br>        hashcodefield.setAccessible(<span class="hljs-literal">true</span>);<br>        hashcodefield.set(url,<span class="hljs-number">1234</span>);<br>        hashmap.put(url, <span class="hljs-number">1</span>);<span class="hljs-comment">//不改变的话在put的时候就已经调用hash,key的hashCode方法了，已经发送dns请求了</span><br><br>       <span class="hljs-comment">//这里把hashCode改回-1</span><br>        <span class="hljs-comment">//通过反射改变已有对象的属性</span><br>        hashcodefield.set(url,-<span class="hljs-number">1</span>);<br>        serialize(hashmap);<br><br><br><br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h4><p><strong>需要两半部分</strong>,A部分作为入口类,反序列化的时候会自动调用A的参数o的f方法(即入口类hashMap,反序列化的时候会自动调用readObject方法,进而执行key的hashCode方法)</p><p>B部分需要有好的方法( 即能发起dns请求的URL类的hashCode方法)</p><p>B类里面的方法可以达到目的但(由于readObject 后面不能继续利用了)不能直接作为入口类</p><p>B类是后半部分的成品,A类是前半部分的成品</p><p><strong>两部分结合(即同名函数替换)</strong>: 条件:B类就  要与  能直接调的A类的方法中的参数类型 是相同类型(相同或是父子类)，再调A中方法传进B类的参数—&gt;相当于调B中的方法</p><p><strong>注意点</strong>：在传入B类参数即（URL）时用到put方法也会触发发送dns请求的那一串，在put前反射修改hashCode值为非-1，put后修改为-1,最后序列化，在反序列化的时候发送请求</p>]]></content>
    
    
    <categories>
      
      <category>Java反序列化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ObjectOutputStream &amp;&amp; ObjectInputStream</title>
    <link href="/2025/04/02/ObjectOutputStream&amp;&amp;ObjectInputStream/"/>
    <url>/2025/04/02/ObjectOutputStream&amp;&amp;ObjectInputStream/</url>
    
    <content type="html"><![CDATA[<p>ObjectOutputStream&amp;&amp;ObjectInputStream</p><p>处理流ObjectOutputStream&amp;&amp;ObjectInputStream</p><span id="more"></span><h3 id="节点流-处理流"><a href="#节点流-处理流" class="headerlink" title="节点流&amp;&amp; 处理流"></a>节点流&amp;&amp; 处理流</h3><ol><li><p>节点流：可以从一个特定的数据源（如：文件）读写数据，如：FileReader,FileWriter</p></li><li><p>处理流： （也叫包装流），是“连接”在已存在的流（节点流或处理流）之上</p><p><img src="/2025/04/02/ObjectOutputStream&&ObjectInputStream/image-20250403111505906-17437501750711.png" alt="image-20250403111505906"></p></li></ol><p>例如：BufferedReader类中有属性Reader,即可以封装一个节点流，该节点流可以是任意的，只要是Reader的子类就行（如上图：可以是文件，数组，管道，字符串…）</p><p>FileReader CharArrayReader   PipedReader  StringReader 都可以传进去    把它称为包装流</p><p><strong>区别与联系</strong></p><ol><li>节点流是底层流&#x2F;低级流，直接根数据源相接</li><li>处理流（包装流）包装节点流，使用了修饰器模式，不会直接与数据源项链</li><li>处理流对节点流进行包装，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出</li></ol><h4 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h4><p>拿BufferedReader来说，类里面有一个属性为Reader类的，构造器里传Reader类的 ，因此可以接受Reader子类的对象，就可以对它进行扩展（重写）</p><hr><h3 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h3><p>ObjectOutputStream 将 Java 对象的基本数据类型和图形写入 OutputStream。 提供序列化功能</p><p>参数:OutputStream out:字节输出流。</p><ul><li><p>构造方法：</p><p>ObjectOutputStream(OutputStream out） 因为它是一个处理流，所以需要一个节点流对象作为参数。</p></li><li><p>成员方法（无返回值）:</p></li><li><p><strong>void</strong> writeObject(Object obj) <em><strong>将指定的对象写入 ObjectOutputStream</strong></em> (即ObjectOutputStream对象(把它叫做流对象吧)调用writeObject方法（流方法）)</p><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath));<br>oos.writeObject(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;旺财&quot;</span>,<span class="hljs-number">10</span>));<br></code></pre></td></tr></table></figure></li><li><p>void writeInt （int …）    void writeChar(char …)    void  writeBoolean(boolean …)    同理</p></li></ul><h3 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h3><p>（对象的反序列化流）的构造方法：</p><ul><li><p>构造方法：</p><p>ObjectInputStream(InputStream in) 创建从指定 InputStream 读取的 ObjectInputStream。<br>参数:InputStream in:字节输入流</p></li><li><p>成员方法:（读什么类型就返回什么类型的）</p><ul><li><p><strong>Object</strong> readObject() <em><strong>从 ObjectInputStream 读取对象。</strong></em> （这时就把对象看作一个大类）</p><p>即ObjectInputStream对象 使用readInt,readBoolean,readChar,reaIdObject方法读取，返回读取Object类</p><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath));<br><br><span class="hljs-type">Object</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> ois.readObject();<br></code></pre></td></tr></table></figure></li><li><p>int readInt()     boolean readBoolean()        char readChar ()       String readUTF() 同理</p></li></ul></li></ul><p>序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.ObjectOutputStream;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectOutStream</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        String filePath=<span class="hljs-string">&quot;D:\\aaa.txt&quot;</span>;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath));<br><br>        <span class="hljs-comment">//序列化数据到 aaa.txt文件中</span><br>        oos.writeInt(<span class="hljs-number">100</span>);<span class="hljs-comment">//int---&gt;integer (实现了Serializable)</span><br>        oos.writeBoolean(<span class="hljs-literal">true</span>);<span class="hljs-comment">//boolean---&gt;Boolean(实现了Serializable)</span><br>        oos.writeChar(<span class="hljs-string">&#x27;a&#x27;</span>);<span class="hljs-comment">//char---&gt;Character(实现了Serializable)</span><br>        oos.writeDouble(<span class="hljs-number">3.14</span>);<span class="hljs-comment">//double---&gt;Double(实现了Serializable)</span><br>        oos.writeUTF(<span class="hljs-string">&quot;hello&quot;</span>);<span class="hljs-comment">//String</span><br><br>        <span class="hljs-comment">//保存一个Dog对象</span><br>        oos.writeObject(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;旺财&quot;</span>,<span class="hljs-number">10</span>));  <span class="hljs-comment">//Dog和它在同一个包下所以可以直接用</span><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>Dog 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.ObjectOutputStream;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br>        <span class="hljs-keyword">public</span> String name;<br>        <span class="hljs-comment">//serialVersionUID序列化的版本号，可以提高兼容性</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span>&#123;<br>            <span class="hljs-built_in">this</span>.age=age;<br>            <span class="hljs-built_in">this</span>.name=name;<br>        &#125;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">return</span> name;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Dog&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;age=&quot;</span> + age +<br>                    <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>    &#125;<br><br><br></code></pre></td></tr></table></figure><p>反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.InputStream;<br><span class="hljs-keyword">import</span> com.zhang.ObjectOutputStream.Dog; <span class="hljs-comment">//反序列化对象所属的类的路径必须与序列化时调用类的路径一致</span><br><br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectInStream</span> &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-comment">//指定要反序列化的文件</span><br>        String filePath=<span class="hljs-string">&quot;D:\\aaa.txt&quot;</span>;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath));<br><br>        <span class="hljs-comment">//读取的顺序（反序列化的顺序）一定要和保存顺序（序列化顺序）一致，否则会报异常</span><br>        System.out.println(ois.readInt());<br>        System.out.println(ois.readBoolean());<br>        System.out.println(ois.readChar());<br>        System.out.println(ois.readDouble());<br>        System.out.println(ois.readUTF());<br>        <span class="hljs-comment">//dog 的编译类型是Object，dog 的运行类型是Dog</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> ois.readObject();<br>        System.out.println(<span class="hljs-string">&quot;运行类型&quot;</span>+dog.getClass());<br>        System.out.println(dog);<br>        <span class="hljs-comment">//特别重要的细节</span><br>        <span class="hljs-comment">//1.注意此时dog是Object类型的哦！Dog类中的方法只有Dog子类中存在，父类Object对象 dog 是不能调用子类中独有的对象的，需要向下强转</span><br>        <span class="hljs-comment">// dog.getName();！！不可以！！</span><br>        <span class="hljs-comment">//2.！！这里Dog的定义需放到同一个包下或可以引用的地方才能用）   总之序列化和反序列化引用的类的路径必须相同</span><br>       Dog dog2= (Dog)dog;<br>        System.out.println(dog2.getName());<br>        ois.close();<br><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="小总结："><a href="#小总结：" class="headerlink" title="小总结："></a><em><strong>小总结：</strong></em></h4><ul><li>创建ObjectInputStream （处理流）对象oos  </li><li>处理流对象oos调用读取对象的方法readObject() 返回Object类型的对象dog</li><li>要调用序列化类的方法，需要向下强转为该类(Object—&gt;Dog)再调用</li></ul><hr><ol><li>读写顺序要一致</li><li>要求序列化或反序列化的对象，要实现Serializable</li><li>序列化的类中建议添加SerialVersionUID,为了提高版本的兼容性</li><li>序列化对象时，默认将里面的所有属性都进行序列化，<strong>但是除了static或transient（短暂的）修饰的成员</strong>它们不会被序列化</li><li>序列化对象时，要求里面的属性类型也需要实现序列化接口，像int 之类的也是间接实现序列化接口，自定义一种类的时候要注意实现序列化接口</li><li>序列化具备可继承性，如果某类已经实现了序列化，则它的所有子类也已经默认实现了序列化</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>注解&amp;&amp;反射&amp;&amp;类加载</title>
    <link href="/2025/03/26/%E6%B3%A8%E8%A7%A3-%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E5%8F%8D%E5%B0%84/"/>
    <url>/2025/03/26/%E6%B3%A8%E8%A7%A3-%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<p> 基础</p><!---more--><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>Annotation:</p><ul><li><p>不是程序本身，可以对程序作出解释，可以被其他程序（比如：编译器）读取</p></li><li><p>格式：”@注释名” 在代码中存在，还可以添加一些参数值，eg:@SuppressWarnings(value&#x3D;”unchecked”)</p></li><li><p>可以附加在package,class,method,field 等上面。相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问</p></li></ul><h4 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h4><ul><li>@Override:定义在java.lang.Override 中  重写方法</li><li>@Deprecated: 定义在 java.lang.Deprecated 中 ，表示不鼓励程序员使用这样的元素</li><li>@SuppressWarnings: 定义在java.labg.SuppressWarnings 中，用来抑制编译时的警告信息，他需要添加一个参数才能使用，这些参数都是定义好的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.annotation;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test01</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Object</span> &#123;<br><br>    <span class="hljs-comment">//@Override 这就是 重写 的注解</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.toString();<br>    &#125;<br><br>    <span class="hljs-meta">@Deprecated</span> <span class="hljs-comment">// @Deprecated 表示不推荐程序员使用，</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Deprecated&quot;</span>);<br><br>    &#125;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><span class="hljs-comment">//镇压警告</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        test();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><ul><li><p>作用：<strong>负责注解其他注解</strong>，Java定义了4个标准的meta-annotation , 他们呃用来提供对其他annotation 类型做说明</p></li><li><p>这些类型在java.lang.annotation 包中可以找到（@Target @Retention @Documented @Inherited）</p><ul><li><p><strong>@Target</strong>： 描述注解的<strong>使用范围</strong>（<em>即：被描述的注解可以用在什么地方</em>）</p><ul><li>ElementType取值：<ol><li>TYPE:可以作用在类上</li><li>METHOD:可以作用于方法上</li><li>FIELD:可以作用于成员变量上</li></ol></li></ul></li><li><p><strong>@Retention</strong>:  表示需要在什么级别<strong>保存</strong>被描述的注解信息，用于描述注解的生命周期</p><p>（<em>SOURCE&lt;CLASS&lt;<strong>RUNTIME</strong></em>）</p><ul><li>RUNTIME:当前被描述的注解会被保存在class字节码文件中，并且被JVM读取到</li><li>CLASS:当前被描述的注解会被保存在class字节码文件中，但不会被JVM读取到</li><li>SOURCE:当前被描述的注解<strong>不会</strong>被保存在class字节码文件中</li></ul></li><li><p>@Document:说明被描述的注解将被包含在javadoc文档中</p></li><li><p>Inherited:说明子类可以继承父类中的被描述的注解</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.annotation;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.*;<br><br><span class="hljs-comment">//测试元注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test02</span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">//@Target  注解作用范围</span><br><span class="hljs-comment">//定义一个注解 关键字 @interface  名称 MyAnnotation</span><br><span class="hljs-comment">//写元注解@Target @Retention @Documected</span><br> <span class="hljs-meta">@Target(value=&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><span class="hljs-comment">//表示MyAnnoation 能作用于方法，类</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-comment">//表示当前 被描述的注解 会保留到class字节码文件中，并被JVM读取到</span><br> <span class="hljs-meta">@Documented</span> <span class="hljs-comment">//该被描述的注解会被保留在javadoc文档中</span><br><span class="hljs-meta">@Inherited</span> <span class="hljs-comment">//子类可以继承父类该被描述的注解</span><br><span class="hljs-meta">@interface</span> MyAnnotation &#123;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><ul><li>关键字 @interface 自定义注解，自动继承了java.lang.annotation.Annotation 接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.annotation;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test03</span> &#123;<br>    <span class="hljs-comment">//注解可以显示赋值  可以默认值定义，没有默认值必须显示赋值</span><br>    <span class="hljs-comment">//显式定义格式 （参数=），没有固定顺序</span><br>    <span class="hljs-meta">@MyAnnotation2(age=18)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;&#125;<br><br><br>    <span class="hljs-comment">//显式赋值时，不写参数名的话，就必须只有一个参数且参数名默认必须为value 才不报错</span><br>    <span class="hljs-meta">@MyAnnotation3(&quot;秦疆&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>&#123;&#125;<br><br><br>&#125;<br><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> MyAnnotation2&#123;<br>    <span class="hljs-comment">//这是注解的参数  ： 参数类型 +参数名（）; 命名要求最后要加括号</span><br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//default 默认赋值</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">age</span><span class="hljs-params">()</span> ;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">id</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">//如果默认值为-1，代表不存在。</span><br>    String[] school() <span class="hljs-keyword">default</span>&#123;<span class="hljs-string">&quot;西工大&quot;</span>,<span class="hljs-string">&quot;西部开源&quot;</span>&#125;;<br>&#125;<br><br><span class="hljs-comment">//只有一个参数</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> MyAnnotation3&#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>加载类，并允许以编程的方式解剖类中的各种成分（成员变量，方法，构造器）</p><ul><li><p><strong>动态语言：</strong>在运行时可以改变其结构的语言 eg: PHP Python JavaScript C #</p></li><li><p><strong>静态语言：</strong> 与动态语言相对应，运行时结构不可改变的语言 eg: Java  C  C++</p></li><li><p>Java不是动态语言，但Java 可以称之为“准动态语言”，即Java 有一定的动态性，我们可以利用<strong>反射机制</strong>获得类似动态语言的特性</p></li><li><p><strong>反射</strong>：是Java被视为动态语言的关键，反射机制允许程序在执行期间借助于Refelection API取得任何类的内部信息，并能直接操纵任意对象的内部属性及方法（可以直接二读取到private ）</p></li></ul><ol><li><p>反射第一步：加载类，获取类的字节码：Class对象（万物皆对象，获取类本身）</p></li><li><p>获取类的构造器对象：Constructor 对象</p></li><li><p>获取类的成员变量：Field 对象</p></li><li><p>获取类的成员方法对象：Method 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.reflection;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Class.forName;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test02</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Object</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-comment">//通过反射获取  User类 的Class对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.zhang.reflection.User&quot;</span>);<br>        System.out.println(c1);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.zhang.reflection.User&quot;</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.zhang.reflection.User&quot;</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.zhang.reflection.User&quot;</span>);<br><br>        <span class="hljs-comment">//一个类在内存中只有一个Class对象</span><br>        <span class="hljs-comment">//一个类被加载后，整个类的结构都会被封装在Class对象中</span><br>        System.out.println(c2.hashCode());<br>        System.out.println(c3.hashCode());<br>        System.out.println(c4.hashCode());<br>        <br>       <br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//实体类 ：pojo entity</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">//有参构造器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> id, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2025/03/26/%E6%B3%A8%E8%A7%A3-%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E5%8F%8D%E5%B0%84/image-20250327222718531.png" alt="image-20250327222718531" style="zoom:50%;"></li></ol><h4 id="获取class对象的三种方式"><a href="#获取class对象的三种方式" class="headerlink" title="获取class对象的三种方式"></a><strong>获取class对象的三种方式</strong></h4><ul><li><p>Class c1&#x3D;类名.class    每一个类都有一个默认的class属性</p></li><li><p>调用Class提供的方法：Class c2&#x3D; Class. forName(“类的全类名”);</p></li><li><p>通过实例 ：  Object 提供的方法： new 类（）； Class c3&#x3D;对象. getClass();    </p><p><strong>注意</strong>：[getClass 返回实际类型的Class类型] </p><p>​ [<em>子类Class 类型的对象</em> getSuperClass方法 可以获得父类的Class 对象 ]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student2</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s1.getClass();<span class="hljs-comment">//创建对象，获得子类的Class对象</span><br>        c1.getSuperclass();<span class="hljs-comment">//通过子类Class对象，获得父类Class对象</span><br></code></pre></td></tr></table></figure><ul><li><p>特殊的： 基本内置类型的包装类都有一个Type 属性</p><p>Class c4&#x3D; Integer.TYPE;</p></li></ul></li></ul><p><em>获取类</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.reflection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-comment">//1.获取类本身：类.Class</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Student.class;<br>        System.out.println(c1);<br><br>        <span class="hljs-comment">//2.获取类本身：Class.forName(&quot;类的全类名&quot;)</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.zhang.reflection.Student&quot;</span>);<br>        System.out.println(c2);<br>        <span class="hljs-comment">//类对象在内存中只会加载一个</span><br>        System.out.println(c1 == c2);<span class="hljs-comment">//true  c1 c2 指向的都是同一个class</span><br><br><br>        <span class="hljs-comment">//3.获取类本身：对象.getClass()</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> s.getClass();<span class="hljs-comment">//任何对象都可以调getClass方法  因为它是Object的方法</span><br>        System.out.println(c3);<br>        System.out.println(c1 == c3);<span class="hljs-comment">//true  c1 c2 c3 指向的都是同一个class</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="所有类型的Class对象"><a href="#所有类型的Class对象" class="headerlink" title="所有类型的Class对象"></a>所有类型的Class对象</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">所有的Class类型：</span><br>类.class:Object.class<br>接口.class: Comparable.class<br>一维数组.class:String[].class<br>二维数组.class:String[][].class<br>注解.class: @Override.class<br>枚举.class: ElementType.class<br>基本数据类型.class: Integer.class    #Integer 是int 基本数据类型的包装类<br>void.class<br>Class.class<br><span class="hljs-meta prompt_"># </span><span class="language-bash">只要元素类型为度一样，就是同一个Class</span><br></code></pre></td></tr></table></figure><hr><h4 id="Java-内存分析"><a href="#Java-内存分析" class="headerlink" title="Java 内存分析"></a>Java 内存分析</h4><p><img src="/2025/03/26/%E6%B3%A8%E8%A7%A3-%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E5%8F%8D%E5%B0%84/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20250328105121-17435969548973.png" alt="联想截图_20250328105121"></p><h3 id="——–"><a href="#——–" class="headerlink" title="——–"></a>——–</h3><h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><h4 id="了解类的加载过程："><a href="#了解类的加载过程：" class="headerlink" title="了解类的加载过程："></a><em>了解类的加载过程：</em></h4><ul><li><p>程序主动使用某个类时，如果该类还未被加载到内存中，系统会自动通过以下三个步骤对该类进行初始化：</p><ul><li><p>类的加载：将类的class文件读入内存，</p><p>并为之在堆中创建一个java.lang.Class对象。此过程<em><strong>由类加载器完成</strong></em></p><ul><li>加载完类之后<em><strong>，在堆中就产生了一个Class 类型的对象，</strong></em>一个类就只有一个Class对象，这个对象包含了完整的类的结构（成员变量，构造器，成员方法….），对象就像一面镜子，透过这个镜子，看到类的结构</li></ul></li><li><p>类的链接：将java类二进制数据合并到 JRE中</p><ul><li>验证：确保加载的类信息符合JVM规范，没有安全方面的问题</li><li>准备：正式为类变量 （static） 分配内存并设置类变量默认初始值的阶段（所以说static在初始化之前就已经有了一个值），这些内存都将在方法区中进行分配</li><li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程</li></ul></li><li><p>类的初始化：JVM负责对类进行初始化</p><p>执行类构造器<clinit>()方法的过程，<code>类构造器&lt;clinit&gt;()方法</code> 是由编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并产生的（就是所有static 的变量和代码块）（类构造器是构造类信息的，<em>不是构造该类对象的构造器</em>）</clinit></p><p>当初始化一个类的时候，如果发现它的父类还没进行初始化，则先触发其父类的初始化</p><p>{说白了，类初始化就是通过类构造器<clinit>()方法将该类的静态变量和静态代码块合并}</clinit></p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.reflection;<br><br><span class="hljs-keyword">import</span> javax.swing.plaf.synth.SynthOptionPaneUI;<br><span class="hljs-keyword">import</span> java.sql.SQLOutput;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        System.out.println(a.m);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 1.加载到内存，在堆中生成一个Class对象</span><br><span class="hljs-comment">        * 2.链接，提前将static 赋值为0（m=0）</span><br><span class="hljs-comment">        * 3.初始化，用&lt;clinit&gt;()方法，将静态变量，静态代码合并起来</span><br><span class="hljs-comment">        * &lt;clinit&gt;()&#123;</span><br><span class="hljs-comment">        * System.out.println(&quot;A类静态代码块初始化&quot;);</span><br><span class="hljs-comment">          m=300;</span><br><span class="hljs-comment">          m=100;</span><br><span class="hljs-comment">          *</span><br><span class="hljs-comment">          * 4.最后m=100</span><br><span class="hljs-comment">        * &#125; */</span><br><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A类静态代码块初始化&quot;</span>);<br>        m=<span class="hljs-number">300</span>;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> m=<span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;A类无参构造初始化&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><p><strong>所以回顾之前的一个结论 静态方法属于类，非静态方法属于对象：</strong></p><p>因为在验证准备阶段，在方法区中会为静态变量分配内存空间，而非静态方法依赖于该类的实例化对象，实例化时才会分配内存</p><p>​</p><hr><h4 id="Java程序的三个阶段："><a href="#Java程序的三个阶段：" class="headerlink" title="Java程序的三个阶段："></a><em>Java程序的三个阶段：</em></h4><p><strong>1 .<strong>先进行编译阶段 ： 源代码通过javac变成class字节码文件（字节码文件中有：类的属性，</strong>构造器</strong>，成员方法….）（存放于方法区）</p><p><strong>2 .</strong> 加载阶段：通过类加载器ClassLoader(体现反射)，在堆中产生了一个Class类型的对象</p><p>**3 .**Runtime运行阶段</p><p>new Cat()对象，这个Cat对象在堆中,&#x3D;&#x3D;该对象知道它是属于哪个Class对象的&#x3D;&#x3D;</p><p><img src="/2025/03/26/%E6%B3%A8%E8%A7%A3-%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E5%8F%8D%E5%B0%84/%E8%81%94%E6%83%B3%E6%88%AA%E5%9B%BE_20250328112734-17435969263562.png" alt="联想截图_20250328112734"></p><hr><h4 id="类初始化的触发"><a href="#类初始化的触发" class="headerlink" title="类初始化的触发"></a>类初始化的触发</h4><blockquote><p>初始化阶段开始之前，自然还是要先经历 加载、验证、准备 、解析的。</p></blockquote><p>回顾类初始化：类构造器通过<clinit>方法将该类中的所有类变量和静态代码块合并起来</clinit></p><ul><li>类的主动引用一定会触发类的初始化<ul><li><u><em><strong>虚拟机启动，先初始化main方法所在的类</strong></em></u></li><li>new 类</li><li>使用java.lang.reflect包的方法进行反射调用 &#x3D;&#x3D;类.class调用反射不能触发类的初始化&#x3D;&#x3D;</li><li>直接用类调用静态方法或属性 （除了final变量）</li></ul></li><li>类的被动引用不会触发类的初始化<ul><li>子类调用父类的静态方法或属性（子类不会初始化，父类被初始化）</li><li>通过数组定义类引用</li><li>引用一个类中的常量，不会触发该类的初始化（<em><strong>常量在链接阶段就存入调用类的常量池中了</strong></em>）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.reflection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test06</span> &#123;<br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Main 类被加载&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-comment">//1.主动引用 触发初始化</span><br>        <span class="hljs-comment">//Son son=new Son();</span><br><br><br>        <span class="hljs-comment">//2. 用java.lang.reflect包调用反射也能触发初始化</span><br>        <span class="hljs-comment">//Class&lt;?&gt; aClass = Class.forName(&quot;com.zhang.reflection.Son&quot;);</span><br>        <span class="hljs-comment">//** 用类默认的class属性  不能触发类的初始化  而 Object的getClass()方法 先new了就触发类的初始化啦</span><br>       <span class="hljs-comment">// Class&lt;Son&gt; sonClass = Son.class;</span><br><br><br>        <span class="hljs-comment">//3.子类调用自己的静态方法或属性  可以触发类初始化，父类未初始化的情况下，就先触发其父类的初始化</span><br>        <span class="hljs-comment">// System.out.println(Son.m);</span><br><br><br>        <span class="hljs-comment">//而不会触发类初始化的：</span><br>        <span class="hljs-comment">//1.子类调用父类静态方法或属性</span><br>       <span class="hljs-comment">//System.out.println(Son.b);</span><br>        <span class="hljs-comment">//2.数组</span><br>       <span class="hljs-comment">// Son[] array=new Son[10];//这个只会加载Main 方法，只初始化Test06</span><br>        <span class="hljs-comment">//3.常量</span><br>        <span class="hljs-comment">//System.out.println(Son.M);</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> b=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;父类被加载&quot;</span>);<br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;子类被加载&quot;</span>);<br>        m=<span class="hljs-number">300</span>;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> m=<span class="hljs-number">200</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> M=<span class="hljs-number">11</span>;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="类加载器的作用"><a href="#类加载器的作用" class="headerlink" title="类加载器的作用"></a>类加载器的作用</h3><ul><li>引导类加载器： 用c++编写，该加载器无法直接获取</li><li>扩展类加载器：</li><li>系统类加载器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.reflection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test07</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-comment">//获取系统类的加载器</span><br>        ClassLoader systemClassLoader=ClassLoader.getSystemClassLoader();<br>        System.out.println(systemClassLoader);<br>        <span class="hljs-comment">//获取系统类的加载器的父类加载器----&gt;扩展类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> systemClassLoader.getParent();<br>        System.out.println(parent);<br><br>        <span class="hljs-comment">//获取扩展类加载器的父类加载器--&gt;根加载器（c/c++写的）</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">parent1</span> <span class="hljs-operator">=</span> parent.getParent();<br>        System.out.println(parent1);<br><br>        <span class="hljs-comment">//测试当前类的加载器（它是哪个类加载的）</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.zhang.reflection.Test07&quot;</span>).getClassLoader();<br>        System.out.println(classLoader);<br>        <span class="hljs-comment">//测试jdk内部的类是谁加载的</span><br>        classLoader=Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getClassLoader();<br>        System.out.println(classLoader);<br><br>        <span class="hljs-comment">//获得系统类加载器可以加载的路径</span><br>        System.out.println(System.getProperty(<span class="hljs-string">&quot;java.class.path&quot;</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>双亲委派机制：</p><p>双亲委派模型的工作过程为：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。</p><hr><h3 id="———"><a href="#———" class="headerlink" title="———"></a>———</h3><h1 id="反射-1"><a href="#反射-1" class="headerlink" title="反射"></a>反射</h1><h4 id="获取类的运行结构"><a href="#获取类的运行结构" class="headerlink" title="获取类的运行结构"></a>获取类的运行结构</h4><ul><li><p>类的名字 </p><p>类对象.getName()</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过Class.forName()获得Class对象</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.zhang.reflection.User&quot;</span>);<br><br>        <span class="hljs-comment">//获得类的名字</span><br>        System.out.println(c1.getName());<span class="hljs-comment">//包名+类名</span><br>        System.out.println(c1.getSimpleName());<span class="hljs-comment">//类名</span><br><span class="hljs-comment">//也可以通过new 得到Class对象，获得类名字</span><br><span class="hljs-type">User</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;xiao&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">18</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> u1.getClass();<br>        System.out.println(c2.getName());<br></code></pre></td></tr></table></figure><ul><li><p>类的属性</p><p>类对象.getFields(): 获取所有public属性</p><p>类对象.getDeclaredFields(): 获取所有的属性</p><p>类对象.getDeclaredField(“name”):获取指定的属性</p><p>类对象.getField(“name”)：获得指定的public属性</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获得类的属性  getFields()方法   返回的是数组</span><br>       Field[] fields = c1.getFields(); <span class="hljs-comment">//！！getFields 获得的是public属性</span><br>       fields=c1.getDeclaredFields();<span class="hljs-comment">//!! getDeclaredFields获得的是全部属性</span><br><br>       <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>           System.out.println(field);<br>       &#125;<br>       System.out.println(<span class="hljs-string">&quot;====&quot;</span>);<br><br>       <span class="hljs-comment">//获得指定属性</span><br>       Field id=c1.getDeclaredField(<span class="hljs-string">&quot;id&quot;</span>);<span class="hljs-comment">//注意有参数的没有 s</span><br>       System.out.println(id);<br></code></pre></td></tr></table></figure><ul><li><p>类的方法</p><p>getMethods()   获取本类及父类的所有public方法</p><p>getDeclaredMethods()  ：获取本类的所有方法</p><p>getMethod(“方法名”，“参数（丢个类型）反射的形式）”)   ： 获取本类及父类的指定public方法</p><p>getDeclaredMethod(“方法名”，“参数（反射的形式）”) ：获取本类的所有方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获得类的方法</span><br>        System.out.println(<span class="hljs-string">&quot;====&quot;</span>);<br>        Method[] methods = c1.getMethods();<span class="hljs-comment">//获得本类及其父类的全部public方法</span><br><br>        <span class="hljs-keyword">for</span>(Method m: methods)&#123;<br>            System.out.println(<span class="hljs-string">&quot;正常的&quot;</span>+m);<br>        &#125;<br>        ;<br>        methods=c1.getDeclaredMethods();<span class="hljs-comment">//获得本类的全部方法</span><br>        <span class="hljs-keyword">for</span>(Method m: methods)&#123;<br>            System.out.println(<span class="hljs-string">&quot;getClaredMethods&quot;</span>+m);<br><br>        &#125;<br>        <span class="hljs-comment">//获得指定方法</span><br>        <span class="hljs-comment">//一定需要写方法的参数  有重载的情况</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">getName</span> <span class="hljs-operator">=</span> c1.getMethod(<span class="hljs-string">&quot;getName&quot;</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-type">Method</span> <span class="hljs-variable">setName</span> <span class="hljs-operator">=</span> c1.getMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<br><br>        System.out.println(getName);<br>        System.out.println(<span class="hljs-string">&quot;===========&quot;</span>);<br><br></code></pre></td></tr></table></figure><ul><li><p>类的构造器</p><p>getConstructors():获得所有public构造器（本类）</p><p>……如有参数,参数也是反射类型的</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获得所有构造器</span><br>       Constructor[] constructor = c1.getConstructors();<br>        <span class="hljs-keyword">for</span>(Constructor c: constructor)&#123;<br>           System.out.println(c);<br>       &#125;<br>       Constructor[] declaredConstructors = c1.getDeclaredConstructors();<br>        <span class="hljs-comment">//获得指定构造器</span><br>       <span class="hljs-type">Constructor</span> <span class="hljs-variable">declaredConstructor</span> <span class="hljs-operator">=</span> c1.getDeclaredConstructor(String.class, <span class="hljs-type">int</span>.class, <span class="hljs-type">int</span>.class);<span class="hljs-comment">//参数必须是反射的形式</span><br>       System.out.println(declaredConstructor);<br></code></pre></td></tr></table></figure><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><ul><li><p>getDeclaredField(“属性名”)</p></li><li><p>getDeclaredMethod(“方法名”，参数（class形式的）)</p></li><li><p>getDeclaredConstructor(参数（class形式的）) 构造器与类肯定同名不需要写构造器名了</p></li><li><p>getDeclaredAnnotation(注解(class形式的))  </p><p>注解VS构造器：<br>注解不需要写参数，构造器不需要写构造器名</p></li></ul><hr><h4 id="动态创建对象执行方法"><a href="#动态创建对象执行方法" class="headerlink" title="动态创建对象执行方法"></a>动态创建对象执行方法</h4><ul><li>总结流程就是：<ol><li>先由反射获得Class对象</li><li>Class对象 通过getDeclaredConstructor().newInstance()获得一般对象  （之后备用哈ha）</li><li>获得（抽象【就是由class对象getDeclaredField()得到的】）（其实也就是Method,Field对象）属性&#x2F;方法</li><li>将抽象属性&#x2F;方法&#x2F;构造器 进行（set&#x2F;invoke&#x2F;） 抽象方法激活，抽象属性设置<ul><li>抽象方法.invoke（所属的一般对象,方法的参数值）</li><li>抽象属性.set(所属的一般对象，属性赋值)</li></ul></li></ol></li></ul><p><strong>注意：</strong></p><ol><li><p>操作私有的方法或属性时：需要将程序的安全检验关掉并使用detDeclaredMethod&#x2F;getDeclaredFiled 获取指定私有方法或属性</p><p>Method,Field,Constructor 对象都有setAccessible()方法</p><p>参数值为true则指反射的对象在使用时应该取消Java语言访问检查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">方法或属性.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-comment">//关闭程序的安全及检验只是能对私有方法或属性操作，但并不能直接调用,之后还得借助public的方法</span><br>   <br></code></pre></td></tr></table></figure></li><li><p>class对象.getDeclaredConstructor().newInstance()  之后得到的是Object类型的对象，<strong>需强转成想要的类型</strong></p></li><li><p>得到抽象方法或属性时，注意第二个参数是反射类型的</p></li></ol><p>细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取Class对象</span><br>       <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.zhang.reflection.User&quot;</span>);<br>       <span class="hljs-comment">//Class对象创建一般对象  返回的是Object类型的，需强转成User类型的</span><br>       <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> (User)c1.getDeclaredConstructor().newInstance();<span class="hljs-comment">//这里需要注意getDeclaredConstructor()不加参数 本质上是调用的无参构造器，没有public 无参构造器会报错的！！</span><br>       System.out.println(user1);<br><br>       <span class="hljs-comment">//通过有参构造器创建对象</span><br>       <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> c1.getDeclaredConstructor(String.class, <span class="hljs-type">int</span>.class, <span class="hljs-type">int</span>.class);<br>       <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span>(User) constructor.newInstance(<span class="hljs-string">&quot;xiao&quot;</span>, <span class="hljs-number">001</span>, <span class="hljs-number">18</span>);<br>       System.out.println(user2);<br>       <span class="hljs-comment">//直接调用</span><br>      <span class="hljs-comment">/* user1.setName(&quot;xiao&quot;);</span><br><span class="hljs-comment">       System.out.println(user1.getName());*/</span><br><br>       <span class="hljs-comment">//通过反射调用普通方法</span><br>       <span class="hljs-type">User</span> <span class="hljs-variable">user3</span> <span class="hljs-operator">=</span> (User) c1.getDeclaredConstructor().newInstance();<br>       <span class="hljs-comment">//先获得抽象方法          上面代码这里本质上调用无参构造器</span><br>       <span class="hljs-type">Method</span> <span class="hljs-variable">setName</span> <span class="hljs-operator">=</span> c1.getDeclaredMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<br>       <span class="hljs-comment">//激活抽象方法</span><br>      setName.invoke(user3,<span class="hljs-string">&quot;xiao&quot;</span>);<br>       System.out.println(user3.getName());<br>       System.out.println(<span class="hljs-string">&quot;333333333333&quot;</span>);<br>       <br><br><span class="hljs-comment">//操作私有方法试一下</span><br>       <span class="hljs-comment">//1.先得到指定的抽象的方法</span><br>       <span class="hljs-type">Method</span> <span class="hljs-variable">test5</span> <span class="hljs-operator">=</span> c1.getDeclaredMethod(<span class="hljs-string">&quot;test5&quot;</span>);<br>       test5.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-comment">//关闭程序的安全及检验只是能对私有方法或属性操作，但并不能直接调用</span><br>       test5.invoke(user3,<span class="hljs-literal">null</span>);<br>       user3.getTest05();<span class="hljs-comment">//调用私有方法它无返回值时一定不能打印！！，直接调用即可</span><br></code></pre></td></tr></table></figure><h4 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test10</span>&#123;<br><br>    <span class="hljs-comment">//普通测试</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test01</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000000</span>; i++) &#123;<br>            user.getName();<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;普通方式执行&quot;</span>+(end - start));<br>    &#125;<br><br><br>    <span class="hljs-comment">//反射测试</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        Class&lt;User&gt; c1 = User.class;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">getName</span> <span class="hljs-operator">=</span> c1.getDeclaredMethod(<span class="hljs-string">&quot;getName&quot;</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000000</span>; i++) &#123;<br>            getName.invoke(user,<span class="hljs-literal">null</span>);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;反射方式执行&quot;</span>+ (end - start));<br>    &#125;<br><br><br>    <span class="hljs-comment">//反射测试  关闭检测</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        Class&lt;User&gt; c1 = User.class;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">getName</span> <span class="hljs-operator">=</span> c1.getDeclaredMethod(<span class="hljs-string">&quot;getName&quot;</span>, <span class="hljs-literal">null</span>);<br>        getName.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000000</span>; i++) &#123;<br>            getName.invoke(user,<span class="hljs-literal">null</span>);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(end - start);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, NoSuchMethodException, IllegalAccessException &#123;<br>        test01();<span class="hljs-comment">//3</span><br>        test02();<span class="hljs-comment">//4194</span><br>        test03();<span class="hljs-comment">//3750  关闭点检测能提高点效率</span><br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul><li>泛型就是表示一种数据类型的数据类型</li><li>泛型俗称“标签”，使用<E>表示。泛型就是在允许定义类，接口时通过一个标识表示某个属性的类型或者是某个方法的返回值或者是参数类型，参数类型在具体使用的时候确定，在使用之前对类型进行检查。</E></li><li>在类声明或实例化对象是只要指定好需要的具体类型即可<ul><li>在类声明时通过一个标识表示类中某个属性的类型或某个方法&#x2F;构造器的返回值类型，参数类型</li></ul></li><li><strong>补充：在Java库中，使用变量E表示集合的元素类型，K和V分别表示关键字和值的类型。T表示任意类型。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&lt;E&gt;&#123;<br>    E s;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(E s)</span>&#123;<br>        <span class="hljs-built_in">this</span>.s=s;<br>    &#125;<br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">f</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>泛型的声明</p><p>interface接口<T>{} 和class 类&lt;K,V&gt;{}</T></p><p>T,K,V代表类型</p></li><li><p>泛型的好处：</p><ul><li>编译时检查添加的元素的类型，提高了安全性</li><li>减少了类型转换的次数，提高效率</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//ArrayList&lt;Dog&gt; 表示存放到集合ArrayList中的元素都是Dog类型</span><br>        <span class="hljs-comment">//若编译器发现添加的元素不是指定的Dog类型，就会报错的</span><br>        ArrayList&lt;Dog&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Dog&gt;();<br>        arrayList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;汪汪&quot;</span>,<span class="hljs-number">10</span>));<br>        arrayList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;旺财&quot;</span>,<span class="hljs-number">1</span>));<br>        arrayList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;小汪&quot;</span>,<span class="hljs-number">5</span>));<br>        <span class="hljs-comment">//遍历：之前传统方式直接取Dog类型的会报错，只能取Object类型的然后再向下转，现在就可以直接取Dog类型的啦</span><br>        <span class="hljs-keyword">for</span> (Dog d : arrayList) &#123;<br>            System.out.println(d.getName()+<span class="hljs-string">&quot;:&quot;</span>+d.getAge());<br>        &#125;<br><br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>     <span class="hljs-keyword">private</span> String name;<br>     <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>泛型的分类：</p><ul><li><p>类泛型：类定义中使用类型参数代表具体谁的类型，在实例化类时指定类型参数</p></li><li><p>泛型方法：适用于传许多不同的类型数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Printer</span> &#123;<br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(T data)</span> &#123;<br>        System.out.println(data);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用泛型方法打印不同类型的数据</span><br><span class="hljs-type">Printer</span> <span class="hljs-variable">printer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Printer</span>();<br>printer.print(<span class="hljs-string">&quot;Hello&quot;</span>); <span class="hljs-comment">// 打印输出: Hello</span><br><br>printer.print(<span class="hljs-number">123</span>); <span class="hljs-comment">// 打印输出: 123</span><br><br>printer.print(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// 打印输出: 3.14</span><br></code></pre></td></tr></table></figure></li><li><p>泛型接口：<strong>当我们需要定义一个可以适用于不同类型的接口时，就可以使用泛型接口</strong>，在实现类中传具体的数据类型</p><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBox</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Box</span>&lt;String&gt; <br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="反射获取泛型信息"><a href="#反射获取泛型信息" class="headerlink" title="反射获取泛型信息"></a>反射获取泛型信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.reflection;<br><br><br><br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.ParameterizedType;<br><span class="hljs-keyword">import</span> java.lang.reflect.Type;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-comment">//通过反射获取泛型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test11</span> &#123;<br>    <span class="hljs-comment">//泛型作为参数</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test01</span><span class="hljs-params">(Map&lt;String,User&gt; map, List&lt;User&gt; list)</span> &#123;<br><br>       System.out.println(<span class="hljs-string">&quot;test01&quot;</span>);<br>   &#125;<br>    <span class="hljs-comment">//泛型作为返回类型</span><br>    <span class="hljs-keyword">public</span> Map&lt;String,User&gt; <span class="hljs-title function_">test02</span><span class="hljs-params">()</span>&#123;<br>           System.out.println(<span class="hljs-string">&quot;test02&quot;</span>);<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br><br><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException &#123;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> Test11.class.getMethod(<span class="hljs-string">&quot;test01&quot;</span>, Map.class, List.class);<span class="hljs-comment">//Method对象</span><br>        Type[] genericExceptionTypes = method.getGenericParameterTypes();<span class="hljs-comment">//获得泛型的参数类型</span><br>        <span class="hljs-keyword">for</span> (Type genericParameterType : genericExceptionTypes) &#123;<br>            System.out.println(<span class="hljs-string">&quot;#&quot;</span>+genericParameterType);<br>                                                            <span class="hljs-comment">//ParameterizedType 表示一种参数化类型</span><br>            <span class="hljs-keyword">if</span> (genericParameterType <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();<span class="hljs-comment">//强转获得真实参数信息</span><br>                <span class="hljs-keyword">for</span>(Type actualTypeArgument : actualTypeArguments)&#123;<br>                    System.out.println(actualTypeArgument);<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;========&quot;</span>);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method2</span> <span class="hljs-operator">=</span> Test11.class.getMethod(<span class="hljs-string">&quot;test02&quot;</span>,<span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Type</span> <span class="hljs-variable">genericReturnType</span> <span class="hljs-operator">=</span> method2.getGenericReturnType();<span class="hljs-comment">//获得泛型的返回类型</span><br>        <span class="hljs-keyword">if</span> (genericReturnType <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>            Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();<span class="hljs-comment">//强转获得真实参数信息</span><br>            <span class="hljs-keyword">for</span>(Type actualTypeArgument : actualTypeArguments)&#123;<br>                System.out.println(actualTypeArgument);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>泛型可作为方法的参数也可作为方法的返回类型</p><p>总的思路是：</p><ol><li>先获得Method 方法</li><li>再获得泛型的参数类型或者返回类型（看泛型在哪个位置）</li><li>强转获得真实参数信息</li></ol></li></ul><h4 id="反射获取注解信息"><a href="#反射获取注解信息" class="headerlink" title="反射获取注解信息"></a>反射获取注解信息</h4><ul><li>ROM：Object relationship Mapping —–&gt; 对象关系映射</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.reflection;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-comment">//练习反射操作注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test13</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchFieldException, NoSuchMethodException &#123;<br>        <span class="hljs-comment">//创建反射对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.zhang.reflection.Student33&quot;</span>);<br>        Annotation[] annotations = c1.getAnnotations();<br>        <span class="hljs-keyword">for</span> (Annotation annotation : annotations) &#123;<br>            System.out.println(annotation);<br>        &#125;<br><br>        <span class="hljs-comment">//获得指定注解的value值  类注解是直接由class对象操作</span><br>        <span class="hljs-type">A2</span> <span class="hljs-variable">annotationA2</span> <span class="hljs-operator">=</span> (A2)c1.getAnnotation(A2.class);  <span class="hljs-comment">//返回Annotation 类型的 强转成A2</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> annotationA2.value();<br>        System.out.println(value);<br>        <br>        <span class="hljs-comment">//获得指定的属性注解    属性注解 ： 先获得class对象，再由生成的Field对象 （抽象属性）操作</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameClass</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;id&quot;</span>);<br>        <span class="hljs-type">B</span> <span class="hljs-variable">annotation</span> <span class="hljs-operator">=</span> nameClass.getAnnotation(B.class);<span class="hljs-comment">//由（抽象）属性获得指定属性注解</span><br>        System.out.println(annotation.columnName());<br>        System.out.println(annotation.type());<br>        System.out.println(annotation.length());<br><br>        <span class="hljs-comment">//获得指定构造器注解亦同理</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> c1.getDeclaredConstructor(<span class="hljs-literal">null</span>);  <span class="hljs-comment">//这里注意获取指定的构造器括号里只需写参数类型，不能再写构造器名称了</span><br>        <span class="hljs-type">C</span> <span class="hljs-variable">annotation1</span> <span class="hljs-operator">=</span> (C)constructor.getAnnotation(C.class);<br>        System.out.println(annotation1.value());<br><br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-meta">@A2(&quot;db_student&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student33</span>&#123;<br>    <span class="hljs-meta">@B(columnName=&quot;db_name&quot;,type=&quot;varchar&quot;,length=3)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@B(columnName=&quot;db_age&quot;,type=&quot;int&quot;,length=10)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-meta">@B(columnName=&quot;db_id&quot;,type=&quot;int&quot;,length=10)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-meta">@C(&quot;CONSTRUCTIR&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student33</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//自定义类注解</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> A2 &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//自定义属性的注解</span><br><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> B&#123;<br>    String <span class="hljs-title function_">columnName</span><span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">type</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//构造器注解</span><br><span class="hljs-meta">@Target(ElementType.CONSTRUCTOR)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> C&#123;<br>   String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h4><p>抽象对象（瞎编的一个词）  即由class对象下的各种Method&#x2F;Field&#x2F;Constructor对象（或它们下的对象）</p><ul><li><p>反射获得类注解</p><ol><li><p>获得class对象 c1</p></li><li><p>获得抽象注解：直接class对象c1 由<code>getAnnotation(指定注解.class) </code>获得指定（抽象的）类注解</p><p><strong>注意(抽象)类注解获得的时候自动返回Annotation类的，要强转一下，转成指定的类注解</strong></p></li><li><p>由(<strong>抽象的)类注解.value()</strong> 即可获得注解值</p></li></ol></li><li><p>反射获得属性注解</p><ol><li>获得class对象 c1</li><li>获得抽象属性：（多一步）由class对象c1 先生成（抽象即Field对象）属性对象:<ul><li>c1.getDeclaredField(name)</li></ul></li><li>(抽象)属性对象 由<code>getAnnotation(指定注解.class) </code>获得指定（抽象的）类注解</li><li>由(<strong>抽象的)类注解.value()</strong> 即可获得注解值</li></ol></li><li><p>反射获得构造器注解</p><ol><li>获得class对象 c1</li><li>获得抽象构造器：（多一步）由class对象c1 先生成（抽象即Constructor对象）构造器对象:<ul><li>c1.getDeclaredConstructor(参数class类)</li></ul></li><li>(抽象)构造器对象 由<code>getAnnotation(指定注解.class) </code>获得指定（抽象的）类注解</li><li>由(<strong>抽象的)类注解.value()</strong> 即可获得注解值</li></ol></li><li><p>反射获得方法注解同理</p></li></ul><p>（总的感觉从反射这一层来看：注解是抽象类的抽象属性&#x2F;方法&#x2F;构造器的下一抽象层）</p><p>什么类型的抽象对象.getAnnotation(什么类型的注解.class)—-&gt;得到抽象的一个注解</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/2025/03/20/java-%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/03/20/java-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><span id="more"></span><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li><p>单行注释&#x2F;&#x2F;  （ctrl +&#x2F;）</p></li><li><p>多行注释(ctrl+shift+&#x2F;)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/*文字*/<br></code></pre></td></tr></table></figure></li></ul><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul><li>字母（大小写），数字，下划线，美元符组成，但不能以数字开头</li><li>大小写敏感</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>基本数据类型，引用数据类型</p><ul><li><p>强类型语言：所有变量先定义后使用</p></li><li><p>基本数据类型：</p><p>数值类型：</p><ul><li>整数类型：byte（1个字节）,short（2个字节）,int(默认)(4个字节),long(long数字后要加L)（8个字节）</li><li>浮点类型：float(float 数字后要加F)，double(默认)</li><li>字符类型：char（2个字节）</li></ul><p>boolean:</p><p>​true false（1位）</p></li><li><p>引用类型：</p><ul><li>类</li><li>接口</li><li>数组</li></ul></li></ul><hr><p><strong>最好完全避免使用float类型的数字进行比较：float 离散，舍入误差</strong></p><p><strong>所有的字符本质上还是数字</strong></p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">String sa=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>String sb=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><br>System.out.println(sa==sb);<span class="hljs-comment">//false</span><br><br>String sc=<span class="hljs-string">&quot;hello world&quot;</span>;<br>String sd=<span class="hljs-string">&quot;hello world&quot;</span>;<br>System.out.println(sc==sd);<span class="hljs-comment">//true 对象  从内存分析</span><br></code></pre></td></tr></table></figure><hr><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><p>低—–&gt;高</p><p>byte,short,char,int,long,float,double</p></li></ul><p>不能对布尔值进行转换</p><p><strong>强制转换</strong></p><ul><li>要避免内存溢出</li></ul><p><strong>自动转换</strong></p><ul><li><p>低—&gt;高</p></li><li><p>注意计算时内存溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> money=<span class="hljs-number">1000000000</span>;<br><span class="hljs-type">int</span> yers=<span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> total=money*years<span class="hljs-comment">//结果为负数</span><br><span class="hljs-type">long</span> total2=money*years<span class="hljs-comment">//也为负，mony years 默认是int 计算之后还是int，在转换之前就出问题了</span><br><span class="hljs-type">long</span> total3=money*((<span class="hljs-type">long</span>)years)<span class="hljs-comment">//先把一个数转换成long</span><br></code></pre></td></tr></table></figure><hr><h4 id="数据类型的范围"><a href="#数据类型的范围" class="headerlink" title="数据类型的范围"></a>数据类型的范围</h4><ul><li>byte:<strong>-128-127</strong></li><li>short:<strong>-32768~32767</strong></li><li>int:<strong>-2147483648~2147483647</strong></li><li>long：**-9223372036854775808~9223372036854775807**</li></ul></li></ul><hr><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>类变量(static)，实例变量，局部变量</p><ul><li><p>实例变量：(在类里面 main方法外面）</p><p>从属于对象，如果不初始化，会有默认值</p><ul><li>所有的数字默认值是0 或 0.0</li><li>布尔值默认是：false</li><li>除基本数据类型外（即引用类型）：都是null</li></ul></li><li><p>类变量：**<u><em>static</em></u>** （当然也是在类里面main方法外面）</p><p>从属于类，<strong>可以直接在main里面直接调用</strong></p></li><li><p>局部变量：（在main方法里面）</p><p>必须声明变量类型和初始值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br><br>    <span class="hljs-comment">//类变量  static  从属类</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> salary=<span class="hljs-number">2500</span>;<br><br>    <span class="hljs-comment">//实例变量：从属于对象；（在类里面main方法外面）</span><br>    String name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">//main 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//局部变量，在main里面：必须声明变量类型和初始化值</span><br>        <span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br>        System.out.println(i);<br><br>        <span class="hljs-comment">//变量类型  变量名称</span><br>        <span class="hljs-type">Dome01</span> <span class="hljs-variable">dome01</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dome01</span>();<br>        System.out.println(dome01);<br>        System.out.println(salary);<br>    &#125;<br><br><br></code></pre></td></tr></table></figure><hr><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>final  常量名 &#x3D;值</p><p>常量名一般使用大写字符</p><p>修饰符不存在先后顺序</p><p>命名规范</p><ul><li>所有变量，方法，类名：见名知意</li><li>类成员变量：首字母小写和驼峰原则（monthSalary）即除第一个单词外后面的单词首字母都大写</li><li>局部变量： 首字母小写+驼峰原则</li><li>常量：大写字母和下划线MAX_VALUE</li><li>类名：首字母大写+驼峰原则 Man GoodMan</li><li>方法名：首字母小写+驼峰原则</li></ul><hr><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li>long,int,short,byte 进行运算时，有long 的，直接变化为为long ，其余的都是**<u><em>自动转化为int</em></u>**</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> operator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">long</span> a=<span class="hljs-number">1231231323123132L</span>;<br>        <span class="hljs-type">int</span> b=<span class="hljs-number">123</span>;<br>        <span class="hljs-type">short</span> c=<span class="hljs-number">10</span>;<br>        <span class="hljs-type">byte</span> d=<span class="hljs-number">8</span>;<br>        System.out.println(a+b+c+d);<span class="hljs-comment">//long</span><br>        System.out.println(b+c+d);<span class="hljs-comment">//int</span><br>        System.out.println(c+d);<span class="hljs-comment">//int</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>关系运算符返回结果：true,false</p><ul><li>instanceof 关系运算符</li></ul></li><li><p>自增减运算符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> a=<span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> b=a++;<br>System.out.println(b);<span class="hljs-comment">//b=3  a=4</span><br><span class="hljs-type">int</span> c=++a;<br>System.out.println(c);<span class="hljs-comment">//c=5   a=5</span><br>System.out.println(a);<span class="hljs-comment">//a=5</span><br><br><br></code></pre></td></tr></table></figure></li><li><p>逻辑运算符：and or !</p></li><li><p>位运算符：</p><p>&amp;：两个都是1才为1</p><p>|：都是0才为0</p><p>^：对应位相同为0，不同为1</p><p><code>&lt;&lt; </code>:*2</p><p><code>&gt;&gt;</code>:&#x2F;2</p></li><li><p>连接符+：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> operator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> b=<span class="hljs-number">20</span>;<br>        System.out.println(a+b);<span class="hljs-comment">//30</span><br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>+a+b);<span class="hljs-comment">//1020</span><br>        System.out.println(a+b+<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//30</span><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>三元运算符</p><p>x ? y : z</p><hr></li></ul><h3 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h3><p>语法格式为：<br><code>package package1[.package2[.package3...]];</code></p><p>在正式的开发中，一般都采用公司域名倒置来作为包名</p><p>导入包，使用<code>import</code>语句将其导入，具体语法如下：<br><code>import package1[.package2[.package3...]].(ClassName|*);</code></p><h3 id="javaDoc"><a href="#javaDoc" class="headerlink" title="javaDoc"></a>javaDoc</h3><p>将注释信息生成帮助文档</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@auther</span> <br><span class="hljs-meta">@Version</span><br><span class="hljs-meta">@Since</span><br><span class="hljs-meta">@param</span><br><span class="hljs-meta">@throws</span><br></code></pre></td></tr></table></figure><p>javaDoc用来生成自己的API文档</p><p><strong>生成文档：</strong>cmd打开：<strong>javadoc  -encoding UTF-8 -charset UTF-8  Doc.java</strong>  UTF-8编码，避免出现非英语字符乱码</p><p>在代码文件对应的位置会多出许多文件，index.html打开就是生成的文档</p><p><a href="https://blog.csdn.net/vbirdbest/article/details/80296136">理解Javadoc-CSDN博客</a></p><h2 id="————"><a href="#————" class="headerlink" title="————"></a>————</h2><h3 id="Scanner对象"><a href="#Scanner对象" class="headerlink" title="Scanner对象"></a>Scanner对象</h3><ul><li>next接受以空格作为结束标志</li><li>nextLine接受 回车作为结束标志</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.scanner;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//创建扫描器对象，用于接收键盘数据</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;使用next方法接收：&quot;</span>);<br>        <span class="hljs-comment">//判断用户有没有输入字符串</span><br>        <span class="hljs-keyword">if</span> (scanner.hasNext())&#123;<br>            <span class="hljs-comment">//使用next方式接受</span><br>            String str=scanner.next();<br>            System.out.println(<span class="hljs-string">&quot;输出内容为：&quot;</span>+str);<br>        &#125;<br>        <span class="hljs-comment">//属于IO流类的不关闭会占用资源</span><br>        scanner.close();<br><br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>小练习</p><p>接受double类型的数字并计算总和及平均值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.scanner;<br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome03</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">double</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span> (scanner.hasNextDouble()) &#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> scanner.nextDouble();<br>            sum=sum+a;<br>            m++;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;sum为&quot;</span>+sum);<br>        System.out.println(<span class="hljs-string">&quot;平均数为&quot;</span>+(sum/m));<br>        scanner.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li><p>选择结构 </p><p>if </p><p>switch:</p><ul><li><p>注意case穿透现象，写完每个case后都应该加上一个break</p></li><li><p>jdk7后switch也支持字符串比较即括号里的表达式也可以是字符串（字符串用双引号）</p></li></ul></li><li><p>循环结构</p><p>while,do…while</p><p>for:</p><ul><li><p>(for (int i &#x3D; 0; i &lt; 100; i++) {}):快捷键：<strong>100.for</strong></p></li><li><p>for(;;) {}死循环</p><p>九九乘法表小练习</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.struct;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span>( j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>                System.out.print(j+<span class="hljs-string">&quot;*&quot;</span>+i+<span class="hljs-string">&quot;=&quot;</span>+(i*j)+ <span class="hljs-string">&quot;\t&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>增强for循环：</p><p>for(声明语句：表达式){</p><p>}</p><p>声明语句：声明新的局部变量，该变量的类型必须与数组元素的类型匹配</p><p>表达式：要访问的数组名，或者是返回值是数组的方法</p><p><strong>之后数组重点使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.struct;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] numbers=&#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>&#125;;<span class="hljs-comment">//定义一个数组</span><br><br>        <span class="hljs-comment">//遍历数组元素 增强for循环</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x:numbers) &#123;<br>            System.out.println(x);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;=======&quot;</span>);<br><br>        <span class="hljs-comment">//等同于以下for循环</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            System.out.println(numbers[i]);<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul></li></ul><hr><p><strong>小练习打印三角形</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.struct;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome05</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<br>            <span class="hljs-comment">//分割成三部分打印</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">5</span>;j&gt;i;j--)&#123;<br>                System.out.print(<span class="hljs-string">&quot;*&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>                System.out.print(<span class="hljs-string">&quot;~&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;<br>               System.out.print(<span class="hljs-string">&quot;^&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>   <br>&#125;<br><span class="hljs-comment">/*结果，</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">****~</span><br><span class="hljs-comment">***~~^</span><br><span class="hljs-comment">**~~~^^</span><br><span class="hljs-comment">*~~~~^^^</span><br><span class="hljs-comment">~~~~~^^^^</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">将内层第一个for换成空格，第二三个for换成*，即可打印出三角形</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>类似c的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//eg:</span><br>System.out.prinntln()<br><span class="hljs-comment">//类   对象   方法</span><br></code></pre></td></tr></table></figure><p><strong>设计方法的原则：</strong>一个方法只完成一个功能，有利于后期去扩展</p><p><strong>方法命名规则：</strong> 首字母小写+驼峰</p><p><strong>方法的定义：</strong> 修饰符 返回类型 方法名（参数类型 参数名）</p><ul><li>修饰符：可选，告诉编译器如何调用该方法，定义了该方法的访问类型</li></ul><p><strong>方法的调用</strong>：对象名.方法名（实参列表）</p><p><strong>方法的重载</strong>：</p><p>在一个类中有相同的函数名，但形参不同的函数（<u><em>调用时根据参数类型不同调用）</em></u></p><ul><li>重载规则：</li><li>方法名称必须相同</li><li>参数列表必须不同（个数或类型不同或参数排列顺序不同）</li><li>方法返回类型可以相同也可以不同（重点在于参数那块不同）</li><li>仅仅返回类型不同不足以成为方法重载</li></ul><h3 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a>命令行传参</h3><ul><li><p>cmd窗口先编译成Dome01.class(命令：javac Dome01.java)</p><p>执行编译文件时注意要加上包名，找对路径（在src目录下执行java xxx.xxx.xxx.Dome01 传参）</p></li></ul><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>本质是数组</p><ul><li>在方法声明中，在指定参数类型后加一个省略号…</li><li>一个方法中只能指定一个可变参数，<strong>它必须是方法的最后一个参数</strong></li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//阶乘</span><br><span class="hljs-keyword">package</span> com.zhang.method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> b=<span class="hljs-number">4</span>;<br>        System.out.println(f(b));<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br>        <span class="hljs-keyword">if</span> (a==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> a*f(a-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>声明：</strong></p><ul><li>int[] array1; 首选方法</li><li>int array1[];</li></ul><p><strong>开辟空间</strong>：array1&#x3D;new int [10] ;</p><p>—–&gt;int[] array2&#x3D;new int[10];</p><p>首先在栈里创建对象，new:在堆里开辟内存空间，在堆里赋值</p><h4 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a><strong>初始化：</strong></h4><ul><li><p>静态初始化：创建以后不可更改</p><p>int[] a&#x3D;{1,2,3,4,5};</p><p>静态初始化是在声明数组的同时为数组元素赋值。语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 语法</span><br>type[] arrayName = &#123;value1, value2, value3,...&#125;;<br><br><span class="hljs-comment">// 示例</span><br><span class="hljs-type">int</span>[] numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>String[] fruits = &#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>&#125;;<br></code></pre></td></tr></table></figure><p>在静态初始化中，数组的大小由花括号内元素的个数自动确定，不需要显式指定。</p></li><li><p>动态初始化：(包含默认初始化)</p><p>int[] b&#x3D;new int [10];</p><p>动态初始化是先声明数组，然后在后续代码中使用 <code>new</code> 关键字为数组分配内存空间并指定数组的大小</p><p><strong>初始化</strong></p><p>不同的数据类型在初始化是会有不同的默认值：</p><ul><li><p>数值类型：0</p></li><li><p>布尔类型：false</p></li><li><p>引用类型（即除基本类型外的）：null</p><p><strong>数组默认初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 数值类型数组</span><br><span class="hljs-type">int</span>[] intArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br><span class="hljs-comment">// 数组元素默认值为 0，依次为：0, 0, 0</span><br><br><span class="hljs-comment">// 布尔类型数组</span><br><span class="hljs-type">boolean</span>[] booleanArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">2</span>];<br><span class="hljs-comment">// 数组元素默认值为 false，依次为：false, false</span><br><br><span class="hljs-comment">// 引用类型数组</span><br>String[] stringArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">4</span>];<br><span class="hljs-comment">// 数组元素默认值为 null，依次为：null, null, null, null</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><hr><p><strong>数组特点</strong>：</p><ul><li>数组是<strong>相同类型</strong>的有序集合，其中的元素可以是任何类型的，包括基本类型和引用类型</li><li>数组也是对象，数组元素相当于对象的成员变量</li><li>数组长度是不可变的</li></ul><h4 id="增强for循环："><a href="#增强for循环：" class="headerlink" title="增强for循环："></a><strong>增强for循环：</strong></h4><p>适合打印输出，不适合操作元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.array;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arrays=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> array : arrays) &#123;<br>            System.out.println(array);<br><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>数组作为方法的参数和返回值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.array;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arrays=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><br>        printArrays(arrays);<br>        <span class="hljs-type">int</span>[]res=reverseArrays(arrays);<br>        printArrays(res);<br><br>    &#125;<br>    <span class="hljs-comment">//打印数组                      数组为参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arrays)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arrays.length;i++)&#123;<br>            System.out.println(arrays[i]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//逆序数组     数组为返回值时，创建新数组作为返回数组</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] reverseArrays(<span class="hljs-type">int</span>[] arrays) &#123;<br>        <span class="hljs-comment">//创建新数组作为结果</span><br>        <span class="hljs-type">int</span>[] result=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arrays.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=arrays.length-<span class="hljs-number">1</span>;i&lt;arrays.length;i++,j--)&#123;<br>            result[j]=arrays[i];<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><hr><p><strong>多维数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.array;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[][] array1=&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;,&#123;<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>&#125;&#125;;<span class="hljs-number">4</span><br>        System.out.println(array1.length);<span class="hljs-comment">//4 行的长度</span><br>        System.out.println(array1[<span class="hljs-number">0</span>].length);<span class="hljs-comment">//3 列的长度</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.array;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[][] array1=&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;,&#123;<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>&#125;&#125;;<br>        <span class="hljs-comment">//for循环输出二维数组</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;array1.length;i++)&#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;array1[i].length;j++)&#123;<br>               System.out.println(array1[i][j]);<br>           &#125;<br>       &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">array</span>s.length;i++)&#123;<br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-built_in">array</span>s[i]);<br>&#125;<br></code></pre></td></tr></table></figure><hr><p><strong>Arrays类</strong></p><p>Arrays类位于 java.util 包中，主要包含了操作数组的各种方法。</p><p>eg:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>        <span class="hljs-comment">//将数组转化为字符串，此时输出结果为字符串类型</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">newArr</span> <span class="hljs-operator">=</span> Arrays.toString(arr);<br>        System.out.println(newArr);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h4><ul><li><p>外层循环:最后一次循环肯定就剩一个数了，所以循环次数为：个数-1次    for(i&#x3D;0;   i&lt;arrar,length-1;i++)</p></li><li><p>内层循环</p><p>每次内层循环是从前（0或1）开始—-&gt;往后</p><p>接下来比较前后两个数并交换，后面的数if小就是小的数一直往后，if大就是大的数一直往后，最终内循环一次结束后，就可以确定出最后面的是最大值或最小值，下一轮需要比较的数的个数就少一个，内循环几次，下一次比较就可以少比较几个 所以 for(j&#x3D;0; j&lt;array.length-1-i;j++)</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arrays=&#123;<span class="hljs-number">12</span>,<span class="hljs-number">34</span>,<span class="hljs-number">23</span>,<span class="hljs-number">44</span>,<span class="hljs-number">38</span>&#125;;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arrays.length-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-type">boolean</span> flag=<span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;arrays.length-<span class="hljs-number">1</span>-i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(arrays[j+<span class="hljs-number">1</span>]&gt;arrays[j])&#123;<br>                    <span class="hljs-type">int</span> temp=arrays[j+<span class="hljs-number">1</span>];<br>                    arrays[j+<span class="hljs-number">1</span>]=arrays[j];<br>                    arrays[j]=temp;<br>                    <span class="hljs-type">boolean</span> flag=<span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arrays.length;i++)&#123;<br>            System.out.println(arrays[i]);<br>        &#125;<br></code></pre></td></tr></table></figure><h4 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a><strong>稀疏数组</strong></h4><p>记录有效值及其行列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhang.array;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome06</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建一个新的目标数组</span><br>        <span class="hljs-type">int</span>[][] arrays1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">11</span>][<span class="hljs-number">11</span>];<br>                arrays1[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br>                arrays1[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] ants:arrays1)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ents:ants)&#123;<br>                System.out.print(ents+<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br><br>        <span class="hljs-comment">//统计有效值,为新建稀疏数组的行数做准备</span><br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arrays1.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;arrays1[i].length;j++)&#123;<br>                <span class="hljs-keyword">if</span> (arrays1[i][j]!=<span class="hljs-number">0</span>)&#123;<br>                    sum++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(sum);<br><br><br><br>        <span class="hljs-comment">//创建稀疏数组及它的第0行（第0行是  原数组的行数 列数   有效值）</span><br>        <span class="hljs-type">int</span>[][] arrays2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[sum+<span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>        arrays2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=arrays1.length;<br>        arrays2[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=arrays1[<span class="hljs-number">0</span>].length;<br>        arrays2[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=sum;<br><br><br>        <span class="hljs-comment">//将有效值放入稀疏数组</span><br>        <span class="hljs-type">int</span> m=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arrays1.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;arrays1[i].length;j++)&#123;<br>                <span class="hljs-keyword">if</span>(arrays1[i][j]!=<span class="hljs-number">0</span>)&#123;<br>                    m++;<br>                    arrays2[m][<span class="hljs-number">0</span>]=i;<br>                    arrays2[m][<span class="hljs-number">1</span>]=j;<br>                    arrays2[m][<span class="hljs-number">2</span>]=arrays1[i][j];<br>                &#125;<br>            &#125;<br>        &#125;<br><br><br><br><br>        <span class="hljs-comment">//打印稀疏数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ants: arrays2)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> ents:ants)&#123;<br>                System.out.print(ents+<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.println();<br><br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="—————"><a href="#—————" class="headerlink" title="—————"></a>—————</h3><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p><strong>本质：</strong><br><u><em>以类的方式组织代码，以对象的组织（封装）数据</em></u></p><p><strong>三大特性：</strong></p><p>封装，继承，多态</p><p><strong>从代码的角度：</strong>先有类才有对象</p><hr><h4 id="回顾方法及加深"><a href="#回顾方法及加深" class="headerlink" title="回顾方法及加深"></a>回顾方法及加深</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome01;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 修饰符  返回类型   方法名（...）&#123;</span><br><span class="hljs-comment">    * //方法体</span><br><span class="hljs-comment">    * return 返回值；</span><br><span class="hljs-comment">    * &#125;*/</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayhello</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> a&gt;b? a:b;<span class="hljs-comment">//三元运算符</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>return&amp;&amp; break:</strong></p><p>return ：标志方法的结束，返回一个结果或者空</p><p>break：跳出switch循环，结束循环</p><p><strong>方法调用：</strong></p><p><em>静态方法</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome01;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><br>    <span class="hljs-comment">//static 静态方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br><br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//**********在下面的程序可以直接在main中调用（类.方法）****************************</span><br><br><br><span class="hljs-keyword">package</span> com.oop.dome01;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Student.say();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><em>非静态方法</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome01;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><br>    <span class="hljs-comment">//非 静态方法</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//****************非静态方法不可直接调用，实例化后再由对象调用（对象.方法）**********************</span><br><br><br><span class="hljs-keyword">package</span> com.oop.dome01;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-comment">//非静态</span><br><br>        <span class="hljs-comment">//先实例化  new</span><br>       Student student1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>       <span class="hljs-comment">//再调用</span><br>       student1.say();<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>加static的方法与类一起加载，非静态的方法，实例化后才存在  </p><p>在同一个类中，可以直接在main方法中调用其他静态方法，</p><p>调用其他非静态的方法：</p><p>1 .在main中先new 实例化，再调用 </p><p>2 .或者 非静态方法改成静态方法（加static）</p><p><strong>值传递&amp;&amp;引用传递：</strong><br>值传递传递形参，另外开辟了一块内存</p><p>引用传递，将类实例化得到实例化对象，实例化对象传递时直接指向同一块内存传递</p><hr><h4 id="类与对象的创建"><a href="#类与对象的创建" class="headerlink" title="类与对象的创建"></a>类与对象的创建</h4><ul><li>一个程序应该只有一个main方法</li></ul><p><strong>使用new关键字创建对象：</strong><br>使用new关键字创建对象时，除了分配内存空间，还会给创建好的对象进行默认的初始化以及类中的构造器的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome02;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><br>    <span class="hljs-comment">//属性： 字段</span><br>    String name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">//方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">//this代表当前这个类，this.当前类的属性</span><br>        System.out.println(<span class="hljs-built_in">this</span>.name+<span class="hljs-string">&quot;在学习&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><br><br><br><br><br><span class="hljs-keyword">package</span> com.oop.dome02;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//类：抽象的，需要实例化</span><br>        <span class="hljs-comment">//类实例化后返回对象</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">xiaoming</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        Student daming=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        <br>        <span class="hljs-comment">//给xiaoming的属性赋值</span><br>        xiaoming.name = <span class="hljs-string">&quot;小明&quot;</span>;<br>        xiaoming.age=<span class="hljs-number">20</span>;<br>        <br>        <span class="hljs-comment">//调用方法</span><br>        xiaoming.study();<span class="hljs-comment">//小明在学习</span><br>        daming.study();<span class="hljs-comment">//null在学习</span><br>       <br>        <span class="hljs-comment">//打印属性</span><br>        System.out.println(xiaoming.name);<span class="hljs-comment">//小明</span><br>        System.out.println(xiaoming.age);<span class="hljs-comment">//20</span><br>        System.out.println(daming.name);<span class="hljs-comment">//null</span><br>        System.out.println(daming.age);<span class="hljs-comment">//0</span><br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>类是对象的模板，对象是类的实例，就像以上Student类中属性name,age不能写死，它只是一个模板，对象就是它的实例，用对象来调用属性进行赋值，[创建对象时默认初始化属性（daming  的name&#x3D;null   age&#x3D;0）]</p><p><strong>所以回到了开始那句话：面向对象编程的本质是：以类的方式组织代码，以对象的组织（封装）数据</strong></p><hr><h4 id="构造器详解"><a href="#构造器详解" class="headerlink" title="构造器详解"></a>构造器详解</h4><ul><li><p>类中的构造器也叫构造方法，是在创建对象时必须调用的，并且构造器具有以下两个特点：<br><em>1 .必须和类的名称相同</em></p><p><em>2 .必须没有返回类型，也不能写void</em></p></li><li><p>一个类即使什么也没有写，<em><strong>它也有一个默认构造器</strong></em></p></li><li><p>显示定义构造器(它其实就是一个特殊的无返回值的方法)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome02;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>构造器的作用：</strong></p><ol><li><p>实例化初始值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome02;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.name=<span class="hljs-string">&quot;lili&quot;</span>;<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-keyword">package</span> com.oop.dome02;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//new 实例化对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        System.out.println(person.name);<span class="hljs-comment">//lili</span><br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>所以实例化对象的属性：</p><ol><li>可以通过在main中实例化对象后用对象.属性赋值(即使用默认无参构造器)，</li><li>可以在类中通过  显示无参构造器（属性写死）</li><li>有参构造器初始化（属性传参   new时传参）</li></ol></li></ol></li></ul><p><strong>有参构造&amp;&amp;无参构造</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome02;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br><br>    <span class="hljs-comment">//new 关键字实例化，本质是在调用构造器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//有参构造：一旦定义了有参构造，无参构造就必须显式定义</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">package</span> com.oop.dome02;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//new 实例化对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;xiaoming&quot;</span>);<span class="hljs-comment">//不加参数调用的就是无参构造器，打印结果为null，加上参数调用有参构造器，打印机结果xiaoming</span><br> <span class="hljs-comment">// Person person1 = new Person(&quot;xiaoming&quot;);=======Person person1=new person();    person1.name=&quot;小明&quot;;     </span><br>        System.out.println(person1.name);<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>new 实例化，本质在调用构造器，会自动根据参数判断，有参数的直接调用有参构造器 （方法重载）。构造器用来初始化值，在构造器中  <code>this.属性</code>  直接就可以赋值</p></li><li><p><u>注意</u>：<em>一旦定义了有参构造，并且也无参实例化了（无参创建对象），无参构造就必须显式定义，否则会报错</em>   </p><p>默认类中是有无参构造的，写了有参构造，无参构造就没有了，就需要显式定义 </p><p>alt+insert 快捷键默认生成有参构造器</p></li><li><p>定义不同有参构造器即方法重载，在类中创建不同的属性，不同属性作为构造器参数实现方法重载</p></li></ul><hr><p><strong>创建对象内存分析</strong></p><p><img src="/2025/03/20/java-%E5%9F%BA%E7%A1%80/image-20250322185600248.png" alt="image-20250322185600248"></p><hr><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><ol><li><p>类是一个模板（抽象的），对象是一个具体的实例</p></li><li><p>方法：定义，调用</p></li><li><p>对象是通过<strong>引用</strong>来操作的：栈—–&gt;堆（地址）</p></li><li><p>属性：字段 Field   成员变量</p><ul><li><p>初始化 ：数字0  0.0 </p><p>​char : u0000</p></li></ul></li></ol><p>​  boolean: false</p><p>​引用： null</p><p>​修饰符    属性类型   属性名&#x3D;属性值</p><ol start="5"><li>对象的创建和使用：<ul><li>必须使用new关键字创造对象  ，构造器</li><li>对象的属性方法调用： <code>对象名.属性   对象.方法</code></li></ul></li><li>类：静态的属性，动态的方法</li></ol><hr><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li><p>程序追求 <em>高内聚低耦合</em></p><p>高内聚就是：类的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用</p></li><li><p>属性私有   get&#x2F;set  （alt  + insert 快捷键生成get&#x2F;set方法）</p></li><li><p>关键字private  就不能直接 s1.name 来操作 借助get方法返回name 调用的方法得到name</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">package</span> com.oop.dome03;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">//属性私有  private 关键字   外部的就不能直接  对象,属性 来操作属性</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> sex;<br><br>    <span class="hljs-comment">//提供一些操作私有属性的方法</span><br>    <span class="hljs-comment">//提供一些public的get /set方法</span><br><br>    <span class="hljs-comment">//get 获得数据  就是借助方法获得</span><br>    <span class="hljs-keyword">public</span>  String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br><br>    <span class="hljs-comment">//set 给这个数据设置值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>&#125;<br><br><br><br><br><br><br><span class="hljs-keyword">package</span> com.oop.dome02;<br><br><span class="hljs-keyword">import</span> com.oop.dome03.Student ;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        System.out.println(s1.getName());<span class="hljs-comment">//null</span><br>        s1.setName(<span class="hljs-string">&quot;小明&quot;</span>);<span class="hljs-comment">//通过方法进行设置属性</span><br>        System.out.println(s1.getName());<span class="hljs-comment">//小明</span><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>思考：</strong>不借助set方法的话，有参构造器也可以直接初始化属性</p><p><em><strong>所以又体现出来构造器就是特殊的方法</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome03;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;xiaoming&quot;</span>);<br>        System.out.println(s1.getName());<br><br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">package</span> com.oop.dome03;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">//属性私有  private 关键字   外部的就不能直接  对象,属性 来操作属性</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> sex;<br><br>    <span class="hljs-comment">//提供一些操作私有属性的方法</span><br>    <span class="hljs-comment">//提供一些public的get /set方法</span><br><br>    <span class="hljs-comment">//get 获得数据  就是借助方法获得</span><br>    <span class="hljs-keyword">public</span>  String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br><br>   <br><span class="hljs-comment">//有参构造器初始化属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用属性的时候再传参即可，构造器在new的时候就会调用，在new的时候直接传参</p><p><strong>封装的好处：</strong></p><p>规避不合法的数据，在set方法中设置条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome03;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><br>        System.out.println(s1.getAge());<br>        s1.setAge(<span class="hljs-number">999</span>);<span class="hljs-comment">//数据不合法</span><br>        System.out.println(s1.getAge());<span class="hljs-comment">//!!!!!！！这里在set方法中设置了合法条件，所以输出3</span><br><br><br>    &#125;<br>&#125;<br><br><br><br><br><br><span class="hljs-keyword">package</span> com.oop.dome03;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">//属性私有  private 关键字   外部的就不能直接  对象,属性 来操作属性</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> sex;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">//提供一些操作私有属性的方法</span><br>    <span class="hljs-comment">//提供一些public的get /set方法</span><br><br>    <span class="hljs-comment">//get 获得数据  就是借助方法获得</span><br>    <span class="hljs-keyword">public</span>  <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age;<br>    &#125;<br><br>    <span class="hljs-comment">//set 给这个数据设置值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>&#123;<br>       <span class="hljs-keyword">if</span>(age&gt;<span class="hljs-number">120</span>||age&lt;<span class="hljs-number">0</span>)&#123;<br>           <span class="hljs-built_in">this</span>.age=<span class="hljs-number">3</span>;<br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>           <span class="hljs-built_in">this</span>.age = age;<br>       &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>好处：</strong></p><ol><li>提高程序的安全性，保护数据</li><li>隐藏代码的实现细节</li><li>统一接口</li><li>系统可维护增加</li></ol><hr><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li><p>继承的本质是对一批类的抽象</p></li><li><p>关键字 extends 子类是父类的扩展</p></li><li><p>继承是类与类之间的一种关系，类与类之间的关系还有依赖，组合，聚合等</p></li><li><p>继承关系的两个类，一个为子类（派生类），一个为父类（基类）。</p></li><li><p><strong>只要子类继承了父类，实例化子类对象，对象也可以用父类中的属性和方法</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//父类</span><br><span class="hljs-keyword">package</span> com.oop.dome04;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> money=<span class="hljs-number">10_0000_0000</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;说了一句话&quot;</span>);<br><br>    &#125;&#125;<br><br><br><br><span class="hljs-comment">//子类继承父类</span><br><span class="hljs-keyword">package</span> com.oop.dome04;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>&#125;<br><br><br><br><span class="hljs-comment">//实例化子类，子类对象调用父类的方法和属性</span><br><span class="hljs-keyword">package</span> com.oop;<br><br><span class="hljs-keyword">import</span> com.oop.dome04.Student;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        student.say();<br>        System.out.println(student.money);<br><br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>修饰符：public（要加public,才能用子类创建的对象调用父类的属性）protected,default,private(私有的   子类不能继承私有属性，要借助get,set)</p><ul><li><p>在java中所有的类都默认直接或间接继承object类，也可以显示定义继承object类</p></li><li><p>java中只有单继承（即一个儿子对应一个爸爸）</p></li><li><p>犯的错误：</p><p>在父类中定义方法无返回值，使用子类创建的对象调用该方法时，因为该方法无返回值，不能直接输出，可以直接调用就好</p></li></ul><hr><h4 id="super详解"><a href="#super详解" class="headerlink" title="super详解"></a>super详解</h4><ul><li><p>子类的方法中访问父类的属性或方法 <code>super.属性或方法</code></p><p>回顾：<code>this.属性或方法</code>调用当前类中的属性或方法</p><p>在方法中可以互相直接调用方法</p></li></ul><p>以下代码实现了 通过子类方法执行类的其他方法，和子类方法中调用父类方法</p><p>Person 父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome04;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>     <span class="hljs-keyword">public</span> String name=<span class="hljs-string">&quot;Person&quot;</span>;<br>     <span class="hljs-type">int</span> age;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>         System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>     &#125;<br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Person&quot;</span>);<br><br>    &#125;<br><br><br>    &#125;<br><br></code></pre></td></tr></table></figure><p>Student 子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome04;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name=<span class="hljs-string">&quot;小明&quot;</span>;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Student&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">text1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">/*print();//Student</span><br><span class="hljs-comment">        System.out.println(this.name);</span><br><span class="hljs-comment">        System.out.println(super.name);*/</span><br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">text2</span><span class="hljs-params">()</span>&#123;<br>        print();<span class="hljs-comment">//方法中调用方法 </span><br>        <span class="hljs-built_in">this</span>.print();<span class="hljs-comment">//调用这个类的print方法</span><br>        <span class="hljs-built_in">super</span>.print();<span class="hljs-comment">//父类的print方法</span><br>        <br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>main:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop;<br><span class="hljs-keyword">import</span> com.oop.dome04.Person;<br><span class="hljs-keyword">import</span> com.oop.dome04.Student;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        s1.text2();<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><p><strong>this   &amp;&amp; super</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">text1</span><span class="hljs-params">(String name)</span>&#123;<br>     print();<span class="hljs-comment">// 此类中的print方法  Student</span><br>     System.out.println(<span class="hljs-built_in">this</span>.name);<span class="hljs-comment">// 就近原则 此类中的name </span><br>     System.out.println(<span class="hljs-built_in">super</span>.name);<span class="hljs-comment">//父类中的属性name</span><br>     System.out.println(name);<span class="hljs-comment">//方法传参的name</span><br><br> &#125;<br></code></pre></td></tr></table></figure><h4 id="有参构造-无参构造"><a href="#有参构造-无参构造" class="headerlink" title="有参构造&amp;&amp; 无参构造"></a><strong>有参构造&amp;&amp; 无参构造</strong></h4><p>以下部分代码 输出： Person无参构造</p><p>​  Student无参构造</p><p><em><strong>new的时候就根据<code>实际类型</code>调用构造器，若是子类构造器，在子类构造器中有隐藏的调用父类构造器的代码 super()</strong></em></p><ul><li><pre><code class="java">Person s1 = new Person();//只调用Person 构造器<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br>*x显示调用父类的构造器必须在子类的构造器第一行*<br><br>``` java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dome01</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        Student s1 = <span class="hljs-keyword">new</span> Student();  <span class="hljs-comment">//输出 Person无参构造  Student无参构造</span><br>       <span class="hljs-comment">// s1.text2();</span><br><br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//*******以下为父类**********</span><br><br>package com.oop.dome04;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;<br>   <br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Person无参构造&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//*********以下为子类*************</span><br><br>package com.oop.dome04;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-title">extends</span> <span class="hljs-title">Person</span> &#123;<br>   <br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span>()</span> &#123;<br>        <span class="hljs-comment">//在子类的构造方法中隐藏代码super()  new的时候调用父类的无参构造</span><br>       <span class="hljs-comment">// super();//调用父类的构造器必须在子类的构造器第一行</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Student无参构造&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></code></pre></li><li><p>当子类定义一个有参构造后，无参构造就会消失，就不会默认new的时候调用父类的无参构造了——&gt;只要定义了一个有参构造，就必须显示定义无参构造</p></li></ul><h4 id="小总结："><a href="#小总结：" class="headerlink" title="小总结："></a><strong>小总结：</strong></h4><ol><li><p>super 注意点：</p><ul><li>super 调用父类的构造方法，必须在构造方法的第一个</li><li><em>super必须只能出现在子类的方法或者构造方法中去调用父类的方法或属性</em></li><li>super() 和this() 不能同时调用构造方法，因为他们都要写在第一行</li></ul></li><li><p>super VS this:<br><em>代表对象不同</em>：this :代表调用者这个对象    super:代表父类对象的应用</p><p><em>前提</em>： this :没有继承也可以使用   super  :  只能在继承条件下才能使用</p><p><em>构造方法</em>：this() 本类的构造       super() 父类的构造</p></li></ol><hr><h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>重写都是方法重写，与属性无关</p><p>方法重写只与非静态方法有关，与静态方法无关</p><p>定义的什么类（等号左边的）就调用的什么类的静态方法，回想之前学的方法的调用，静态方法可以直接用类调用（它随类一起加载）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <br>        <span class="hljs-comment">//方法的调用只和左边，定义的数据类型有关</span><br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        a.test();<span class="hljs-comment">//A类中的方法    结果：A----test</span><br>        <br>        <span class="hljs-comment">//父类的引用指向了子类</span><br>        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        b.test();<span class="hljs-comment">//B类中的方法    结果：B----&gt;test</span><br><span class="hljs-comment">//!!!!它们调用的都是静态方法</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//A类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;A---&gt;test()&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-comment">//B类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;B---&gt;test()&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然而 非静态方法 与以上的静态方法不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        a.test();<span class="hljs-comment">//还是A类输出   A----&gt;test</span><br>        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<span class="hljs-comment">//子类重写了父类的方法 （非静态）</span><br>        b.test();<span class="hljs-comment">//!!!!这里就是调用的A了   输出A---&gt;test</span><br><br><br>    &#125;<br>&#125;<br><br><br><br><br><span class="hljs-keyword">package</span> com.oop.dome05;<br><br><span class="hljs-keyword">import</span> org.w3c.dom.ls.LSOutput;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;A---&gt;test()&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><br><br><br><br><br><span class="hljs-keyword">package</span> com.oop.dome05;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;B---&gt;test()&quot;</span>);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><strong>理解：</strong></p><p>静态方法属于类，非静态方法属于对象</p><p>静态时方法随类一起加载，new 的b 是B类（等号左边），因此执行B类方法</p><p>非静态时，子类重写了父类的方法，都执行子类方法</p><h4 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h4><p>重写存在于子类父类，有了继承才能在子类中重写父类的方法</p><ol><li><p>子类父类的方法名必须相同，（alt+insert快捷键重写方法自动给就可以实现）</p></li><li><p>参数列表也必须相同（不同那就是<del>方法的重载啦</del>，也不是，方法的重载是在一个类中的）</p></li><li><p>子类重写的方法的修饰符范围只能比父类的修饰符扩大，</p><p>public&gt;protected&gt;default(默认什么都不写的)&gt;private</p></li><li><p>抛出异常：范围，可以缩小，不能扩大</p><p>ClassNotFoundException(小异常)—-&gt;Exception(大异常)</p></li></ol><p><strong>为什么需要重写：</strong></p><ol><li><p>父类的功能子类不需要，或者不一定满足！</p><p>快捷键：alt+insert 选择重写方法</p></li></ol><hr><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//引用类型       实际类型</span><br>Person s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>Student s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br></code></pre></td></tr></table></figure><ul><li><p>一个对象的实际类型是确定的，但引用类型是不确定的</p></li><li><p>方法重写后，父类的引用类型调用子类的方法（相比继承：子类继承父类的方法和属性），（多态讲的父类何时能调用子类的方法）</p></li><li><p>当方法只有子类中有的时候，父类调用不了子类的，需要强制类型转换（继承时子类自然继承父类的）</p></li><li><p>对象能执行哪些方法看左边引用类型：</p><p>子类的引用类型能调用继承的父类的方法</p><p>而父类的引用类型不能调用子类独有的（要强制类型转换），能调用子类重写后的</p></li><li><p>注意事项：</p><ol><li><p>多态时方法的重写，属性没有多态</p></li><li><p>创建对象时父类和子类有联系，要注意类型转换异常！ ClassCastException!</p></li><li><p>多态存在条件：继承关系，方法重写，<strong>父类引用指向子类对象</strong></p><p><em>不能重写的方法</em></p><ul><li><p>static 方法，不属于实例，属于类,</p></li><li><p>final  修饰的是常量</p></li><li><p>private 方法</p></li></ul></li></ol></li></ul><hr><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><ul><li><p>instanceof是Java中的一种关键字，用于判断一个对象是否属于某个类或其子类</p></li><li><p>在Java中，instanceof关键字通过比较<code>对象的类型</code>和<code>类的类型</code>来判断对象的实例关系。其底层实现原理是通过比较对象的类型和类的类型在内存中的地址。如果两者相同或者具有继承关系，则返回true；否则返回false。</p></li><li></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop;<br><span class="hljs-keyword">import</span> com.oop.dome06.Person;<br><br><span class="hljs-keyword">import</span> com.oop.dome06.Student;<br><span class="hljs-keyword">import</span> com.oop.dome06.Teacher;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">//引用类型Student         实际类型Student</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        System.out.println(student <span class="hljs-keyword">instanceof</span> Student);<span class="hljs-comment">//ture</span><br>        System.out.println(student <span class="hljs-keyword">instanceof</span> Object);<span class="hljs-comment">//ture</span><br>        System.out.println(student <span class="hljs-keyword">instanceof</span> Person);<span class="hljs-comment">//ture</span><br>       <span class="hljs-comment">//System.out.println(student instanceof Teacher);//编译报错</span><br>      <span class="hljs-comment">//  System.out.println(student instanceof String); 编译报错</span><br><br><br>        <span class="hljs-comment">//引用类型Object         实际类型Student</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        System.out.println(object <span class="hljs-keyword">instanceof</span> Student);<span class="hljs-comment">//ture</span><br>        System.out.println(object <span class="hljs-keyword">instanceof</span> Object);<span class="hljs-comment">//ture</span><br>        System.out.println(object <span class="hljs-keyword">instanceof</span> Person);<span class="hljs-comment">//ture</span><br>        System.out.println(object <span class="hljs-keyword">instanceof</span> Teacher);<span class="hljs-comment">//false</span><br>        System.out.println(object <span class="hljs-keyword">instanceof</span> String);<span class="hljs-comment">// false</span><br>        System.out.println(<span class="hljs-string">&quot;=====================&quot;</span>);<br><br><br><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        System.out.println(person <span class="hljs-keyword">instanceof</span> Student);<span class="hljs-comment">//ture</span><br>        System.out.println(person <span class="hljs-keyword">instanceof</span> Object);<span class="hljs-comment">//ture</span><br>        System.out.println(person <span class="hljs-keyword">instanceof</span> Person);<span class="hljs-comment">//ture</span><br>        System.out.println(person <span class="hljs-keyword">instanceof</span> Teacher);<span class="hljs-comment">//false</span><br>       <span class="hljs-comment">// System.out.println(person instanceof String);// 编译报错</span><br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="小总结：-1"><a href="#小总结：-1" class="headerlink" title="小总结："></a>小总结：</h4><ul><li><p>X  instanceof  Y</p><p>X:对象   Y：类或接口</p><ul><li><p>*<u><strong>编译</strong></u>*：看对象左边的引用类型(如以下例子为:Object)，比较引用类型和Y之间是否存在父子类关系，存在则成功编译。（以上面代码@@@标记处为编译失败的例子）</p></li><li><p>*<u><strong>执行</strong></u>*：看对象右边的实际类型（如以下例子为：Student），比较实际类型和Y之间是否存在父子类关系，存在就输出true 。（以上代码###标记处为输出false的例子）</p><ul><li><p>eg:</p><p>Object s1&#x3D;new Student();&#x3D;&#x3D;父类引用指向子类对象&#x3D;&#x3D;</p><p>System.out.println(s1 instanceof  Student);</p></li></ul></li><li><p>还有一点注意：</p><p>执行比较时：不是比较实际类型嘛，但***必须  实际类型 是Y的子类或就是Y类才输出ture,***实际类型如果是Y的父类则输出false</p><p>(输出false的情况: 实际类型是Y的父类或他们两个不存在父子类关系)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//引用类型Object     实际类型Person</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>System.out.println(object <span class="hljs-keyword">instanceof</span> Student);<span class="hljs-comment">//false  Person是Student的父类输出为false</span><br>System.out.println(object <span class="hljs-keyword">instanceof</span> Object);<span class="hljs-comment">//ture</span><br>System.out.println(object <span class="hljs-keyword">instanceof</span> Person);<span class="hljs-comment">//ture</span><br>System.out.println(object <span class="hljs-keyword">instanceof</span> Teacher);<span class="hljs-comment">//false 同理 Person 是Teacher的父类输出false</span><br>System.out.println(object <span class="hljs-keyword">instanceof</span> String);<span class="hljs-comment">// false 这里就是不存在父子关系输出false</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><p>对象引用类型为父类，不能通过对象调用子类中独有的方法</p><p>如果引用类型为父类，通过对象调用父类子类共有的方法（就是多态啦）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop;<br><span class="hljs-keyword">import</span> com.oop.dome06.Person;<br><br><span class="hljs-keyword">import</span> com.oop.dome06.Student;<br><span class="hljs-keyword">import</span> com.oop.dome06.Teacher;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//类型之间的转换：父----&gt;子</span><br>        <span class="hljs-comment">//  高&lt;---转-----低</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>       <span class="hljs-comment">//引用类型为父类的对象强制类型转换才能调用子类独有的方法</span><br>        ((Student)s).go();<br>        <span class="hljs-comment">//或</span><br>        Student student=(Student)s;<br>        student.go();<br><br>        <span class="hljs-comment">//自动低转高</span><br>        <span class="hljs-comment">//子类转父类可能丢失自己本来的一些方法（只存在于子类中的方法）</span><br>        Person person=student;<br>        <span class="hljs-comment">//person.go(); 就无法调用</span><br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li><p>强制类型转换  存在条件：<strong>父类引用指向子类对象</strong></p><p>直接 父类引用指向父类对象 创建不能强制类型转换（）</p><p>会报ClassCastException的错误</p></li><li><p>父类转换为子类，向下转型，强制转换</p></li></ol><hr><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ul><li><p>非静态方法必须new一个对象后才能用对象调用，</p></li><li><p>静态方法跟类一起就加载出来了，可以直接  类.方法  调用</p><p>在同一个类中也可以直接写方法调用，非静态方法中也是可以调用静态方法的</p></li><li><p>new的时候自动调用静态代码块（只执行一次），匿名代码块，构造方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome07;<br><br><span class="hljs-keyword">import</span> com.sun.security.jgss.GSSUtil;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>   <span class="hljs-comment">//2：赋初始值~</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;匿名代码块&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//1: 只执行一次~</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;静态代码块&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//3：</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;构造方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        System.out.println(<span class="hljs-string">&quot;==========&quot;</span>);<br>        Person p2= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 输出：</span><br><span class="hljs-comment">    * 静态代码块</span><br><span class="hljs-comment">    匿名代码块</span><br><span class="hljs-comment">    构造器</span><br><span class="hljs-comment">    ==========</span><br><span class="hljs-comment">    匿名代码块</span><br><span class="hljs-comment">    构造器*/</span><br>    <br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>发现了一个比较好玩的：</strong></p><p>new的时候调用顺序为静态代码块,匿名代码块，构造方法</p><p>调用构造方法的时候是根据对象的实际类型调用的！</p><ul><li>new Student (),实际类型是子类就调用子类构造器并且先执行之前学习的隐藏代码super()即先调用父类的构造器，再调用子类的构造器</li><li>new Person(),实际类型是父类就直接调用父类构造器了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome07;<br><br><span class="hljs-keyword">import</span> com.sun.security.jgss.GSSUtil;<br><span class="hljs-keyword">import</span> com.oop.dome07.Person;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>   <span class="hljs-comment">//2：赋初始值~</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;匿名代码块&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//1: 只执行一次~</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;静态代码块&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//3：</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;构造方法Person&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        System.out.println(<span class="hljs-string">&quot;==========&quot;</span>);<br>        Person p2= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    &#125;<br>    <span class="hljs-comment">/*静态代码块</span><br><span class="hljs-comment">    匿名代码块</span><br><span class="hljs-comment">    构造方法Person</span><br><span class="hljs-comment">    构造方法：Student</span><br><span class="hljs-comment">    ==========</span><br><span class="hljs-comment">    匿名代码块</span><br><span class="hljs-comment">    构造方法Person*/</span><br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>遗留一个问题：静态代码，匿名代码写在了Person 类中</p><p>new一个 引用属性，实际属性都是Student的对象 也会调用静态代码，匿名代码</p></li></ul><hr><p><strong>静态导入包：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome07;<br><span class="hljs-comment">//静态导入包</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.random;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(random());<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>final 修饰常量，如果类被final修饰是没有办法作为父类继承的</li></ul><p><strong>static 静态方法</strong></p><p>父类是静态方法，子类是不能重写的</p><hr><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li>抽象类本质也是类，是由abstract声明的类 （abstract  class）  extends :单继承    （接口可以实现多继承）</li><li>子类继承抽象类后，必须实现抽象方法，除非该子类也必须声明为抽象类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome08;<br><span class="hljs-comment">//abstract 抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Action</span> &#123;<br>    <span class="hljs-comment">//abstract 抽象方法，只有方法的名字，在抽象类中没有方法体  方法的实现是在继承他的子类中重写实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSonmething</span><span class="hljs-params">()</span>;<br>&#125;<br><br><br><br><br><br><br><br><br><span class="hljs-keyword">package</span> com.oop.dome08;<br><span class="hljs-comment">//继承了抽象类的子类，都必须要实现(相当于重写) 抽象类 的方法（因为抽象类中没有方法体）  普通方法就不一定必须重写了</span><br><span class="hljs-comment">//除非子类也是抽象类,那就由子子类去实现了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Action</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSonmething</span><span class="hljs-params">()</span> &#123;<br>      <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>特点：</strong></p><ol><li>抽象类<strong>不能new,无法实例化</strong>，只能靠子类去实现它</li><li>抽象类里面也可以有普通方法，但一旦有了抽象方法就必须是在抽象类里面</li></ol><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li><p>普通类：只有具体实现方法</p><p>抽象类：具体实现方法和定义（抽象方法）都有！</p><p>接口：只有抽象方法的定义！ 约束和实现分离</p><p>接口的本质是契约，声明接口的关键词是：<u>interface</u></p></li><li><p>接口中定义的所有属性，只能是常量，默认修饰符<strong>public static final</strong></p><p>接口中定义的所有方法，默认什么都不写的修饰符<strong>public abstract</strong> </p></li><li><p>没有构造方法</p></li><li><p><em>实现类：</em>一般以impl结尾   一个类实现一个接口通过 implements 关键字，并且一个实现类必须重写接口里面的所有方法</p></li><li><p>实现类实现多个接口，要重写里面的所有抽象方法，如果接口中的方法重名，只需要在实现类中重写一次即可，重写的方法既代表对接口1中方法的重写，又代表对接口2中的方法的重写</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//**********接口*************</span><br><span class="hljs-keyword">package</span> com.oop.dome09;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<span class="hljs-comment">//接口都需要实现类</span><br>    <span class="hljs-comment">//接口中的所有方法都是默认抽象的 public abstract</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String name)</span>;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String name)</span>;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String name)</span>;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">query</span><span class="hljs-params">(String name)</span>;<br>&#125;<br><br><br><br><span class="hljs-comment">//**********实现方法**************</span><br><br><span class="hljs-keyword">package</span> com.oop.dome09;<br><span class="hljs-comment">//implements关键字 可以实现接口   extends 只能是单继承</span><br><br><span class="hljs-comment">//实现了接口的类，就需要重写接口的方法~</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String name)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String name)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String name)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">query</span><span class="hljs-params">(String name)</span> &#123;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>接口里面定义的都是抽象方法，定义常量   静态常量方法</li></ul><p><strong>作用：</strong></p><ol><li>约束</li><li>在接口中定义一些方法（没有方法体），让不同的 实现类 实现，实现接口必须重写方法</li><li>接口不能实例化，没有构造方法。接口中没有方法实现（和抽象类一样），</li><li>implements 可以实现多个接口</li></ol><hr><p><strong>抽象类和接口的共同点</strong></p><ol><li><p>都是为了让方法抽象，再让子类去实现</p></li><li><p>都不能实例化本类对象，只能让子类实例化对象</p></li></ol><hr><p><strong>接口与类之间的关系：</strong></p><ul><li><p>类于类的关系：继承，只能是单继承，不能多继承，（单继承多继承主体是下一级 单继承   多继承）但可以是多层继承</p></li><li><p>类与接口之间的关系：实现关系，实现类  来  实现接口</p></li><li><p>接口与接口之间的关系：继承关系（也是extends关键字），可以单继承，*<u>也可以多继承</u>*</p><p>若实现类实现的是最下面的子接口的话，需要重写这个体系中所有的抽象方法</p></li></ul><hr><h3 id="N种内部类"><a href="#N种内部类" class="headerlink" title="N种内部类"></a>N种内部类</h3><ul><li>java 一个类 中可以有多个class 但只能有一个public class</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.oop.dome10;<br><br><span class="hljs-keyword">import</span> org.w3c.dom.ls.LSOutput;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id=<span class="hljs-number">105</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">out</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;这是外部类的方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">outPrivate</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;这是外部类的私有方法&quot;</span>);<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Inner</span>&#123;<br><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">in</span><span class="hljs-params">()</span> &#123;<br>           System.out.println(<span class="hljs-string">&quot;这是内部类的方法&quot;</span>);<br>       &#125;<br><br>       <span class="hljs-comment">//内部类写方法访问外部类的私有属性</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(id);<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getOut</span><span class="hljs-params">()</span> &#123;<br>           outPrivate();<span class="hljs-comment">//调用外部方法</span><br>        &#125;<br><br>    &#125;<br>&#125;<br><br><br><br><br><span class="hljs-keyword">package</span> com.oop;<br><span class="hljs-keyword">import</span> com.oop.dome10.Outer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dome01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//实例化外部类</span><br>        <span class="hljs-type">Outer</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br>        <span class="hljs-comment">//通过外部类对象new内部类来实例化内部类~</span><br>        Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> outer.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>        inner.in();<br><br>        <span class="hljs-comment">//内部类实例化对象调用内部类方法实现访问外部类的私有属性</span><br>        inner.getId();<span class="hljs-comment">//内部类获取外部类私有属性</span><br>        inner.getOut();<span class="hljs-comment">//内部类获取外部类私有方法</span><br>        <br>        <span class="hljs-comment">/*输出： 这是内部类的方法</span><br><span class="hljs-comment">                105</span><br><span class="hljs-comment">                这是外部类的私有方法*/</span><br><br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><p>实例化内部类对象时，先实例化一个外部的对象，再通过这个外部对象new内部对象</p><ul><li><pre><code class="java">//实例化外部类Outer outer = new Outer();//通过外部类对象new内部类来实例化内部类~Outer.Inner inner = outer.new Inner();<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br>- ***子类对象访问父类私有属性和方法，内部类对象访问外部类私有属性和方法***，通过在子类或内部类写类似<span class="hljs-keyword">get</span>方法即可获取到<br><br>***<br><br>**静态内部类**<br><br>以上代码的内部类加上<span class="hljs-keyword">static</span> 就是静态内部类了<br><br>- 静态内部类可以直接访问外部类的静态成员，但不能访问外部类的实例成员<br><br>- 静态内部类中   获取外部类的私有属性和方法的代码就会出错：因为先实例化的外部对象，<span class="hljs-keyword">static</span>  静态内部类先加载出来，而外部类的实例成员还没有加载出来<br><br><br><br>**匿名内部类：**<br><br>``` java<br>package com.oop.dome10;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        <span class="hljs-comment">/*Apple apple = new Apple();</span><br><span class="hljs-comment">        apple.eat();*/</span><br><br>        <span class="hljs-comment">//没有名字初始化类，不用将实例保存单变量中~</span><br>        <span class="hljs-keyword">new</span> Apple().eat();<br><br><br>        <span class="hljs-comment">//new 接口实例化对象</span><br>        <span class="hljs-comment">//下面这个类其实就是一个实现类，匿名内部类</span><br>        UserService userService = <span class="hljs-keyword">new</span> UserService() &#123;<br>            <span class="hljs-comment">//不重写接口方法的话会报错</span><br>            @Override<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span>()</span> &#123;<br>                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>            &#125;<br><br>        &#125;;<span class="hljs-comment">//注意这里的分号</span><br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//下面的在Test类外面写</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hello</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><hr><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>Exception</p><ul><li><p>异常指程序运行中出现的不期而至的各种状况：文件找不到，网络连接失败，非法参数，异常发生在程序运行期间，它影响了程序正常执行流程</p><ul><li><pre><code class="java">int a=10int b=0;int res=a/b;//1.异常是程序当执行到a/b 时，因为 b=0,程序就会出现（抛出）异常，ArithmeticException（算术异常）//2.当抛出异常后，程序就退出，崩溃了//3.这样一个不算致命的错误导致程序崩溃  不好//4.所以需要异常处理机制来解决这个问题System.out.println(&quot;程序继续运行&quot;)；<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs php"><br>- 异常分为两大类：<br><br>  <span class="hljs-built_in">Error</span>：(错误) JVM无法解决的严重错误 eg: 栈溢出   <span class="hljs-built_in">Error</span> 是严重错误，程序会崩溃<br><br>  Excpetion:  分为两大类： 运行时异常（程序运行时异常）和编译时异常（编程时编译器就检查出异常）<br><br>- java把异常当作对象来处理，并定义一个基类java.lang.<span class="hljs-built_in">Throwable</span> 作为所有异常的超类<br><br>***<br><br><br><br><span class="hljs-comment">#### **异常处理机制**</span><br><br>- 进行了异常处理，即使出现了异常，程序仍可继续执行<br><br>  <br><br>*<span class="hljs-keyword">try</span>-<span class="hljs-keyword">catch</span>-<span class="hljs-keyword">finally</span>*<br><br>- 将一段可能有问题的代码选中 ctrl+alt+t 使用<span class="hljs-keyword">try</span>-<span class="hljs-keyword">catch</span>-<span class="hljs-keyword">finally</span> 捕获<br><br>  ```java<br>  <span class="hljs-keyword">try</span>&#123;<br>      <span class="hljs-comment">//可能异常的代码</span><br>  &#125;<span class="hljs-keyword">catch</span>(<span class="hljs-built_in">Exception</span> e)&#123;<br>      <span class="hljs-comment">//当捕获到异常时，系统将异常封装成Exception 对象e  传递给catch</span><br>  &#125;<span class="hljs-keyword">finally</span>&#123;<br>      <span class="hljs-comment">//不管try代码块是否有异常，最终都要执行finally</span><br>      <span class="hljs-comment">//所以一般将关闭资源放在finally中</span><br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p><em>throws</em>（投掷）</p><ul><li><p>try-catch-finally 和throws 二选一，程序员如果没有显示处理异常，默认throws</p></li><li><p>将发生的异常抛出，交给调用者（方法来处理），最顶级的处理者就是JVM</p><p>throw 后面的异常类型可以是方法中产生的异常类型，也可以是它的父类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.exception;<br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Throws01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">f2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException,NullPointerException ,ArithmeticException &#123;<br>        <span class="hljs-comment">//创建了一个文件流对象</span><br>        <span class="hljs-comment">//1.这里异常是一个编译异常 FileNotFoundException</span><br>        <span class="hljs-comment">//2.可以使用try-catch-finally</span><br>        <span class="hljs-comment">//3. 使用throws ，抛出异常，放调用f2的调用者（方法）处理</span><br>        <span class="hljs-comment">//4.throws 后面的异常类型可以是方法中产生的异常类型，也可以是它的父类</span><br>        <span class="hljs-comment">//5. throws 后面的关键字也可以是抛出多个异常</span><br>        <br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;d://aa.txt&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/2025/03/20/java-%E5%9F%BA%E7%A1%80/image-20250326094727521-17429950120406.png" alt="image-20250326094727521"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.exception;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//快捷键 ctrl +alt+ t</span><br>        <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//try 监控区</span><br>            System.out.println(a/b);<br>        &#125;<span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<span class="hljs-comment">//catch 捕获异常</span><br>            System.out.println(<span class="hljs-string">&quot;程序异常，变量b不能为0&quot;</span>);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">//处理善后工作    ！！！！没有捕获到错误也是执行的</span><br>            System.out.println(<span class="hljs-string">&quot;finally&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//finally 可以不要   后续学习的 IO流 资源需要关闭！</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>捕获多个异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.exception;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;<br><br><br><br>        <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//try 监控区</span><br>            <span class="hljs-keyword">if</span> (b==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArithmeticException</span>();<span class="hljs-comment">//主动的抛出异常</span><br>            &#125;<br><br>            System.out.println(a/b);<br>        &#125;<span class="hljs-keyword">catch</span> (Error e) &#123;<span class="hljs-comment">//catch 捕获异常</span><br>            System.out.println(<span class="hljs-string">&quot;Error&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Exception&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span>(Throwable e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Exception&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;finally&quot;</span>);<br>        &#125;<br><br>      <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://segmentfault.com/a/1190000045396203">Java异常详解(全文干货) - 个人文章 - SegmentFault 思否</a></p><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>当程序中出现了某些“错误”，但该错误信息并没有在Throwable子类中描述处理，这个时候可以自己设计异常类，用于描述该错误信息</p><p><strong>步骤：</strong></p><ol><li>定义类：自定义异常类名，继承Exception 或RuntimeException </li><li>如果继承Exception ，属于编译异常</li><li>如果继承RuntimeException ，属于运行异常（一般都是继承RuntimeExceptipn）</li></ol><p>即我们把自定义异常作为运行时异常（好处可以使用默认的处理机制）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.exception;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomExcepption</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <span class="hljs-comment">/*throws AgeException*/</span><br>        <span class="hljs-type">int</span> age=<span class="hljs-number">818</span>;<br>        <span class="hljs-keyword">if</span> (!(age&gt;=<span class="hljs-number">18</span> &amp;&amp; age&lt;=<span class="hljs-number">120</span>))&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelfException</span>(<span class="hljs-string">&quot;年龄需要在18~120之间&quot;</span>);<span class="hljs-comment">//new 自定义异常类，才能调用构造方法</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;你的年龄范围正确&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//自定义类名 继承 运行异常 就变成  自定义异常   一般情况下自定义异常是继承编译异常 （好处：我们可以使用默认的处理机制）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SelfException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SelfException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/03/20/java-%E5%9F%BA%E7%A1%80/image-20250326192411669-17429941347282.png" alt="image-20250326192411669"></p><hr><p><strong>throw vs throws:</strong></p><ul><li><p>throws :代表异常处理方式    位于方法声明中   后面跟异常类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throws</span> AgeException<br></code></pre></td></tr></table></figure></li><li><p>throw: 是手动生创建异常对象的关键字    位于方法体中   后面跟异常对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelfException</span>(<span class="hljs-string">&quot;年龄需要在18~120之间&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2024/12/20/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2024/12/20/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><img src="/2024/12/20/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/12/20/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.png" class title="图片引用方法一"><p><img src="/2024/12/20/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.png" alt="图片引用方法二"></p><p><img src="/images/test.png" alt="图片引用方法三"></p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>123</tag>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
